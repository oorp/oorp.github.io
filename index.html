<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<!--[if IE]><meta http-equiv="X-UA-Compatible" content="IE=edge"><![endif]-->
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<meta name="generator" content="Asciidoctor 1.5.3">
<meta name="author" content="Serge Demeyer, StÃ©phane Ducasse, Oscar Nierstraszv">
<title>Object-Oriented Reengineering Patterns</title>
<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:300,300italic,400,400italic,600,600italic%7CNoto+Serif:400,400italic,700,700italic%7CDroid+Sans+Mono:400,700">
<style>
/* Asciidoctor default stylesheet | MIT License | http://asciidoctor.org */
/* Remove comment around @import statement below when using as a custom stylesheet */
/*@import "https://fonts.googleapis.com/css?family=Open+Sans:300,300italic,400,400italic,600,600italic%7CNoto+Serif:400,400italic,700,700italic%7CDroid+Sans+Mono:400,700";*/
article,aside,details,figcaption,figure,footer,header,hgroup,main,nav,section,summary{display:block}
audio,canvas,video{display:inline-block}
audio:not([controls]){display:none;height:0}
[hidden],template{display:none}
script{display:none!important}
html{font-family:sans-serif;-ms-text-size-adjust:100%;-webkit-text-size-adjust:100%}
body{margin:0}
a{background:transparent}
a:focus{outline:thin dotted}
a:active,a:hover{outline:0}
h1{font-size:2em;margin:.67em 0}
abbr[title]{border-bottom:1px dotted}
b,strong{font-weight:bold}
dfn{font-style:italic}
hr{-moz-box-sizing:content-box;box-sizing:content-box;height:0}
mark{background:#ff0;color:#000}
code,kbd,pre,samp{font-family:monospace;font-size:1em}
pre{white-space:pre-wrap}
q{quotes:"\201C" "\201D" "\2018" "\2019"}
small{font-size:80%}
sub,sup{font-size:75%;line-height:0;position:relative;vertical-align:baseline}
sup{top:-.5em}
sub{bottom:-.25em}
img{border:0}
svg:not(:root){overflow:hidden}
figure{margin:0}
fieldset{border:1px solid silver;margin:0 2px;padding:.35em .625em .75em}
legend{border:0;padding:0}
button,input,select,textarea{font-family:inherit;font-size:100%;margin:0}
button,input{line-height:normal}
button,select{text-transform:none}
button,html input[type="button"],input[type="reset"],input[type="submit"]{-webkit-appearance:button;cursor:pointer}
button[disabled],html input[disabled]{cursor:default}
input[type="checkbox"],input[type="radio"]{box-sizing:border-box;padding:0}
input[type="search"]{-webkit-appearance:textfield;-moz-box-sizing:content-box;-webkit-box-sizing:content-box;box-sizing:content-box}
input[type="search"]::-webkit-search-cancel-button,input[type="search"]::-webkit-search-decoration{-webkit-appearance:none}
button::-moz-focus-inner,input::-moz-focus-inner{border:0;padding:0}
textarea{overflow:auto;vertical-align:top}
table{border-collapse:collapse;border-spacing:0}
*,*:before,*:after{-moz-box-sizing:border-box;-webkit-box-sizing:border-box;box-sizing:border-box}
html,body{font-size:100%}
body{background:#fff;color:rgba(0,0,0,.8);padding:0;margin:0;font-family:"Noto Serif","DejaVu Serif",serif;font-weight:400;font-style:normal;line-height:1;position:relative;cursor:auto}
a:hover{cursor:pointer}
img,object,embed{max-width:100%;height:auto}
object,embed{height:100%}
img{-ms-interpolation-mode:bicubic}
.left{float:left!important}
.right{float:right!important}
.text-left{text-align:left!important}
.text-right{text-align:right!important}
.text-center{text-align:center!important}
.text-justify{text-align:justify!important}
.hide{display:none}
body{-webkit-font-smoothing:antialiased}
img,object,svg{display:inline-block;vertical-align:middle}
textarea{height:auto;min-height:50px}
select{width:100%}
.center{margin-left:auto;margin-right:auto}
.spread{width:100%}
p.lead,.paragraph.lead>p,#preamble>.sectionbody>.paragraph:first-of-type p{font-size:1.21875em;line-height:1.6}
.subheader,.admonitionblock td.content>.title,.audioblock>.title,.exampleblock>.title,.imageblock>.title,.listingblock>.title,.literalblock>.title,.stemblock>.title,.openblock>.title,.paragraph>.title,.quoteblock>.title,table.tableblock>.title,.verseblock>.title,.videoblock>.title,.dlist>.title,.olist>.title,.ulist>.title,.qlist>.title,.hdlist>.title{line-height:1.45;color:#7a2518;font-weight:400;margin-top:0;margin-bottom:.25em}
div,dl,dt,dd,ul,ol,li,h1,h2,h3,#toctitle,.sidebarblock>.content>.title,h4,h5,h6,pre,form,p,blockquote,th,td{margin:0;padding:0;direction:ltr}
a{color:#2156a5;text-decoration:underline;line-height:inherit}
a:hover,a:focus{color:#1d4b8f}
a img{border:none}
p{font-family:inherit;font-weight:400;font-size:1em;line-height:1.6;margin-bottom:1.25em;text-rendering:optimizeLegibility}
p aside{font-size:.875em;line-height:1.35;font-style:italic}
h1,h2,h3,#toctitle,.sidebarblock>.content>.title,h4,h5,h6{font-family:"Open Sans","DejaVu Sans",sans-serif;font-weight:300;font-style:normal;color:#ba3925;text-rendering:optimizeLegibility;margin-top:1em;margin-bottom:.5em;line-height:1.0125em}
h1 small,h2 small,h3 small,#toctitle small,.sidebarblock>.content>.title small,h4 small,h5 small,h6 small{font-size:60%;color:#e99b8f;line-height:0}
h1{font-size:2.125em}
h2{font-size:1.6875em}
h3,#toctitle,.sidebarblock>.content>.title{font-size:1.375em}
h4,h5{font-size:1.125em}
h6{font-size:1em}
hr{border:solid #ddddd8;border-width:1px 0 0;clear:both;margin:1.25em 0 1.1875em;height:0}
em,i{font-style:italic;line-height:inherit}
strong,b{font-weight:bold;line-height:inherit}
small{font-size:60%;line-height:inherit}
code{font-family:"Droid Sans Mono","DejaVu Sans Mono",monospace;font-weight:400;color:rgba(0,0,0,.9)}
ul,ol,dl{font-size:1em;line-height:1.6;margin-bottom:1.25em;list-style-position:outside;font-family:inherit}
ul,ol,ul.no-bullet,ol.no-bullet{margin-left:1.5em}
ul li ul,ul li ol{margin-left:1.25em;margin-bottom:0;font-size:1em}
ul.square li ul,ul.circle li ul,ul.disc li ul{list-style:inherit}
ul.square{list-style-type:square}
ul.circle{list-style-type:circle}
ul.disc{list-style-type:disc}
ul.no-bullet{list-style:none}
ol li ul,ol li ol{margin-left:1.25em;margin-bottom:0}
dl dt{margin-bottom:.3125em;font-weight:bold}
dl dd{margin-bottom:1.25em}
abbr,acronym{text-transform:uppercase;font-size:90%;color:rgba(0,0,0,.8);border-bottom:1px dotted #ddd;cursor:help}
abbr{text-transform:none}
blockquote{margin:0 0 1.25em;padding:.5625em 1.25em 0 1.1875em;border-left:1px solid #ddd}
blockquote cite{display:block;font-size:.9375em;color:rgba(0,0,0,.6)}
blockquote cite:before{content:"\2014 \0020"}
blockquote cite a,blockquote cite a:visited{color:rgba(0,0,0,.6)}
blockquote,blockquote p{line-height:1.6;color:rgba(0,0,0,.85)}
@media only screen and (min-width:768px){h1,h2,h3,#toctitle,.sidebarblock>.content>.title,h4,h5,h6{line-height:1.2}
h1{font-size:2.75em}
h2{font-size:2.3125em}
h3,#toctitle,.sidebarblock>.content>.title{font-size:1.6875em}
h4{font-size:1.4375em}}
table{background:#fff;margin-bottom:1.25em;border:solid 1px #dedede}
table thead,table tfoot{background:#f7f8f7;font-weight:bold}
table thead tr th,table thead tr td,table tfoot tr th,table tfoot tr td{padding:.5em .625em .625em;font-size:inherit;color:rgba(0,0,0,.8);text-align:left}
table tr th,table tr td{padding:.5625em .625em;font-size:inherit;color:rgba(0,0,0,.8)}
table tr.even,table tr.alt,table tr:nth-of-type(even){background:#f8f8f7}
table thead tr th,table tfoot tr th,table tbody tr td,table tr td,table tfoot tr td{display:table-cell;line-height:1.6}
body{tab-size:4}
h1,h2,h3,#toctitle,.sidebarblock>.content>.title,h4,h5,h6{line-height:1.2;word-spacing:-.05em}
h1 strong,h2 strong,h3 strong,#toctitle strong,.sidebarblock>.content>.title strong,h4 strong,h5 strong,h6 strong{font-weight:400}
.clearfix:before,.clearfix:after,.float-group:before,.float-group:after{content:" ";display:table}
.clearfix:after,.float-group:after{clear:both}
*:not(pre)>code{font-size:.9375em;font-style:normal!important;letter-spacing:0;padding:.1em .5ex;word-spacing:-.15em;background-color:#f7f7f8;-webkit-border-radius:4px;border-radius:4px;line-height:1.45;text-rendering:optimizeSpeed}
pre,pre>code{line-height:1.45;color:rgba(0,0,0,.9);font-family:"Droid Sans Mono","DejaVu Sans Mono",monospace;font-weight:400;text-rendering:optimizeSpeed}
.keyseq{color:rgba(51,51,51,.8)}
kbd{font-family:"Droid Sans Mono","DejaVu Sans Mono",monospace;display:inline-block;color:rgba(0,0,0,.8);font-size:.65em;line-height:1.45;background-color:#f7f7f7;border:1px solid #ccc;-webkit-border-radius:3px;border-radius:3px;-webkit-box-shadow:0 1px 0 rgba(0,0,0,.2),0 0 0 .1em white inset;box-shadow:0 1px 0 rgba(0,0,0,.2),0 0 0 .1em #fff inset;margin:0 .15em;padding:.2em .5em;vertical-align:middle;position:relative;top:-.1em;white-space:nowrap}
.keyseq kbd:first-child{margin-left:0}
.keyseq kbd:last-child{margin-right:0}
.menuseq,.menu{color:rgba(0,0,0,.8)}
b.button:before,b.button:after{position:relative;top:-1px;font-weight:400}
b.button:before{content:"[";padding:0 3px 0 2px}
b.button:after{content:"]";padding:0 2px 0 3px}
p a>code:hover{color:rgba(0,0,0,.9)}
#header,#content,#footnotes,#footer{width:100%;margin-left:auto;margin-right:auto;margin-top:0;margin-bottom:0;max-width:62.5em;*zoom:1;position:relative;padding-left:.9375em;padding-right:.9375em}
#header:before,#header:after,#content:before,#content:after,#footnotes:before,#footnotes:after,#footer:before,#footer:after{content:" ";display:table}
#header:after,#content:after,#footnotes:after,#footer:after{clear:both}
#content{margin-top:1.25em}
#content:before{content:none}
#header>h1:first-child{color:rgba(0,0,0,.85);margin-top:2.25rem;margin-bottom:0}
#header>h1:first-child+#toc{margin-top:8px;border-top:1px solid #ddddd8}
#header>h1:only-child,body.toc2 #header>h1:nth-last-child(2){border-bottom:1px solid #ddddd8;padding-bottom:8px}
#header .details{border-bottom:1px solid #ddddd8;line-height:1.45;padding-top:.25em;padding-bottom:.25em;padding-left:.25em;color:rgba(0,0,0,.6);display:-ms-flexbox;display:-webkit-flex;display:flex;-ms-flex-flow:row wrap;-webkit-flex-flow:row wrap;flex-flow:row wrap}
#header .details span:first-child{margin-left:-.125em}
#header .details span.email a{color:rgba(0,0,0,.85)}
#header .details br{display:none}
#header .details br+span:before{content:"\00a0\2013\00a0"}
#header .details br+span.author:before{content:"\00a0\22c5\00a0";color:rgba(0,0,0,.85)}
#header .details br+span#revremark:before{content:"\00a0|\00a0"}
#header #revnumber{text-transform:capitalize}
#header #revnumber:after{content:"\00a0"}
#content>h1:first-child:not([class]){color:rgba(0,0,0,.85);border-bottom:1px solid #ddddd8;padding-bottom:8px;margin-top:0;padding-top:1rem;margin-bottom:1.25rem}
#toc{border-bottom:1px solid #efefed;padding-bottom:.5em}
#toc>ul{margin-left:.125em}
#toc ul.sectlevel0>li>a{font-style:italic}
#toc ul.sectlevel0 ul.sectlevel1{margin:.5em 0}
#toc ul{font-family:"Open Sans","DejaVu Sans",sans-serif;list-style-type:none}
#toc li{line-height:1.3334;margin-top:.3334em}
#toc a{text-decoration:none}
#toc a:active{text-decoration:underline}
#toctitle{color:#7a2518;font-size:1.2em}
@media only screen and (min-width:768px){#toctitle{font-size:1.375em}
body.toc2{padding-left:15em;padding-right:0}
#toc.toc2{margin-top:0!important;background-color:#f8f8f7;position:fixed;width:15em;left:0;top:0;border-right:1px solid #efefed;border-top-width:0!important;border-bottom-width:0!important;z-index:1000;padding:1.25em 1em;height:100%;overflow:auto}
#toc.toc2 #toctitle{margin-top:0;margin-bottom:.8rem;font-size:1.2em}
#toc.toc2>ul{font-size:.9em;margin-bottom:0}
#toc.toc2 ul ul{margin-left:0;padding-left:1em}
#toc.toc2 ul.sectlevel0 ul.sectlevel1{padding-left:0;margin-top:.5em;margin-bottom:.5em}
body.toc2.toc-right{padding-left:0;padding-right:15em}
body.toc2.toc-right #toc.toc2{border-right-width:0;border-left:1px solid #efefed;left:auto;right:0}}
@media only screen and (min-width:1280px){body.toc2{padding-left:20em;padding-right:0}
#toc.toc2{width:20em}
#toc.toc2 #toctitle{font-size:1.375em}
#toc.toc2>ul{font-size:.95em}
#toc.toc2 ul ul{padding-left:1.25em}
body.toc2.toc-right{padding-left:0;padding-right:20em}}
#content #toc{border-style:solid;border-width:1px;border-color:#e0e0dc;margin-bottom:1.25em;padding:1.25em;background:#f8f8f7;-webkit-border-radius:4px;border-radius:4px}
#content #toc>:first-child{margin-top:0}
#content #toc>:last-child{margin-bottom:0}
#footer{max-width:100%;background-color:rgba(0,0,0,.8);padding:1.25em}
#footer-text{color:rgba(255,255,255,.8);line-height:1.44}
.sect1{padding-bottom:.625em}
@media only screen and (min-width:768px){.sect1{padding-bottom:1.25em}}
.sect1+.sect1{border-top:1px solid #efefed}
#content h1>a.anchor,h2>a.anchor,h3>a.anchor,#toctitle>a.anchor,.sidebarblock>.content>.title>a.anchor,h4>a.anchor,h5>a.anchor,h6>a.anchor{position:absolute;z-index:1001;width:1.5ex;margin-left:-1.5ex;display:block;text-decoration:none!important;visibility:hidden;text-align:center;font-weight:400}
#content h1>a.anchor:before,h2>a.anchor:before,h3>a.anchor:before,#toctitle>a.anchor:before,.sidebarblock>.content>.title>a.anchor:before,h4>a.anchor:before,h5>a.anchor:before,h6>a.anchor:before{content:"\00A7";font-size:.85em;display:block;padding-top:.1em}
#content h1:hover>a.anchor,#content h1>a.anchor:hover,h2:hover>a.anchor,h2>a.anchor:hover,h3:hover>a.anchor,#toctitle:hover>a.anchor,.sidebarblock>.content>.title:hover>a.anchor,h3>a.anchor:hover,#toctitle>a.anchor:hover,.sidebarblock>.content>.title>a.anchor:hover,h4:hover>a.anchor,h4>a.anchor:hover,h5:hover>a.anchor,h5>a.anchor:hover,h6:hover>a.anchor,h6>a.anchor:hover{visibility:visible}
#content h1>a.link,h2>a.link,h3>a.link,#toctitle>a.link,.sidebarblock>.content>.title>a.link,h4>a.link,h5>a.link,h6>a.link{color:#ba3925;text-decoration:none}
#content h1>a.link:hover,h2>a.link:hover,h3>a.link:hover,#toctitle>a.link:hover,.sidebarblock>.content>.title>a.link:hover,h4>a.link:hover,h5>a.link:hover,h6>a.link:hover{color:#a53221}
.audioblock,.imageblock,.literalblock,.listingblock,.stemblock,.videoblock{margin-bottom:1.25em}
.admonitionblock td.content>.title,.audioblock>.title,.exampleblock>.title,.imageblock>.title,.listingblock>.title,.literalblock>.title,.stemblock>.title,.openblock>.title,.paragraph>.title,.quoteblock>.title,table.tableblock>.title,.verseblock>.title,.videoblock>.title,.dlist>.title,.olist>.title,.ulist>.title,.qlist>.title,.hdlist>.title{text-rendering:optimizeLegibility;text-align:left;font-family:"Noto Serif","DejaVu Serif",serif;font-size:1rem;font-style:italic}
table.tableblock>caption.title{white-space:nowrap;overflow:visible;max-width:0}
.paragraph.lead>p,#preamble>.sectionbody>.paragraph:first-of-type p{color:rgba(0,0,0,.85)}
table.tableblock #preamble>.sectionbody>.paragraph:first-of-type p{font-size:inherit}
.admonitionblock>table{border-collapse:separate;border:0;background:none;width:100%}
.admonitionblock>table td.icon{text-align:center;width:80px}
.admonitionblock>table td.icon img{max-width:none}
.admonitionblock>table td.icon .title{font-weight:bold;font-family:"Open Sans","DejaVu Sans",sans-serif;text-transform:uppercase}
.admonitionblock>table td.content{padding-left:1.125em;padding-right:1.25em;border-left:1px solid #ddddd8;color:rgba(0,0,0,.6)}
.admonitionblock>table td.content>:last-child>:last-child{margin-bottom:0}
.exampleblock>.content{border-style:solid;border-width:1px;border-color:#e6e6e6;margin-bottom:1.25em;padding:1.25em;background:#fff;-webkit-border-radius:4px;border-radius:4px}
.exampleblock>.content>:first-child{margin-top:0}
.exampleblock>.content>:last-child{margin-bottom:0}
.sidebarblock{border-style:solid;border-width:1px;border-color:#e0e0dc;margin-bottom:1.25em;padding:1.25em;background:#f8f8f7;-webkit-border-radius:4px;border-radius:4px}
.sidebarblock>:first-child{margin-top:0}
.sidebarblock>:last-child{margin-bottom:0}
.sidebarblock>.content>.title{color:#7a2518;margin-top:0;text-align:center}
.exampleblock>.content>:last-child>:last-child,.exampleblock>.content .olist>ol>li:last-child>:last-child,.exampleblock>.content .ulist>ul>li:last-child>:last-child,.exampleblock>.content .qlist>ol>li:last-child>:last-child,.sidebarblock>.content>:last-child>:last-child,.sidebarblock>.content .olist>ol>li:last-child>:last-child,.sidebarblock>.content .ulist>ul>li:last-child>:last-child,.sidebarblock>.content .qlist>ol>li:last-child>:last-child{margin-bottom:0}
.literalblock pre,.listingblock pre:not(.highlight),.listingblock pre[class="highlight"],.listingblock pre[class^="highlight "],.listingblock pre.CodeRay,.listingblock pre.prettyprint{background:#f7f7f8}
.sidebarblock .literalblock pre,.sidebarblock .listingblock pre:not(.highlight),.sidebarblock .listingblock pre[class="highlight"],.sidebarblock .listingblock pre[class^="highlight "],.sidebarblock .listingblock pre.CodeRay,.sidebarblock .listingblock pre.prettyprint{background:#f2f1f1}
.literalblock pre,.literalblock pre[class],.listingblock pre,.listingblock pre[class]{-webkit-border-radius:4px;border-radius:4px;word-wrap:break-word;padding:1em;font-size:.8125em}
.literalblock pre.nowrap,.literalblock pre[class].nowrap,.listingblock pre.nowrap,.listingblock pre[class].nowrap{overflow-x:auto;white-space:pre;word-wrap:normal}
@media only screen and (min-width:768px){.literalblock pre,.literalblock pre[class],.listingblock pre,.listingblock pre[class]{font-size:.90625em}}
@media only screen and (min-width:1280px){.literalblock pre,.literalblock pre[class],.listingblock pre,.listingblock pre[class]{font-size:1em}}
.literalblock.output pre{color:#f7f7f8;background-color:rgba(0,0,0,.9)}
.listingblock pre.highlightjs{padding:0}
.listingblock pre.highlightjs>code{padding:1em;-webkit-border-radius:4px;border-radius:4px}
.listingblock pre.prettyprint{border-width:0}
.listingblock>.content{position:relative}
.listingblock code[data-lang]:before{display:none;content:attr(data-lang);position:absolute;font-size:.75em;top:.425rem;right:.5rem;line-height:1;text-transform:uppercase;color:#999}
.listingblock:hover code[data-lang]:before{display:block}
.listingblock.terminal pre .command:before{content:attr(data-prompt);padding-right:.5em;color:#999}
.listingblock.terminal pre .command:not([data-prompt]):before{content:"$"}
table.pyhltable{border-collapse:separate;border:0;margin-bottom:0;background:none}
table.pyhltable td{vertical-align:top;padding-top:0;padding-bottom:0;line-height:1.45}
table.pyhltable td.code{padding-left:.75em;padding-right:0}
pre.pygments .lineno,table.pyhltable td:not(.code){color:#999;padding-left:0;padding-right:.5em;border-right:1px solid #ddddd8}
pre.pygments .lineno{display:inline-block;margin-right:.25em}
table.pyhltable .linenodiv{background:none!important;padding-right:0!important}
.quoteblock{margin:0 1em 1.25em 1.5em;display:table}
.quoteblock>.title{margin-left:-1.5em;margin-bottom:.75em}
.quoteblock blockquote,.quoteblock blockquote p{color:rgba(0,0,0,.85);font-size:1.15rem;line-height:1.75;word-spacing:.1em;letter-spacing:0;font-style:italic;text-align:justify}
.quoteblock blockquote{margin:0;padding:0;border:0}
.quoteblock blockquote:before{content:"\201c";float:left;font-size:2.75em;font-weight:bold;line-height:.6em;margin-left:-.6em;color:#7a2518;text-shadow:0 1px 2px rgba(0,0,0,.1)}
.quoteblock blockquote>.paragraph:last-child p{margin-bottom:0}
.quoteblock .attribution{margin-top:.5em;margin-right:.5ex;text-align:right}
.quoteblock .quoteblock{margin-left:0;margin-right:0;padding:.5em 0;border-left:3px solid rgba(0,0,0,.6)}
.quoteblock .quoteblock blockquote{padding:0 0 0 .75em}
.quoteblock .quoteblock blockquote:before{display:none}
.verseblock{margin:0 1em 1.25em 1em}
.verseblock pre{font-family:"Open Sans","DejaVu Sans",sans;font-size:1.15rem;color:rgba(0,0,0,.85);font-weight:300;text-rendering:optimizeLegibility}
.verseblock pre strong{font-weight:400}
.verseblock .attribution{margin-top:1.25rem;margin-left:.5ex}
.quoteblock .attribution,.verseblock .attribution{font-size:.9375em;line-height:1.45;font-style:italic}
.quoteblock .attribution br,.verseblock .attribution br{display:none}
.quoteblock .attribution cite,.verseblock .attribution cite{display:block;letter-spacing:-.025em;color:rgba(0,0,0,.6)}
.quoteblock.abstract{margin:0 0 1.25em 0;display:block}
.quoteblock.abstract blockquote,.quoteblock.abstract blockquote p{text-align:left;word-spacing:0}
.quoteblock.abstract blockquote:before,.quoteblock.abstract blockquote p:first-of-type:before{display:none}
table.tableblock{max-width:100%;border-collapse:separate}
table.tableblock td>.paragraph:last-child p>p:last-child,table.tableblock th>p:last-child,table.tableblock td>p:last-child{margin-bottom:0}
table.tableblock,th.tableblock,td.tableblock{border:0 solid #dedede}
table.grid-all th.tableblock,table.grid-all td.tableblock{border-width:0 1px 1px 0}
table.grid-all tfoot>tr>th.tableblock,table.grid-all tfoot>tr>td.tableblock{border-width:1px 1px 0 0}
table.grid-cols th.tableblock,table.grid-cols td.tableblock{border-width:0 1px 0 0}
table.grid-all *>tr>.tableblock:last-child,table.grid-cols *>tr>.tableblock:last-child{border-right-width:0}
table.grid-rows th.tableblock,table.grid-rows td.tableblock{border-width:0 0 1px 0}
table.grid-all tbody>tr:last-child>th.tableblock,table.grid-all tbody>tr:last-child>td.tableblock,table.grid-all thead:last-child>tr>th.tableblock,table.grid-rows tbody>tr:last-child>th.tableblock,table.grid-rows tbody>tr:last-child>td.tableblock,table.grid-rows thead:last-child>tr>th.tableblock{border-bottom-width:0}
table.grid-rows tfoot>tr>th.tableblock,table.grid-rows tfoot>tr>td.tableblock{border-width:1px 0 0 0}
table.frame-all{border-width:1px}
table.frame-sides{border-width:0 1px}
table.frame-topbot{border-width:1px 0}
th.halign-left,td.halign-left{text-align:left}
th.halign-right,td.halign-right{text-align:right}
th.halign-center,td.halign-center{text-align:center}
th.valign-top,td.valign-top{vertical-align:top}
th.valign-bottom,td.valign-bottom{vertical-align:bottom}
th.valign-middle,td.valign-middle{vertical-align:middle}
table thead th,table tfoot th{font-weight:bold}
tbody tr th{display:table-cell;line-height:1.6;background:#f7f8f7}
tbody tr th,tbody tr th p,tfoot tr th,tfoot tr th p{color:rgba(0,0,0,.8);font-weight:bold}
p.tableblock>code:only-child{background:none;padding:0}
p.tableblock{font-size:1em}
td>div.verse{white-space:pre}
ol{margin-left:1.75em}
ul li ol{margin-left:1.5em}
dl dd{margin-left:1.125em}
dl dd:last-child,dl dd:last-child>:last-child{margin-bottom:0}
ol>li p,ul>li p,ul dd,ol dd,.olist .olist,.ulist .ulist,.ulist .olist,.olist .ulist{margin-bottom:.625em}
ul.unstyled,ol.unnumbered,ul.checklist,ul.none{list-style-type:none}
ul.unstyled,ol.unnumbered,ul.checklist{margin-left:.625em}
ul.checklist li>p:first-child>.fa-square-o:first-child,ul.checklist li>p:first-child>.fa-check-square-o:first-child{width:1em;font-size:.85em}
ul.checklist li>p:first-child>input[type="checkbox"]:first-child{width:1em;position:relative;top:1px}
ul.inline{margin:0 auto .625em auto;margin-left:-1.375em;margin-right:0;padding:0;list-style:none;overflow:hidden}
ul.inline>li{list-style:none;float:left;margin-left:1.375em;display:block}
ul.inline>li>*{display:block}
.unstyled dl dt{font-weight:400;font-style:normal}
ol.arabic{list-style-type:decimal}
ol.decimal{list-style-type:decimal-leading-zero}
ol.loweralpha{list-style-type:lower-alpha}
ol.upperalpha{list-style-type:upper-alpha}
ol.lowerroman{list-style-type:lower-roman}
ol.upperroman{list-style-type:upper-roman}
ol.lowergreek{list-style-type:lower-greek}
.hdlist>table,.colist>table{border:0;background:none}
.hdlist>table>tbody>tr,.colist>table>tbody>tr{background:none}
td.hdlist1,td.hdlist2{vertical-align:top;padding:0 .625em}
td.hdlist1{font-weight:bold;padding-bottom:1.25em}
.literalblock+.colist,.listingblock+.colist{margin-top:-.5em}
.colist>table tr>td:first-of-type{padding:0 .75em;line-height:1}
.colist>table tr>td:last-of-type{padding:.25em 0}
.thumb,.th{line-height:0;display:inline-block;border:solid 4px #fff;-webkit-box-shadow:0 0 0 1px #ddd;box-shadow:0 0 0 1px #ddd}
.imageblock.left,.imageblock[style*="float: left"]{margin:.25em .625em 1.25em 0}
.imageblock.right,.imageblock[style*="float: right"]{margin:.25em 0 1.25em .625em}
.imageblock>.title{margin-bottom:0}
.imageblock.thumb,.imageblock.th{border-width:6px}
.imageblock.thumb>.title,.imageblock.th>.title{padding:0 .125em}
.image.left,.image.right{margin-top:.25em;margin-bottom:.25em;display:inline-block;line-height:0}
.image.left{margin-right:.625em}
.image.right{margin-left:.625em}
a.image{text-decoration:none;display:inline-block}
a.image object{pointer-events:none}
sup.footnote,sup.footnoteref{font-size:.875em;position:static;vertical-align:super}
sup.footnote a,sup.footnoteref a{text-decoration:none}
sup.footnote a:active,sup.footnoteref a:active{text-decoration:underline}
#footnotes{padding-top:.75em;padding-bottom:.75em;margin-bottom:.625em}
#footnotes hr{width:20%;min-width:6.25em;margin:-.25em 0 .75em 0;border-width:1px 0 0 0}
#footnotes .footnote{padding:0 .375em 0 .225em;line-height:1.3334;font-size:.875em;margin-left:1.2em;text-indent:-1.05em;margin-bottom:.2em}
#footnotes .footnote a:first-of-type{font-weight:bold;text-decoration:none}
#footnotes .footnote:last-of-type{margin-bottom:0}
#content #footnotes{margin-top:-.625em;margin-bottom:0;padding:.75em 0}
.gist .file-data>table{border:0;background:#fff;width:100%;margin-bottom:0}
.gist .file-data>table td.line-data{width:99%}
div.unbreakable{page-break-inside:avoid}
.big{font-size:larger}
.small{font-size:smaller}
.underline{text-decoration:underline}
.overline{text-decoration:overline}
.line-through{text-decoration:line-through}
.aqua{color:#00bfbf}
.aqua-background{background-color:#00fafa}
.black{color:#000}
.black-background{background-color:#000}
.blue{color:#0000bf}
.blue-background{background-color:#0000fa}
.fuchsia{color:#bf00bf}
.fuchsia-background{background-color:#fa00fa}
.gray{color:#606060}
.gray-background{background-color:#7d7d7d}
.green{color:#006000}
.green-background{background-color:#007d00}
.lime{color:#00bf00}
.lime-background{background-color:#00fa00}
.maroon{color:#600000}
.maroon-background{background-color:#7d0000}
.navy{color:#000060}
.navy-background{background-color:#00007d}
.olive{color:#606000}
.olive-background{background-color:#7d7d00}
.purple{color:#600060}
.purple-background{background-color:#7d007d}
.red{color:#bf0000}
.red-background{background-color:#fa0000}
.silver{color:#909090}
.silver-background{background-color:#bcbcbc}
.teal{color:#006060}
.teal-background{background-color:#007d7d}
.white{color:#bfbfbf}
.white-background{background-color:#fafafa}
.yellow{color:#bfbf00}
.yellow-background{background-color:#fafa00}
span.icon>.fa{cursor:default}
.admonitionblock td.icon [class^="fa icon-"]{font-size:2.5em;text-shadow:1px 1px 2px rgba(0,0,0,.5);cursor:default}
.admonitionblock td.icon .icon-note:before{content:"\f05a";color:#19407c}
.admonitionblock td.icon .icon-tip:before{content:"\f0eb";text-shadow:1px 1px 2px rgba(155,155,0,.8);color:#111}
.admonitionblock td.icon .icon-warning:before{content:"\f071";color:#bf6900}
.admonitionblock td.icon .icon-caution:before{content:"\f06d";color:#bf3400}
.admonitionblock td.icon .icon-important:before{content:"\f06a";color:#bf0000}
.conum[data-value]{display:inline-block;color:#fff!important;background-color:rgba(0,0,0,.8);-webkit-border-radius:100px;border-radius:100px;text-align:center;font-size:.75em;width:1.67em;height:1.67em;line-height:1.67em;font-family:"Open Sans","DejaVu Sans",sans-serif;font-style:normal;font-weight:bold}
.conum[data-value] *{color:#fff!important}
.conum[data-value]+b{display:none}
.conum[data-value]:after{content:attr(data-value)}
pre .conum[data-value]{position:relative;top:-.125em}
b.conum *{color:inherit!important}
.conum:not([data-value]):empty{display:none}
dt,th.tableblock,td.content,div.footnote{text-rendering:optimizeLegibility}
h1,h2,p,td.content,span.alt{letter-spacing:-.01em}
p strong,td.content strong,div.footnote strong{letter-spacing:-.005em}
p,blockquote,dt,td.content,span.alt{font-size:1.0625rem}
p{margin-bottom:1.25rem}
.sidebarblock p,.sidebarblock dt,.sidebarblock td.content,p.tableblock{font-size:1em}
.exampleblock>.content{background-color:#fffef7;border-color:#e0e0dc;-webkit-box-shadow:0 1px 4px #e0e0dc;box-shadow:0 1px 4px #e0e0dc}
.print-only{display:none!important}
@media print{@page{margin:1.25cm .75cm}
*{-webkit-box-shadow:none!important;box-shadow:none!important;text-shadow:none!important}
a{color:inherit!important;text-decoration:underline!important}
a.bare,a[href^="#"],a[href^="mailto:"]{text-decoration:none!important}
a[href^="http:"]:not(.bare):after,a[href^="https:"]:not(.bare):after{content:"(" attr(href) ")";display:inline-block;font-size:.875em;padding-left:.25em}
abbr[title]:after{content:" (" attr(title) ")"}
pre,blockquote,tr,img,object,svg{page-break-inside:avoid}
thead{display:table-header-group}
svg{max-width:100%}
p,blockquote,dt,td.content{font-size:1em;orphans:3;widows:3}
h2,h3,#toctitle,.sidebarblock>.content>.title{page-break-after:avoid}
#toc,.sidebarblock,.exampleblock>.content{background:none!important}
#toc{border-bottom:1px solid #ddddd8!important;padding-bottom:0!important}
.sect1{padding-bottom:0!important}
.sect1+.sect1{border:0!important}
#header>h1:first-child{margin-top:1.25rem}
body.book #header{text-align:center}
body.book #header>h1:first-child{border:0!important;margin:2.5em 0 1em 0}
body.book #header .details{border:0!important;display:block;padding:0!important}
body.book #header .details span:first-child{margin-left:0!important}
body.book #header .details br{display:block}
body.book #header .details br+span:before{content:none!important}
body.book #toc{border:0!important;text-align:left!important;padding:0!important;margin:0!important}
body.book #toc,body.book #preamble,body.book h1.sect0,body.book .sect1>h2{page-break-before:always}
.listingblock code[data-lang]:before{display:block}
#footer{background:none!important;padding:0 .9375em}
#footer-text{color:rgba(0,0,0,.6)!important;font-size:.9em}
.hide-on-print{display:none!important}
.print-only{display:block!important}
.hide-for-print{display:none!important}
.show-for-print{display:inherit!important}}
</style>
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.4.0/css/font-awesome.min.css">
<style>
/* Stylesheet for CodeRay to match GitHub theme | MIT License | http://foundation.zurb.com */
/*pre.CodeRay {background-color:#f7f7f8;}*/
.CodeRay .line-numbers{border-right:1px solid #d8d8d8;padding:0 0.5em 0 .25em}
.CodeRay span.line-numbers{display:inline-block;margin-right:.5em;color:rgba(0,0,0,.3)}
.CodeRay .line-numbers strong{color:rgba(0,0,0,.4)}
table.CodeRay{border-collapse:separate;border-spacing:0;margin-bottom:0;border:0;background:none}
table.CodeRay td{vertical-align: top;line-height:1.45}
table.CodeRay td.line-numbers{text-align:right}
table.CodeRay td.line-numbers>pre{padding:0;color:rgba(0,0,0,.3)}
table.CodeRay td.code{padding:0 0 0 .5em}
table.CodeRay td.code>pre{padding:0}
.CodeRay .debug{color:#fff !important;background:#000080 !important}
.CodeRay .annotation{color:#007}
.CodeRay .attribute-name{color:#000080}
.CodeRay .attribute-value{color:#700}
.CodeRay .binary{color:#509}
.CodeRay .comment{color:#998;font-style:italic}
.CodeRay .char{color:#04d}
.CodeRay .char .content{color:#04d}
.CodeRay .char .delimiter{color:#039}
.CodeRay .class{color:#458;font-weight:bold}
.CodeRay .complex{color:#a08}
.CodeRay .constant,.CodeRay .predefined-constant{color:#008080}
.CodeRay .color{color:#099}
.CodeRay .class-variable{color:#369}
.CodeRay .decorator{color:#b0b}
.CodeRay .definition{color:#099}
.CodeRay .delimiter{color:#000}
.CodeRay .doc{color:#970}
.CodeRay .doctype{color:#34b}
.CodeRay .doc-string{color:#d42}
.CodeRay .escape{color:#666}
.CodeRay .entity{color:#800}
.CodeRay .error{color:#808}
.CodeRay .exception{color:inherit}
.CodeRay .filename{color:#099}
.CodeRay .function{color:#900;font-weight:bold}
.CodeRay .global-variable{color:#008080}
.CodeRay .hex{color:#058}
.CodeRay .integer,.CodeRay .float{color:#099}
.CodeRay .include{color:#555}
.CodeRay .inline{color:#000}
.CodeRay .inline .inline{background:#ccc}
.CodeRay .inline .inline .inline{background:#bbb}
.CodeRay .inline .inline-delimiter{color:#d14}
.CodeRay .inline-delimiter{color:#d14}
.CodeRay .important{color:#555;font-weight:bold}
.CodeRay .interpreted{color:#b2b}
.CodeRay .instance-variable{color:#008080}
.CodeRay .label{color:#970}
.CodeRay .local-variable{color:#963}
.CodeRay .octal{color:#40e}
.CodeRay .predefined{color:#369}
.CodeRay .preprocessor{color:#579}
.CodeRay .pseudo-class{color:#555}
.CodeRay .directive{font-weight:bold}
.CodeRay .type{font-weight:bold}
.CodeRay .predefined-type{color:inherit}
.CodeRay .reserved,.CodeRay .keyword {color:#000;font-weight:bold}
.CodeRay .key{color:#808}
.CodeRay .key .delimiter{color:#606}
.CodeRay .key .char{color:#80f}
.CodeRay .value{color:#088}
.CodeRay .regexp .delimiter{color:#808}
.CodeRay .regexp .content{color:#808}
.CodeRay .regexp .modifier{color:#808}
.CodeRay .regexp .char{color:#d14}
.CodeRay .regexp .function{color:#404;font-weight:bold}
.CodeRay .string{color:#d20}
.CodeRay .string .string .string{background:#ffd0d0}
.CodeRay .string .content{color:#d14}
.CodeRay .string .char{color:#d14}
.CodeRay .string .delimiter{color:#d14}
.CodeRay .shell{color:#d14}
.CodeRay .shell .delimiter{color:#d14}
.CodeRay .symbol{color:#990073}
.CodeRay .symbol .content{color:#a60}
.CodeRay .symbol .delimiter{color:#630}
.CodeRay .tag{color:#008080}
.CodeRay .tag-special{color:#d70}
.CodeRay .variable{color:#036}
.CodeRay .insert{background:#afa}
.CodeRay .delete{background:#faa}
.CodeRay .change{color:#aaf;background:#007}
.CodeRay .head{color:#f8f;background:#505}
.CodeRay .insert .insert{color:#080}
.CodeRay .delete .delete{color:#800}
.CodeRay .change .change{color:#66f}
.CodeRay .head .head{color:#f4f}
</style>
</head>
<body class="book toc2 toc-left">
<div id="header">
<h1>Object-Oriented Reengineering Patterns</h1>
<div class="details">
<span id="author" class="author">Serge Demeyer, StÃ©phane Ducasse, Oscar Nierstraszv</span><br>
<span id="revnumber">version 0.01-alpha,</span>
<span id="revdate">2017-01-27</span>
</div>
<div id="toc" class="toc2">
<div id="toctitle">Table of Contents</div>
<ul class="sectlevel1">
<li><a href="#introduction">Introduction</a>
<ul class="sectlevel2">
<li><a href="#copyright-license">Copyright / License</a></li>
<li><a href="#a-fairy-tale">A Fairy Tale</a></li>
</ul>
</li>
<li><a href="#reengineering-patterns">1. Reengineering Patterns</a>
<ul class="sectlevel2">
<li><a href="#1-1-why-do-we-reengineer">1.1 Why do we Reengineer?</a></li>
<li><a href="#the-reengineering-lifecycle">1.2 The Reengineering Lifecycle</a></li>
<li><a href="#reengineering-patterns-1">1.3 Reengineering Patterns</a></li>
<li><a href="#the-form-of-a-reengineering-pattern">1.4 The Form of a Reengineering Pattern</a></li>
<li><a href="#a-map-of-reengineering-patterns">1.5 A Map of Reengineering Patterns</a></li>
</ul>
</li>
<li><a href="#setting-direction">2. Setting Direction</a>
<ul class="sectlevel2">
<li><a href="#forces">Forces</a></li>
<li><a href="#overview">Overview</a></li>
<li><a href="#agree-on-maxims">2.1 Agree on Maxims</a></li>
<li><a href="#appoint-a-navigator">2.2 Appoint a Navigator</a></li>
<li><a href="#speak-to-the-round-table">2.3 Speak to the Round Table</a></li>
<li><a href="#most-valuable-first">2.4 Most Valuable First</a></li>
<li><a href="#fix-problems-not-symptoms">2.5 Fix Problems, Not Symptoms</a></li>
<li><a href="#if-it-aint-broke-dont-fix-it">2.6 If It Ainât Broke, Donât Fix It</a></li>
<li><a href="#keep-it-simple">2.7 Keep It Simple</a></li>
</ul>
</li>
<li><a href="#first-contact">3. First Contact</a>
<ul class="sectlevel2">
<li><a href="#forces-1">Forces</a></li>
<li><a href="#overview-1">Overview</a></li>
<li><a href="#what-next">What Next</a></li>
<li><a href="#chat-with-the-maintainers">3.1 Chat with the Maintainers</a></li>
<li><a href="#read-all-the-code-in-one-hour">3.2 Read all the Code in One Hour</a></li>
<li><a href="#skim-the-documentation">3.3 Skim the Documentation</a></li>
<li><a href="#interview-during-demo">3.4 Interview During Demo</a></li>
<li><a href="#do-a-mock-installation">3.5 Do a Mock Installation</a></li>
</ul>
</li>
<li><a href="#initial-understanding">4. Initial Understanding</a>
<ul class="sectlevel2">
<li><a href="#forces-2">Forces</a></li>
<li><a href="#overview-2">Overview</a></li>
<li><a href="#what-next-6">What Next</a></li>
<li><a href="#analyze-the-persistent-data">4.1 Analyze the Persistent Data</a></li>
<li><a href="#speculate-about-design">4.2 Speculate about Design</a></li>
<li><a href="#study-the-exceptional-entities">4.3 Study the Exceptional Entities</a></li>
</ul>
</li>
<li><a href="#detailed-model-capture">5. Detailed Model Capture</a>
<ul class="sectlevel2">
<li><a href="#forces-3">Forces</a></li>
<li><a href="#overview-3">Overview</a></li>
<li><a href="#what-next-10">What Next</a></li>
<li><a href="#tie-code-and-questions">5.1 Tie Code and Questions</a></li>
<li><a href="#refactor-to-understand">5.2 Refactor to Understand</a></li>
<li><a href="#step-through-the-execution">5.3 Step Through the Execution</a></li>
<li><a href="#look-for-the-contracts">5.4 Look for the Contracts</a></li>
<li><a href="#learn-from-the-past">5.5 Learn from the Past</a></li>
</ul>
</li>
<li><a href="#tests-your-life-insurance">6. Tests: Your Life Insurance!</a>
<ul class="sectlevel2">
<li><a href="#forces-4">Forces</a></li>
<li><a href="#overview-4">Overview</a></li>
<li><a href="#write-tests-to-enable-evolution">6.1 Write Tests to Enable Evolution</a></li>
<li><a href="#grow-your-test-base-incrementally">6.2 Grow Your Test Base Incrementally</a></li>
<li><a href="#use-a-testing-framework">6.3 Use a Testing Framework</a></li>
<li><a href="#test-the-interface-not-the-implementation">6.4 Test the Interface, Not the Implementation</a></li>
<li><a href="#record-business-rules-as-tests">6.5 Record Business Rules as Tests</a></li>
<li><a href="#write-tests-to-understand">6.6 Write Tests to Understand</a></li>
</ul>
</li>
<li><a href="#migration-strategies">7. Migration Strategies</a>
<ul class="sectlevel2">
<li><a href="#forces-5">Forces</a></li>
<li><a href="#overview-5">Overview</a></li>
<li><a href="#involve-the-users">7.1 Involve the Users</a></li>
<li><a href="#build-confidence">7.2 Build Confidence</a></li>
<li><a href="#migrate-systems-incrementally">7.3 Migrate Systems Incrementally</a></li>
<li><a href="#prototype-the-target-solution">7.4 Prototype the Target Solution</a></li>
<li><a href="#always-have-a-running-version">7.5 Always Have a Running Version</a></li>
<li><a href="#regression-test-after-every-change">7.6 Regression Test After Every Change</a></li>
<li><a href="#make-a-bridge-to-the-new-town">7.7 Make a Bridge to the New Town</a></li>
<li><a href="#present-the-right-interface">7.8 Present the Right Interface</a></li>
<li><a href="#distinguish-public-from-published-interface">7.9 Distinguish Public from Published Interface</a></li>
<li><a href="#deprecate-obsolete-interfaces">7.10 Deprecate Obsolete Interfaces</a></li>
<li><a href="#conserve-familiarity">7.11 Conserve Familiarity</a></li>
<li><a href="#use-profiler-before-optimizing">7.12 Use Profiler Before Optimizing</a></li>
</ul>
</li>
<li><a href="#detecting-duplicated-code">8. Detecting Duplicated Code</a>
<ul class="sectlevel2">
<li><a href="#overview-6">Overview</a></li>
<li><a href="#compare-code-mechanically">8.1 Compare Code Mechanically</a></li>
<li><a href="#visualize-code-as-dotplots">8.2 Visualize Code as Dotplots</a></li>
</ul>
</li>
<li><a href="#redistribute-responsibilities">9. Redistribute Responsibilities</a>
<ul class="sectlevel2">
<li><a href="#forces-6">Forces</a></li>
<li><a href="#overview-7">Overview</a></li>
<li><a href="#move-behavior-close-to-data">9.1 Move Behavior Close to Data</a></li>
<li><a href="#eliminate-navigation-code">9.2 Eliminate Navigation Code</a></li>
<li><a href="#split-up-god-class">9.3 Split Up God Class</a></li>
</ul>
</li>
<li><a href="#transform-conditionals-to-polymorphism">10. Transform Conditionals to Polymorphism</a>
<ul class="sectlevel2">
<li><a href="#forces-7">Forces</a></li>
<li><a href="#overview-8">Overview</a></li>
<li><a href="#transform-self-type-checks">10.1 Transform Self Type Checks</a></li>
<li><a href="#transform-client-type-checks">10.2 Transform Client Type Checks</a></li>
<li><a href="#factor-out-state">10.3 Factor out State</a></li>
<li><a href="#factor-out-strategy">10.4 Factor out Strategy</a></li>
<li><a href="#introduce-null-object">10.5 Introduce Null Object</a></li>
<li><a href="#transform-conditionals-into-registration">10.6 Transform Conditionals into Registration</a></li>
</ul>
</li>
<li><a href="#thumbnail-patterns">Thumbnail patterns</a>
<ul class="sectlevel2">
<li><a href="#a.1-testing-patterns">A.1 Testing Patterns</a></li>
<li><a href="#a.2-refactorings">A.2 Refactorings</a></li>
<li><a href="#a.3-design-patterns">A.3 Design Patterns</a></li>
</ul>
</li>
<li><a href="#bibliography">Bibliography</a></li>
<li><a href="#appendix">Appendix</a>
<ul class="sectlevel2">
<li><a href="#praise-for-object-oriented-reengineering-patterns">Praise</a></li>
<li><a href="#foreword">Foreword</a></li>
<li><a href="#acknowledgments">Acknowledgments</a></li>
</ul>
</li>
</ul>
</div>
</div>
<div id="content">
<div class="sect1">
<h2 id="introduction"><a class="anchor" href="#introduction"></a>Introduction</h2>
<div class="sectionbody">
<div class="paragraph">
<p>This site is a migrated version of the freely available book <a href="http://scg.unibe.ch/oorp/">Object-Oriented Reengineering Patterns</a> from Serge Demeyer, StÃ©phane Ducasse and Oscar Nierstrasz; currently maintained by contributors on <a href="https://github.com/oorp/oorp">GitHub</a>. Feel free to submit your suggestions and enhancements!</p>
</div>
<div class="sect2">
<h3 id="copyright-license"><a class="anchor" href="#copyright-license"></a>Copyright / License</h3>
<div class="paragraph">
<p>Copyright Â© 2003 by Elsevier Science (USA). Copyright Â© 2008, 2009 by Serge Demeyer, StÃ©phane Ducasse and Oscar Nierstrasz. The contents of this book are protected under <a href="http://creativecommons.org/licenses/by-sa/3.0">Creative Commons Attribution-ShareAlike 3.0 Unported</a> license.</p>
</div>
</div>
<div class="sect2">
<h3 id="a-fairy-tale"><a class="anchor" href="#a-fairy-tale"></a>A Fairy Tale</h3>
<div class="quoteblock">
<blockquote>
<div class="paragraph">
<p>Once upon a time there was a Good Software Engineer whose Customers knew exactly what they wanted. The Good Software Engineer worked very hard to design the Perfect System that would solve all the Customersâ problems now and for decades. When the Perfect System was designed, implemented and finally deployed, the Customers were very happy indeed. The Maintainer of the System had very little to do to keep the Perfect System up and running, and the Customers and the Maintainer lived happily every after.</p>
</div>
</blockquote>
</div>
<div class="paragraph">
<p>Why isnât real life more like this fairy tale?</p>
</div>
<div class="paragraph">
<p>Could it be because there are no Good Software Engineers? Could it be because the Users donât really know what they want? Or is it because the Perfect System doesnât exist?</p>
</div>
<div class="paragraph">
<p>Maybe there is a bit of truth in all of these observations, but the real reasons probably have more to do with certain fundamental laws of software evolution identified several years ago by Manny Lehman and Les Belady. The two most striking of these laws are [LB85]:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><em>The Law of Continuing Change</em> â A program that is used in a realworld environment must change, or become progressively less useful in that environment.</p>
</li>
<li>
<p><em>The Law of Increasing Complexity</em> â As a program evolves, it becomes more complex, and extra resources are needed to preserve and simplify its structure.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>In other words, we are kidding ourselves if we think that we can know all the requirements and build the perfect system. The best we can hope for is to build a useful system that will survive long enough for it to be asked to do something new.</p>
</div>
<div class="paragraph">
<p><strong>What is this book?</strong></p>
</div>
<div class="paragraph">
<p>This book came into being as a consequence of the realization that the most interesting and challenging side of software engineering may not be building brand new software systems, but rejuvenating existing ones.</p>
</div>
<div class="paragraph">
<p>From November 1996 to December 1999, we participated in a European industrial research project called FAMOOS (ESPRIT Project 21975 â <em>Framework-based Approach for Mastering Object-Oriented Software Evolution</em>). The partners were Nokia (Finland), Daimler-Benz (Germany), Sema Group (Spain), Forschungszentrum Informatik Karlsruhe (FZI, Germany), and the University of Bern (Switzerland). Nokia and Daimler-Benz were both early adopters of object-oriented technology, and had expected to reap significant benefits from this tactic. Now, however, they were experiencing many of the typical problems of legacy systems: they had very large, very valuable, object-oriented software systems that were very difficult to adapt to changing requirements. The goal of the FAMOOS project was to develop tools and techniques to rejuvenate these object-oriented legacy systems so they would continue to be useful and would be more amenable to future changes in requirements.</p>
</div>
<div class="paragraph">
<p>Our idea at the start of the project was to convert these big, objectoriented applications into <em>frameworks</em> â generic applications that can be easily reconfigured using a variety of different programming techniques. We quickly discovered, however, that this was easier said than done. Although the basic idea was sound, it is not so easy to determine which parts of the legacy system should be converted, and exactly how to convert them. In fact, it is a non-trivial problem just to understand the legacy system in the first place, let alone figuring out what (if anything) is wrong with it.</p>
</div>
<div class="paragraph">
<p>We learned many things from this project. We learned that, for the most part, the legacy code was not bad at all. The only reason that there were problems with the legacy code was that the requirements had changed since the original system was designed and deployed. Systems that had been adapted many times to changing requirements suffered from <em>design drift</em> â the original architecture and design was almost impossible to recognize â and that made it almost impossible to make further adaptations, exactly as predicted by Lehman and Beladyâs laws of software evolution.</p>
</div>
<div class="paragraph">
<p>Most surprising to us, however, was the fact that, although each of the case studies we looked at needed to be reengineered for very different reasons â such as unbundling, scaling up requirements, porting to new environments, and so on â the actual technical problems with these systems were oddly similar. This suggested to us that perhaps a few simple techniques could go a long way to fixing some of the more common problems.</p>
</div>
<div class="paragraph">
<p>We discovered that pretty well all reengineering activity must start with some reverse engineering, since you will not be able to trust the documentation (if you are lucky enough to have some). Basically you can analyze the source code, run the system, and interview users and developers to build a model of the legacy system. Then you must determine what are the obstacles to further progress, and fix them. This is the essence of <em>reengineering</em>, which seeks to transform a legacy system into the system you would have built if you had the luxury of hindsight and could have known all the new requirements that you know today. But since you canât afford to rebuild everything, you must cut corners and just reengineer the most critical parts.</p>
</div>
<div class="paragraph">
<p>Since FAMOOS, we have been involved in many other reengineering projects, and have been able to further validate and refine the results of FAMOOS.</p>
</div>
<div class="paragraph">
<p>In this book we summarize what we learned in the hope that it will help others who need to reengineer object-oriented systems. We do not pretend to have all the answers, but we have identified a series of simple techniques that will take you a long way.</p>
</div>
<div class="paragraph">
<p><strong>Why patterns?</strong></p>
</div>
<div class="paragraph">
<p>A pattern is a recurring motif, an event or structure that occurs over and over again. <em>Design patterns</em> are generic solutions to recurring design problems [GHJV95]. It is because these design problems are never exactly alike, but only very similar, that the solutions are not pieces of software, but <em>documents that communicate best practice</em>.</p>
</div>
<div class="paragraph">
<p>Patterns have emerged in recent years as a literary form that can be used to document best practice in solving many different kinds of problems. Although many kinds of problems and solutions can be cast as patterns, they can be overkill when applied to the simplest kinds of problems.</p>
</div>
<div class="paragraph">
<p>Patterns as a form of documentation are most useful and interesting when the problem being considered entails a number of conflicting <em>forces</em>, and the solution described entails a number of <em>tradeoffs</em>. Many well-known design patterns, for example, introduce run-time flexibility at the cost of increased design complexity.</p>
</div>
<div class="paragraph">
<p>This book documents a catalogue of patterns for reverse engineering and reengineering legacy systems. None of these patterns should be applied blindly. Each patterns resolves some <em>forces</em> and involves some <em>tradeoffs</em>. Understanding these tradeoffs is essential to successfully applying the patterns. As a consequence the pattern form seems to be the most natural way to document the best practices we identified in the course of our reengineering projects.</p>
</div>
<div class="paragraph">
<p>A <em>pattern language</em> is a set of related patterns that can be used in combination to solve a set of complex problems. We found that clusters of patterns seemed to function well in combination with each other, so we have organized this book into chapters that each presents such a cluster as a small pattern language.</p>
</div>
<div class="paragraph">
<p>We do not pretend that these clusters are âcompleteâ in any sense, and we do not even pretend to have patterns that cover all aspects of reengineering. We certainly do not pretend that this book represents a systematic method for object-oriented reengineering. What we do claim is simply to have encountered and identified a number of best practices that exhibit interesting synergies. Not only is there strong synergy within a cluster of patterns, but the clusters are also interrelated in important ways. Each chapter therefore contains not only a pattern map that suggests how the patterns may function as a âlanguageâ, but each pattern also lists and explains how it may be combined or composed with other patterns, whether in the same cluster or a different one.</p>
</div>
<div class="paragraph">
<p><strong>Who should read this book?</strong></p>
</div>
<div class="paragraph">
<p>This book is addressed mainly to practitioners who need to reengineer object-oriented systems. If you take an extreme viewpoint, you could say that <em>every</em> software project is a reengineering project, so the scope of this book is quite broad.</p>
</div>
<div class="paragraph">
<p>We believe that most of the patterns in this book will be familiar to anyone with a bit of experience in object-oriented software development.</p>
</div>
<div class="paragraph">
<p>The purpose of the book is to document the details.</p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="reengineering-patterns"><a class="anchor" href="#reengineering-patterns"></a>1. Reengineering Patterns</h2>
<div class="sectionbody">
<div class="sect2">
<h3 id="1-1-why-do-we-reengineer"><a class="anchor" href="#1-1-why-do-we-reengineer"></a>1.1 Why do we Reengineer?</h3>
<div class="paragraph">
<p>A legacy is something <em>valuable</em> that you have <em>inherited</em>. Similarly, legacy software is valuable software that you have inherited. The fact you have inherited it may mean that it is somewhat old-fashioned. It may have been developed using an outdated programming language, or an obsolete development method. Most likely it has changed hands several times, and shows signs of many modifications and adaptations.</p>
</div>
<div class="paragraph">
<p>Perhaps your legacy software is not even that old. With rapid development tools <em>and</em> rapid turnover in personnel, software systems can turn into legacies more quickly than you might imagine. The fact that the software is <em>valuable</em>, however, means that you do not just want to throw it away.</p>
</div>
<div class="paragraph">
<p>A piece of legacy software is critical to your business, and that is precisely the source of all the problems: in order for you to be successful at your business, you must constantly be prepared to adapt to a changing business environment. The software that you use to keep your business running must therefore also be adaptable. Fortunately a lot of software can be upgraded, or simply thrown away and replaced when it no longer serves its purpose. But a legacy system can neither be replaced nor upgraded except at a high cost. The goal of reengineering is to reduce the complexity of a legacy system sufficiently that it can continue to be used and adapted at an acceptable cost.</p>
</div>
<div class="paragraph">
<p>The specific reasons that you might want to reengineer a software system can vary significantly. For example:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>You might want to <em>unbundle</em> a monolithic system so that the individual parts can be more easily marketed separately or combined in different ways.</p>
</li>
<li>
<p>You might want to improve <em>performance</em>. (Experience shows that the right sequence is âfirst do it, then do it right, then do it fastâ, so you might want to reengineer to clean up the code before thinking about performance.)</p>
</li>
<li>
<p>You might want to <em>port the system to a new platform</em>. Before you do that, you may need to rework the architecture to clearly separate the platform-dependent code.</p>
</li>
<li>
<p>You might want to <em>extract the design</em> as a first step to a new implementation.</p>
</li>
<li>
<p>You might want to <em>exploit new technology</em>, such as emerging standards or libraries, as a step towards cutting maintenance costs.</p>
</li>
<li>
<p>You might want to <em>reduce human dependencies</em> by documenting knowledge about the system and making it easier to maintain.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Though there may be many different reasons for reengineering a system, as we shall see, however, the actual technical problems with legacy software are often very similar. It is this fact that allows us to use some very general techniques to do at least part of the job of reengineering.</p>
</div>
<div class="sect3">
<h4 id="recognizing-the-need-to-reengineer"><a class="anchor" href="#recognizing-the-need-to-reengineer"></a>Recognizing the need to reengineer</h4>
<div class="paragraph">
<p>How do you know when you have a legacy problem?</p>
</div>
<div class="paragraph">
<p>Common wisdom says, âIf it ainât broke, donât fix it.â This attitude is often taken as an excuse not to touch any piece of software that is performing an important function and seems to be doing it well. The problem with this approach is that it fails to recognize that there are many ways in which something may be âbrokenâ. From a functional point of view, something is broken only if it no longer delivers the function it is designed to perform. From a maintenance point of view, however, a piece of software is broken <em>if it can no longer be maintained</em>.
So how can you tell that your software is going to break very soon? Fortunately there are many warning signs that tell you that you are headed towards trouble. The symptoms listed below usually do not occur in isolation but several at a time.</p>
</div>
<div class="paragraph">
<p><strong>Obsolete or no documentation.</strong> Obsolete documentation is a clear sign of a legacy system that has undergone many changes. Absence of documentation is a warning sign that problems are on the horizon, as soon as the original developers leave the project.</p>
</div>
<div class="paragraph">
<p><strong>Missing tests.</strong> Even more important than up-to-date documentation is the presence of thorough unit tests for all system components, and system tests that cover all significant use cases and scenarios. The absence of such tests is a sign that the system will not be able to evolve without high risk or cost.</p>
</div>
<div class="paragraph">
<p><strong>Original developers or users have left.</strong> Unless you have a clean, well-documented system with good test coverage, it will rapidly deteriorate into an even less clean, more poorly documented system.</p>
</div>
<div class="paragraph">
<p><strong>Inside knowledge about system has disappeared.</strong> This is a bad sign. The documentation is out of sync with the existing code base. Nobody really knows how it works.</p>
</div>
<div class="paragraph">
<p><strong>Limited understanding of the entire system.</strong> Not only does nobody understand the fine print, but hardly anyone has a good overview of the whole system.</p>
</div>
<div class="paragraph">
<p><strong>Too long to turn things over to production.</strong> Somewhere along the line the process is not working. Perhaps it takes too long to approve changes. Perhaps automatic regression tests are missing. Or perhaps it is difficult to deploy changes. Unless you understand and deal with the difficulties it will only get worse.</p>
</div>
<div class="paragraph">
<p><strong>Too much time to make simple changes.</strong> This is a clear sign that Lehman and Beladyâs Law of Increasing Complexity has kicked in: the system is now so complex that even simple changes are hard to implement. If it takes too long to make simple changes to your system, it will certainly be out of the question to make complex changes. If there is a backlog of simple changes waiting to get done, then you will never get to the difficult problems.</p>
</div>
<div class="paragraph">
<p><strong>Need for constant bug fixes.</strong> Bugs never seem to go away. Every time you fix a bug, a new one pops up next to it. This tells you that parts of your application have become so complex, that you can no longer accurately assess the impact of small changes. Furthermore, the architecture of the application no longer matches the needs, so even small changes will have unexpected consequences.</p>
</div>
<div class="paragraph">
<p><strong>Maintenance Dependencies.</strong> When you fix a bug in one place, another bug pops up <em>somewhere else</em>. This is often a sign that the architecture has deteriorated to the point where logically separate components of the system are no longer independent.</p>
</div>
<div class="paragraph">
<p><strong>Big build times.</strong> Long recompilation times slow down your ability to make changes. Long build times may also be telling you that the organization of your system is too complex for your compiler tools to do their job efficiently.</p>
</div>
<div class="paragraph">
<p><strong>Difficulties separating products.</strong> If there are many clients for your product, and you have difficulty tailoring releases for each customer, then your architecture is no longer right for the job.</p>
</div>
<div class="paragraph">
<p><strong>Duplicated code.</strong> Duplicated code arises naturally as a system evolves, as shortcut to implementing nearly identical code, or merging different versions of a software systems. If the duplicated code is not eliminated by refactoring the common parts into suitable abstractions, maintenance quickly becomes a nightmare as the same code has to be fixed in many places.</p>
</div>
<div class="paragraph">
<p><strong>Code Smells.</strong> Duplicated code is an example of code that âsmells badâ and should be changed. Long methods, big classes, long parameter lists, switch statements and data classes are few more examples that have been documented by Kent Beck and others [FBB<sup>+</sup>99]. Code smells are often a sign that a system has been repeatedly expanded and adapted without having been reengineered.</p>
</div>
<div class="paragraph">
<p><strong>Whatâs special about Objects?</strong></p>
</div>
<div class="paragraph">
<p>Although many of the techniques discussed in this book will apply to any software system, we have chosen to focus on <em>object-oriented legacy systems</em>. There are many reasons for this choice, but mainly we feel that this is a critical point in time at which many early adopters of object-oriented technology are discovering that the benefits they expected to achieve by switching to objects have been very difficult to realize.</p>
</div>
<div class="paragraph">
<p>There are now significant legacy systems even in Java. It is not <em>age</em> that turns a piece of software into a legacy system, but the <em>rate</em> at which it have been developed and adapted without having been reengineered.</p>
</div>
<div class="paragraph">
<p>The wrong conclusion to draw from these experiences is that âobjects are bad, and we need something elseâ. Already we are seeing a rush towards many new trends that are expected to save the day: patterns, components, UML, XMI, and so on. Any one of these developments may be a Good Thing, but in a sense they are all missing the point.</p>
</div>
<div class="paragraph">
<p>One of the conclusions you should draw from this book is that, well, objects are pretty good, but <em>you must take good care of them</em>. To understand this point, consider why legacy problems arise at all with object-oriented systems, if they are supposed to be so good for flexibility, maintainability and reuse.</p>
</div>
<div class="paragraph">
<p>First of all, anyone who has had to work with a non-trivial, existing object-oriented code base will have noticed: <em>it is hard to find the objects</em>. In a very real sense, the architecture of an object-oriented application is usually hidden. What you see is a bunch of classes and an inheritance hierarchy. But that doesnât tell you which objects exist at run-time and how they collaborate to provide the desired behavior. Understanding an object-oriented system is a process of reverse engineering, and the techniques described in this book help to tackle this problem. Furthermore, by reengineering the code, you can arrive at a system whose architecture is more transparent, and easier to understand.</p>
</div>
<div class="paragraph">
<p>Second, anyone who has tried to extend an existing object-oriented application will have realized: <em>reuse does not come for free</em>. It is actually very hard to reuse any piece of code unless a fair bit of effort was put into designing it so that it could be reused. Furthermore, it is essential that investment in reuse <em>requires management commitment</em> to put the right organizational infrastructure in place, and should only be undertaken with clear, measurable goals in mind [GR95].</p>
</div>
<div class="paragraph">
<p>We are still not very good at managing object-oriented software projects in such a way that reuse is properly taken into account. Typically reuse comes too late. We use object-oriented modelling techniques to develop very rich and complex object models, and hope that when we implement the software we will be able to reuse something. But by then there is little chance that these rich models will map to any kind of standard library of components except with great effort. Several of the reengineering techniques we present address how to uncover these components after the fact.</p>
</div>
<div class="paragraph">
<p>The key insight, however, is that the ârightâ design and organization of your objects is not something that is or can be evident from the initial requirements alone, but rather <em>as a consequence of understanding how these requirements evolve</em>. The fact that the world is constantly changing should not be seen purely as a problem, but as the key to the solution.</p>
</div>
<div class="paragraph">
<p><em>Any</em> successful software system will suffer from the symptoms of legacy systems. Object-oriented legacy systems are just successful objectoriented systems whose architecture and design no longer responds to changing requirements. A <em>culture of continuous reengineering</em> is a prerequisite for achieving flexible and maintainable object-oriented systems.</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="the-reengineering-lifecycle"><a class="anchor" href="#the-reengineering-lifecycle"></a>1.2 The Reengineering Lifecycle</h3>
<div class="paragraph">
<p>Reengineering and reverse engineering are often mentioned in the same context, and the terms are sometimes confused, so it is worthwhile to be clear about what we mean by them. Chikofsky and Cross [CI92] define the two terms as follows:</p>
</div>
<div class="paragraph">
<p>â<em>Reverse Engineering</em> is the process of analyzing a subject system to identify the systemâs components and their interrelationships and create representations of the system in another form or at a higher level of abstraction.â</p>
</div>
<div class="paragraph">
<p>That is to say, reverse engineering is essentially concerned with trying to <em>understand</em> a system and how it ticks.</p>
</div>
<div class="paragraph">
<p>â<em>Reengineering</em> &#8230;&#8203; is the examination and <em>alteration of a subject system</em> to reconstitute it in a new form and the subsequent implementation of the new form.â</p>
</div>
<div class="paragraph">
<p>Reengineering, on the other hand, is concerned with <em>restructuring</em> a system, generally to fix some real or perceived problems, but more specifically in preparation for further development and extension.</p>
</div>
<div class="paragraph">
<p>The introduction of term âreverse engineeringâ was clearly an invitation to define âforward engineeringâ, so we have the following as well:</p>
</div>
<div class="paragraph">
<p>â<em>Forward Engineering</em> is the traditional <em>process of moving from</em> high-level abstractions and logical, implementation-independent <em>designs to the physical implementation</em> of a system.â</p>
</div>
<div class="paragraph">
<p>How exactly this process of forward engineering can or should work is of course a matter of great debate, though most people accept that the process is iterative, and conforms to Barry Boehmâs so-called <em>spiral model</em> of software development [Boe88]. In this model, successive versions of a software system are developed by repeatedly collecting requirements, assessing risks, engineering the new version, and evaluating the results. This general framework can accommodate many different kinds of more specific process models that are used in practice.</p>
</div>
<div class="paragraph">
<p>If forward engineering is about moving from high-level views of requirements and models towards concrete realizations, then reverse engineering is about going backwards from some concrete realization to more abstract models, and reengineering is about transforming concrete implementations to other concrete implementations.</p>
</div>
<div class="paragraph">
<p>Figure 1.1 illustrates this idea. <em>Forward engineering</em> can be understood as being a process that moves from high-level and abstract models and artifacts to increasing concrete ones. <em>Reverse engineering</em> reconstructs higher-level models and artifacts from code. <em>Reengineering</em> is a process that transforms one low-level representation to another, <em>while recreating the higher-level artifacts along the way</em>.</p>
</div>
<div class="paragraph">
<p><span class="image"><img src="./media/image1.png" alt="image" width="427" height="251"></span></p>
</div>
<div class="paragraph">
<p>Figure 1.1: Forward, reverse and reengineering</p>
</div>
<div class="paragraph">
<p>The key point to observe is that reengineering is not simply a matter of transforming source code, but of transforming a system <em>at all its levels</em>. For this reason it makes sense to talk about reverse engineering and reengineering in the same breath. In a typical legacy system, you will find that not only the source code, but all the documentation and specifications are out of sync. Reverse engineering is therefore a <em>prerequisite</em> to reengineering since you cannot transform what you do not understand.</p>
</div>
<div class="sect3">
<h4 id="reverse-engineering"><a class="anchor" href="#reverse-engineering"></a>Reverse engineering</h4>
<div class="paragraph">
<p>You carry out reverse engineering whenever you are trying to understand how something really works. Normally you only need to reverse engineer a piece of software if you want to fix, extend or replace it. (Sometimes you need to reverse engineer software just in order to understand how to <em>use</em> it. This may also be a sign that some reengineering is called for.) As a consequence, reverse engineering efforts typically focus on <em>redocumenting</em> software and <em>identifying potential problems</em>, in preparation for reengineering.</p>
</div>
<div class="paragraph">
<p>You can make use of a lot of different sources of information while reverse engineering. For example, you can:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>read the existing documentation</p>
</li>
<li>
<p>read the source code</p>
</li>
<li>
<p>run the software</p>
</li>
<li>
<p>interview users and developers</p>
</li>
<li>
<p>code and execute test cases</p>
</li>
<li>
<p>generate and analyze traces</p>
</li>
<li>
<p>use various tools to generate high-level views of the source code and the traces</p>
</li>
<li>
<p>analyze the version history</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>As you carry out these activities, you will be building progressively refined models of the software, keeping track of various questions and answers, and cleaning up the technical documentation. You will also be keeping an eye out for problems to fix.</p>
</div>
</div>
<div class="sect3">
<h4 id="reengineering"><a class="anchor" href="#reengineering"></a>Reengineering</h4>
<div class="paragraph">
<p>Although the reasons for reengineering a system may vary, the actual technical problems are typically very similar. There is usually a mix of coarsegrained, architectural problems, and fine-grained, design problems. Typical coarse-grained problems include:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><em>Insufficient documentation:</em> documentation either does not exist, or is inconsistent with reality.</p>
</li>
<li>
<p><em>Improper layering:</em> missing or improper layering hampers portability and adaptability.</p>
</li>
<li>
<p><em>Lack of modularity:</em> strong coupling between modules hampers evolution.</p>
</li>
<li>
<p><em>Duplicated code:</em> âcopy, paste and editâ is quick and easy, but leads to maintenance nightmares.</p>
</li>
<li>
<p><em>Duplicated functionality:</em> similar functionality is reimplemented by separate teams, leading to code bloat.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>The most common fine-grain problems occurring in object-oriented software include:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><em>Misuse of inheritance:</em> for composition, code reuse rather than polymorphism</p>
</li>
<li>
<p><em>Missing inheritance:</em> duplicated code, and case statements to select behavior</p>
</li>
<li>
<p><em>Misplaced operations:</em> unexploited cohesion â operations outside instead of inside classes</p>
</li>
<li>
<p><em>Violation of encapsulation:</em> explicit type-casting, C++ âfriendsâ .</p>
</li>
<li>
<p><em>Class abuse:</em> lack of cohesion â classes as namespaces</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Finally, you will be preparing the code base for the reengineering activity by developing exhaustive test cases for all the parts of the system that you plan to change or replace.</p>
</div>
<div class="paragraph">
<p>Reengineering similarly entails a number of interrelated activities. Of course, one of the most important is to evaluate which parts of the system should be repaired and which should be replaced.</p>
</div>
<div class="paragraph">
<p>The actual code transformations that are performed fall into a number of categories. According to Chikofsky and Cross:</p>
</div>
<div class="paragraph">
<p>â<em>Restructuring</em> is the transformation from one representation form to another at the same relative abstraction level, while preserving the systemâs external behavior.â</p>
</div>
<div class="paragraph">
<p>Restructuring generally refers to source code translation (such as the automatic conversion from unstructured âspaghettiâ code to structured, or âgoto-lessâ, code), but it may also entail transformations at the design level.</p>
</div>
<div class="paragraph">
<p><em>Refactoring</em> is restructuring within an object-oriented context. Martin Fowler defines it this way:</p>
</div>
<div class="paragraph">
<p>â<em>Refactoring</em> is the process of changing a software system in such a way that it does not alter the external behavior of the code yet improves its internal structure.â</p>
</div>
<div class="paragraph">
<p>â Martin Fowler, [FBB<sup>+</sup>99]</p>
</div>
<div class="paragraph">
<p>It may be hard to tell the difference between software âreengineeringâ and software âmaintenanceâ. IEEE has made several attempts to define software maintenance, including this one:</p>
</div>
<div class="paragraph">
<p>âthe modification of a software product after delivery to correct faults, to improve performance or other attributes, or to adapt</p>
</div>
<div class="paragraph">
<p>the product to a changed environmentâ
Most people would probably consider that âmaintenanceâ is routine whereas âreengineeringâ is a drastic, major effort to recast a system, as suggested by figure 1.</p>
</div>
<div class="paragraph">
<p>Others, however, might argue that reengineering is just a way of life.</p>
</div>
<div class="paragraph">
<p>You develop a little, reengineer a little, develop a little more, and so on [Bec00]. In fact, there is good evidence to support the notion that a culture of <em>continuous</em> reengineering is necessary to obtain healthy, maintainable software systems.</p>
</div>
<div class="paragraph">
<p>Continuous reengineering, however, is not yet common practice, and for this reason we present the patterns in this book in the context of a major reengineering effort. Nevertheless, the reader should keep in mind that most of the techniques we present will apply just as well when you reengineer in small iterations.</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="reengineering-patterns-1"><a class="anchor" href="#reengineering-patterns-1"></a>1.3 Reengineering Patterns</h3>
<div class="paragraph">
<p>Patterns as a literary form were introduced by the architect Christopher Alexander in his landmark 1977 book, <em>A Pattern Language</em>. In this book, Alexander and his colleagues presented a systematic method for architecting a range of different kinds of physical structures, from rooms to buildings and towns. Each issue was presented as a recurring <em>pattern</em>, a general solution which resolves a number of forces, but must be applied in a unique way to each problem according to the specific circumstances. The actual solution presented in each pattern was not necessarily so interesting, but rather the discussion of the <em>forces</em> and <em>tradeoffs</em> consisted of the real substance they communicated.</p>
</div>
<div class="paragraph">
<p>Patterns were first adopted by the software community as a way of documenting recurring solutions to design problems. As with Alexanderâs patterns, each design pattern entailed a number of forces to be resolved, and a number of tradeoffs to consider when applying the pattern. Patterns turn out to be a compact way to communicate <em>best practice</em>: not just the actual techniques used by experts, but the motivation and rationale behind them. Patterns have since been applied to many aspects of software development other than design, and particularly to the <em>process</em> of designing and developing software.</p>
</div>
<div class="paragraph">
<p>The process of reengineering is, like any other process, one in which many standard techniques have emerged, each of which resolves various forces and may entail many tradeoffs. Patterns as a way of communicating best practice are particularly well-suited to presenting and discussing these techniques.</p>
</div>
<div class="paragraph">
<p><em>Reengineering patterns</em> codify and record knowledge about modifying legacy software: they help in diagnosing problems and identifying weaknesses which may hinder further development of the system, and they aid in finding solutions which are more appropriate to the new requirements. We see reengineering patterns as stable units of expertise which can be consulted in any reengineering effort: they describe a process without proposing a complete methodology, and they suggest appropriate tools without âsellingâ a specific one.</p>
</div>
<div class="paragraph">
<p>Many of the reverse engineering and reengineering patterns have some superficial resemblance to design patterns, in the sense that they have something to do with the design of software. But there is an importance difference in that design patterns have to do with choosing a particular solution to a design problem, whereas reengineering patterns have to do with <em>discovering an existing design</em>, determining what <em>problems</em> it has, and <em>repairing</em> these problems. As a consequence, reengineering patterns have more to do with the <em>process of discovery and transformation</em> than purely with a given design structure. For this reason the names of most of the patterns in this book are process-oriented, like Always Have a Running Version [p. 180], rather than being structure-oriented, like Adapter [p. 293] or Facade [p. 293].</p>
</div>
<div class="paragraph">
<p>Whereas a design pattern presents a solution for a recurring <em>design</em> problem, a reengineering pattern presents a solution for a recurring <em>reengineering</em> problem. The artifacts produced by reengineering patterns are not necessarily designs. They may be as concrete as refactored code, or in the case of reverse engineering patterns, they may be abstract as insights into how the system functions.</p>
</div>
<div class="paragraph">
<p>The mark of a good reengineering pattern is (a) the clarity with which it exposes the advantages, the cost and the consequences of the target artifacts with respect to the existing system state, and <em>not</em> how elegant the result is, (b) the description of the reengineering <em>process</em>: how to get from one state of the system to another.</p>
</div>
<div class="paragraph">
<p>Reengineering patterns entail more than code refactorings. A reengineering pattern may describe a process which starts with the detection of the symptoms and ends with the refactoring of the code to arrive at the new solution. Refactoring is only the last stage of this process, and addresses the technical issue of automatically or semi-automatically modifying the code to implement the new solution. Reengineering patterns also include other elements which are not part of refactorings: they emphasize the context of the symptoms, by taking into account the constraints that reengineers are facing, and include a discussion of the impact of the changes that the refactored solution may introduce.</p>
</div>
</div>
<div class="sect2">
<h3 id="the-form-of-a-reengineering-pattern"><a class="anchor" href="#the-form-of-a-reengineering-pattern"></a>1.4 The Form of a Reengineering Pattern</h3>
<div class="paragraph">
<p>In Figure 1.2 we see an example of a simple pattern that illustrates the format we use in this book. The actual format used may vary slightly from pattern to pattern, since they deal with different kinds of issues, but generally we will see the same kind of headings.</p>
</div>
<div class="paragraph">
<p>The name of a pattern, if well-chosen, should make it easy to remember the pattern and to discuss it with colleagues. (âI think we should Refactor to Understand or we will never figure out whatâs going on here.â) The intent should communicate very compactly the essence of a pattern, and tell you whether it applies to your current situation.</p>
</div>
<div class="paragraph">
<p>Many of the reengineering patterns are concerned with code transformation, in which case a diagram may be used to illustrate the kind of transformation that takes place. Typically such patterns will additionally include steps to detect the problem to be resolved, as well as code fragments illustrating the situation before and after the transformation.</p>
</div>
</div>
<div class="sect2">
<h3 id="a-map-of-reengineering-patterns"><a class="anchor" href="#a-map-of-reengineering-patterns"></a>1.5 A Map of Reengineering Patterns</h3>
<div class="paragraph">
<p>The patterns in this book are organized according to the reengineering lifecycle presented earlier. In figure 3 we can see the chapters in this book represented as clusters of patterns along the lifecycle. The diagram suggests that the patterns may be applied in sequence. Though this may well be the case, in practice you are more likely to iterate between reverse engineering and reengineering tasks. The diagram is simplistic in the same sense that the âwaterfallâ lifeycle is simplistic: it may be a useful way to keep track of the different software engineering activities and their relationships, even though we know that they are not carried out sequentially but iteratively.</p>
</div>
<div class="paragraph">
<p>Each cluster of patterns is presented as a simple âpattern languageâ â a set of related patterns that may be combined to address a common set of problems. As such, each chapter will typically start with a overview and a map of the patterns in that chapter, suggesting how they may be related.</p>
</div>
<div class="paragraph">
<p>Setting Direction contains several patterns to help you determine where to focus your reengineering efforts, and make sure you stay on track. First Contact consists of a set of patterns that may be useful when you encounter a legacy system for the first time. Initial Understanding helps you to develop a first simple model of a legacy system, mainly in the form of class diagrams. Detailed Model Capture helps you to develop a more detailed model of a particular component of the system.</p>
</div>
<div class="paragraph">
<p><span class="image"><img src="./media/image2.jpg" alt="image" width="432" height="534"></span></p>
</div>
<div class="paragraph">
<p>Figure 1.2: The format of a typical reengineering pattern
<span class="image"><img src="./media/image3.jpg" alt="image" width="432" height="271"></span></p>
</div>
<div class="paragraph">
<p>Figure 1.3: A map of reengineering pattern clusters</p>
</div>
<div class="paragraph">
<p>Tests: Your Life Insurance! focusses on the use of testing not only to help you understand a legacy system, but also to prepare it for a reengineering effort. Migration Strategies help you keep a system running while it is being reengineered, and increase the chances that the new system will be accepted by its users. Detecting Duplicated Code can help you identify locations where code may have been copied and pasted, or merged from different versions of the software. Redistribute Responsibilities helps you discover and reengineer classes with too many responsibilities. Transform Conditionals to Polymorphism will help you to redistribute responsibilities when an object-oriented design has been compromised over time.</p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="setting-direction"><a class="anchor" href="#setting-direction"></a>2. Setting Direction</h2>
<div class="sectionbody">
<div class="paragraph">
<p>When you start a reengineering project, you will be pulled in many different directions, by management, by the users, by your own team. It is easy to be tempted to focus on the parts that are technically the most interesting, or the parts that seem like they will be easiest to fix. But what is the best strategy? How do you set the direction of the reengineering effort, and how do you maintain direction once you have started?</p>
</div>
<div class="sect2">
<h3 id="forces"><a class="anchor" href="#forces"></a>Forces</h3>
<div class="ulist">
<ul>
<li>
<p>A typical reengineering project will be burdened with a lot of interests that pull in different directions. Technical, ergonomic, economic and political considerations will make it difficult for you and your team to establish and maintain focus.</p>
</li>
<li>
<p>Communication in a reengineering project can be complicated by either the presence or absence of the original development team.</p>
</li>
<li>
<p>The legacy system will pull you towards a certain architecture that may not be the best for the future of the system.</p>
</li>
<li>
<p>You will detect many problems with the legacy software, and it will be hard to set priorities.</p>
</li>
<li>
<p>It is easy to get seduced by focussing on the technical problems that interest you the most, rather than what is best for the project.</p>
</li>
<li>
<p>It can be difficult to decide whether to wrap, refactor or rewrite a problematic component of a legacy system. Each of these options will address different risks, and will have different consequences for</p>
</li>
</ul>
</div>
<div class="paragraph">
<p><span class="image"><img src="./media/image4.jpg" alt="image" width="432" height="209"></span></p>
</div>
<div class="paragraph">
<p>Figure 2.1: Principles and guidelines to set and maintain direction in reengineering project.</p>
</div>
<div class="paragraph">
<p>the effort required, the speed with which results can be evaluated, and the kinds of changes that can be accommodated in the future.</p>
</div>
<div class="ulist">
<ul>
<li>
<p>When you are reengineering the system, you may be tempted to over-engineer the new solution to deal with every possible eventuality.</p>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="overview"><a class="anchor" href="#overview"></a>Overview</h3>
<div class="paragraph">
<p>Setting Direction is a cluster of patterns that can apply to any development project, but also have special relevance to a reengineering effort. As such, we have chosen a <em>streamlined pattern format</em> to describe them (Problem, Solution and Discussion).</p>
</div>
<div class="paragraph">
<p>You should Agree on Maxims in order to establish a common understanding within the reengineering team of what is at stake and how to achieve it. You should Appoint a Navigator to maintain the architectural vision. Everyone should Speak to the Round Table to maintain team awareness of the state of the project.</p>
</div>
<div class="paragraph">
<p>To help you focus on the right problems and the critical decisions, it is wise to tackle the Most Valuable First. Note that this will help you to Involve the Users [p. 169] and Build Confidence [p. 172]. In order to decide whether to wrap, refactor or rewrite, you should Fix Problems, Not Symptoms. Change for changeâs sake is not productive, so If It Ainât Broke, Donât Fix It. Although you may be tempted to make the new system very flexible and generic, it is almost always better to Keep It Simple.</p>
</div>
</div>
<div class="sect2">
<h3 id="agree-on-maxims"><a class="anchor" href="#agree-on-maxims"></a>2.1 Agree on Maxims</h3>
<div class="paragraph">
<p><strong>Problem</strong> <em>How do you establish a common sense of purpose in a team?</em></p>
</div>
<div class="paragraph">
<p><strong>Solution</strong> <em>Establish the key priorities for the project and identify guiding principles that will help the team to stay on track.</em></p>
</div>
<div class="paragraph">
<p><strong>Discussion</strong> Any reengineering project must cope with a large number of conflicting interests. Management wants to protect its legacy by improving competitiveness of its product and reducing maintenance costs. Users want improved functionality without disrupting their established work patterns. Developers and maintainers would like their jobs to become simpler without being made obsolete. Your team members may each have their own ideas about what a new system should look like.</p>
</div>
<div class="paragraph">
<p>Unless there is a clear understand about certain fundamental questions, such as <em>What is our business model?</em> or <em>Who is responsible for what?</em> you risk that the team will be pulled apart by conflicting interests, and you will not achieve your goal. Maxims are rules of conduct that can help steer a project that is pulled in many directions. Goldberg and Rubin [GR95] give numerous examples of maxims, such as <em>âEveryone is responsible for testing and debuggingâ</em> and <em>âYou cannot do it right the first time.â</em>
All of the patterns in this chapter can be read as maxims (rather than as patterns), since they are intended to guide a team and keep it on track. A maxim like Most Valuable First, for example, is intended to prevent a team from squandering reengineering effort on technically interesting, but marginal aspects that neither protect nor add value to the legacy system. Agree on Maxims is itself a maxim, that can help a team detect when it is rudderless.</p>
</div>
<div class="paragraph">
<p>A key point to remember is that any maxim may only have a limited lifetime. It is important to periodically reevaluate the validity of any maxims that have been adopted. A project can get completely off track if you agree on the wrong maxims, or the right ones but at the wrong time.</p>
</div>
</div>
<div class="sect2">
<h3 id="appoint-a-navigator"><a class="anchor" href="#appoint-a-navigator"></a>2.2 Appoint a Navigator</h3>
<div class="paragraph">
<p><strong>Problem</strong> <em>How do you maintain architectural vision during the course of complex project?</em></p>
</div>
<div class="paragraph">
<p><strong>Solution</strong> <em>Appoint a specific person whose responsibility in role of navigator is to ensure that the architectural vision is maintained.</em></p>
</div>
<div class="paragraph">
<p><strong>Discussion</strong> The architecture of any system tends to degrade with time as it becomes less relevant to new, emerging requirements. The challenge of a reengineering project is to develop a new architectural vision that will allow the legacy system to continue to live and evolve for several more years. Without a navigator, the design and architecture of the old system will tend to creep into and take over the new one.</p>
</div>
<div class="paragraph">
<p>You should tackle the Most Valuable First so you can determine what are the most critical issues that the new architecture should address, and test those aspects early in the reengineering project.</p>
</div>
<div class="paragraph">
<p>A sound architecture will help you to Fix Problems, Not Symptoms.
Alan OâCallaghan also refers to the navigator as the âKeeper of the Flameâ [ODF99].</p>
</div>
</div>
<div class="sect2">
<h3 id="speak-to-the-round-table"><a class="anchor" href="#speak-to-the-round-table"></a>2.3 Speak to the Round Table</h3>
<div class="paragraph">
<p><strong>Problem</strong> <em>How do you keep your team synchronized?</em></p>
</div>
<div class="paragraph">
<p><strong>Solution</strong> <em>Hold brief, regular round table meetings.</em></p>
</div>
<div class="paragraph">
<p><strong>Discussion</strong> Knowledge and understanding of a legacy system is always distributed and usually hidden. A reengineering team is also performing archeology. The information that is extracted from a legacy system is a valuable asset that must be shared for it to be exploited.</p>
</div>
<div class="paragraph">
<p>Nobody has time for meetings, but without meetings, communication is ad hoc and random. Regular, focused, round table meetings can achieve the goal of keeping team members synchronized with the current state of affairs. Round table meetings should be brief, but everyone must be required to contribute. A simple approach is to have everyone say <em>what they have done</em> since the last meeting, <em>what they have learned</em> or perhaps <em>what problems they have encountered</em>, and <em>what they plan to do</em> until the next meeting.</p>
</div>
<div class="paragraph">
<p>Round table meetings should be held at least once a week, but perhaps as often as daily.</p>
</div>
<div class="paragraph">
<p>Minutes of a meeting are important to maintain a log of progress, but keeping minutes can be an unpleasant task. To keep it simple, record only <em>decisions</em> taken and <em>actions</em> to be performed by a certain deadline.</p>
</div>
<div class="paragraph">
<p>Beck and Fowler recommend âStand Up Meetingsâ (meetings without chairs) as a way to keep round table meetings short [BF01].</p>
</div>
</div>
<div class="sect2">
<h3 id="most-valuable-first"><a class="anchor" href="#most-valuable-first"></a>2.4 Most Valuable First</h3>
<div class="paragraph">
<p><strong>Problem</strong> <em>Which problems should you focus on first?</em></p>
</div>
<div class="paragraph">
<p><strong>Solution</strong> <em>Start working on the aspects which are most valuable to your customer.</em></p>
</div>
<div class="paragraph">
<p><strong>Discussion</strong> A legacy system may suffer from a great number of problems, some of which are important, and others which may not be at all critical for the customerâs business. By focusing on the most valuable parts first, you increase the chance that you will identify the right issues at stake, and that you will be able to test early in the project the most important decisions, such as which architecture to migrate to, or what kind of flexibility to build into the new system.</p>
</div>
<div class="paragraph">
<p>By concentrating first on a part of the system that is valuable to the client, you also maximize the commitment that you, your team members and your customers will have in the project. You furthermore increase your chances of having early positive results that demonstrate that the reengineering effort is worthwhile and necessary.</p>
</div>
<div class="paragraph">
<p>Nevertheless there are a number of difficulties in applying this pattern: <em>Who is your customer?</em></p>
</div>
<div class="ulist">
<ul>
<li>
<p>There are many stakeholders in any legacy system, but only one of these is your customer. You can only set priorities if you have a clear understanding who should be calling the shots.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p><em>How do you tell what is valuable?</em></p>
</div>
<div class="ulist">
<ul>
<li>
<p>It can be difficult to assess exactly what is the most valuable aspect for a customer. Once a company asked us to assess if a system could be modularized because they wanted to switch their architecture. After long discussions with them, however, it turned out that in fact they really wanted to have a system where business rules could be more explicit, a system that new programmers could understand more easily to reduce the risk that only one programmer understands it.</p>
</li>
<li>
<p>Try to understand the customerâs business model. This will tell you how to assess the value of the various aspects of the system. Everything that does not relate directly to the business model is likely to be a purely technical side-issue.</p>
</li>
<li>
<p>Try to determine what <em>measurable goal</em> the customer wants to obtain. This must be an external manifestation of some aspect of the system or its evolution, for example, better response time, faster time to market of new features, easier tailoring to individual clients needs.</p>
</li>
<li>
<p>Try to understand whether the primary goal is mainly to <em>protect an existing asset</em>, or rather to <em>add value</em> in terms of new features or capabilities.</p>
</li>
<li>
<p>Examine the change logs and determine where the most activity has historically been in the system. The most valuable artifact is often the one which receives the most change requests (see Learn from the Past [p. 127]).</p>
</li>
<li>
<p>If the customer is unwilling or unable to set priorities, then play the <em>Planning Game</em> [BF01]: collect requirements from all the stakeholders, and make a ballpark estimate of the effort required for each identifiable task. Given an initial budget of effort for an early first milestone, ask the customer to select tasks that will fit in the budget. Repeat this exercise at each iteration.</p>
</li>
<li>
<p>Beware of <em>changing perceptions</em>. Initially the customer may draw your attention to certain symptoms of problems with the legacy system, rather than the problems themselves (see Fix Problems, Not Symptoms [p. 28]).</p>
</li>
</ul>
</div>
<div class="paragraph">
<p><em>Isnât there a risk of raising expectations too high?</em></p>
</div>
<div class="ulist">
<ul>
<li>
<p>If you fail to deliver good initial results, you will learn a lot, but you risk losing credibility. It is therefore critical to choose carefully initial tasks which not only demonstrate value for the customer, but also have a high chance of success. Therefore, take great care in estimating the effort of the initial tasks.</p>
</li>
<li>
<p>The key to success is to plan for small, frequent iterations. If the initial task identified by the customer is too large to demonstrate initial results in a short time frame (such as two weeks), then insist on breaking it down into smaller subtasks that can be tackled in shorter iterations. If you are successful in your first steps, you will certainly raise expectations, but this is not bad if the steps stay small.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p><em>What if the most valuable part is a ratâs nest?</em></p>
</div>
<div class="ulist">
<ul>
<li>
<p>Unfortunately, reengineering a legacy system is often an act of desperation, rather than a normal, periodic process of renovation. It may well be that the most valuable part of the system is also the part that is the most complex, impenetrable and difficult to modify and debug.</p>
</li>
<li>
<p>High changes rates may also be a sign of large numbers of software defects. 80% of software defects typically occur in 5% of the code, thus the strategy to âRenovate the Worst Firstâ [Dav95] can pay off big by eliminating the most serious source of problems in the system. There are nevertheless considerable risks:</p>
<div class="ulist">
<ul>
<li>
<p>it may be hard to demonstrate early, positive results,</p>
</li>
<li>
<p>you are tackling the most complicated part of the system with little information,</p>
</li>
<li>
<p>the chances are higher that you will fall flat on your face.</p>
</li>
</ul>
</div>
</li>
<li>
<p>Determine whether to wrap, refactor or rewrite the problematic component by making sure you Fix Problems, Not Symptoms.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Once you have decided what is the most valuable part of the system to work on, you should Involve the Users [p. 169] in the reengineering effort so you can Build Confidence [p. 172]. If you Migrate Systems Incrementally [p. 174], the users will be able to use the system as it is reengineered and provide continuous feedback.</p>
</div>
</div>
<div class="sect2">
<h3 id="fix-problems-not-symptoms"><a class="anchor" href="#fix-problems-not-symptoms"></a>2.5 Fix Problems, Not Symptoms</h3>
<div class="paragraph">
<p><strong>Problem</strong> <em>How can you possibly tackle all the reported problems?</em></p>
</div>
<div class="paragraph">
<p><strong>Solution</strong> <em>Address the source of a problem, rather than particular requests of your stakeholders.</em></p>
</div>
<div class="paragraph">
<p><strong>Discussion</strong> Although this is a very general principle, it has a particular relevance for reengineering. Each stakeholder has a different viewpoint of the system, and may only see part of it. The problems they want you to fix may just be manifestations of deeper problems in the system. For example, the fact that you do not get immediate feedback for certain user actions may be a consequence of a dataflow architecture. Implementing a workaround may just aggravate the problem and lead to more workarounds. If this is a real problem, you should migrate to a proper architecture.</p>
</div>
<div class="paragraph">
<p>A common difficulty during a reengineering effort is to decide whether to wrap, refactor or rewrite a legacy component. Most Valuable First will help you determine what priority to give to problems in the system, and will tell you which problems are on your critical path. Fix Problems, Not Symptoms tells you to focus on the source of a problem, and not its manifestation. For example:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>If the code of a legacy component is basically stable, and problems mainly occur with changes to clients, then the problem is likely to be with the interface to the legacy component, rather than its implementation, no matter how nasty the code is. In such a case, you should consider applying Present the Right Interface [p. 187] to just fix the interface.</p>
</li>
<li>
<p>If the legacy component is largely defect-free, but is a major bottleneck for changes to the system, then it should probably be refactored to limit the effect of future changes. You might consider applying Split Up God Class [p. 239] to migrate towards a cleaner design.</p>
</li>
<li>
<p>If the legacy component suffers from large numbers of defects, consider applying Make a Bridge to the New Town [p. 184] as a strategy for migrating legacy data to the new implementation.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>This pattern may seem to conflict with If It Ainât Broke, Donât Fix It, but it doesnât really. Something that is not really âbrokenâ cannot really be the source of a problem. Wrapping, for example, may seem to be a workaround, but it may be the right solution if the real problem is just with the interface to a legacy component.</p>
</div>
</div>
<div class="sect2">
<h3 id="if-it-aint-broke-dont-fix-it"><a class="anchor" href="#if-it-aint-broke-dont-fix-it"></a>2.6 If It Ainât Broke, Donât Fix It</h3>
<div class="paragraph">
<p><strong>Problem</strong> <em>Which parts of a legacy system should you reengineer and which should you leave as they are?</em></p>
</div>
<div class="paragraph">
<p><strong>Solution</strong> <em>Only fix the parts that are âbrokenâ â those that can no longer be adapted to planned changes.</em></p>
</div>
<div class="paragraph">
<p><strong>Discussion</strong> Change for changeâs sake is not necessarily a good thing. There may well be parts of the legacy system that may be ugly, but work well and do not pose any significant maintenance effort. If these components can be isolated and wrapped, it may never be necessary to replace them.</p>
</div>
<div class="paragraph">
<p>Anytime you âfixâ something, you also risk breaking something else in the system. You also risk wasting precious time and effort on marginal issues.</p>
</div>
<div class="paragraph">
<p>In a reengineering project, the parts that are âbrokenâ are the ones that are putting the legacy at risk:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>components that need to be frequently adapted to meet new requirements, but are difficult to modify due to high complexity and design drift,</p>
</li>
<li>
<p>components that are valuable, but traditionally contain a large number of defects.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Software artifacts that are stable and do not threaten the future of the legacy system are not âbrokenâ and do not need to be reengineered, no matter what state the code is in.</p>
</div>
</div>
<div class="sect2">
<h3 id="keep-it-simple"><a class="anchor" href="#keep-it-simple"></a>2.7 Keep It Simple</h3>
<div class="paragraph">
<p><strong>Problem</strong> <em>How much flexibility should you try to build into the new system?</em></p>
</div>
<div class="paragraph">
<p><strong>Solution</strong> <em>Prefer an adequate, but simple solution to a potentially more general, but complex solution.</em></p>
</div>
<div class="paragraph">
<p><strong>Discussion</strong> This is another general principle with special significance for reengineering. We are bad at guessing how much generality and flexibility we really need. Many software systems become bloated as every conceivable feature is added to them.</p>
</div>
<div class="paragraph">
<p>Flexibility is a double-edged sword. An important reengineering goal is to accommodate future change. But too much flexibility will make the new system so complex that you may actually impede future change.</p>
</div>
<div class="paragraph">
<p>Some people argue that it is necessary to âplan for reuseâ, hence to make an extra effort to make sure that every software entity that might conceivably by useful to somebody else is programmed in the most general way possible, with as many knobs and buttons as possible. This rarely works, since it is pretty well impossible to anticipate who will want to use something for what purpose. The same holds for end-user software.</p>
</div>
<div class="paragraph">
<p>âDo the simplest thing that will workâ is a maxim of Extreme Programming [Bec00] that applies to any reengineering effort. This strategy reinforces Involve the Users [p. 169] and Build Confidence [p. 172] since it encourages you to quickly introduce simple changes that users can evaluate and respond to.</p>
</div>
<div class="paragraph">
<p>When you do the complex thing, you will probably guess wrong (in terms of what you really need) and it will be harder to fix. If you keep things simple, you will be done faster, get feedback faster, and recover from errors more easily. Then you can make the next step.</p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="first-contact"><a class="anchor" href="#first-contact"></a>3. First Contact</h2>
<div class="sectionbody">
<div class="paragraph">
<p>You are part of a team developing a software system named <em>proDoc</em> which supports doctors in their da The main functional requirements concern (i) maintaining patient files and (ii) keeping track of the money to be paid by patients and health insurances. The health care legislation in Switzerland is quite complicated and changes regularly, hence there are few competitors to worry about. Nevertheless, a fresh start-up company has recently acquired considerable market-share with a competing product named <em>XDoctor</em>. The selling features of <em>XDoctor</em> are its platform independency and its integration with the internet. The system offers a built-in e-mail client and web-browser. <em>XDoctor</em> also exploits the internet for the transaction processing with the health insurances.</p>
</div>
<div class="paragraph">
<p>To ensure its position in the market, your company has purchased <em>XDoctor</em> and now wants to recover as much as possible from the deal. In particular, they want to lift the internet functionality out of <em>XDoctor</em> to reuse it into <em>proDoc</em>. You are asked to make a first evaluation and develop a plan on how to merge the two products into one. At the outset, there is very little known about the technical details of the competing product. From the original development team of four persons, only one has joined your company. His name is Dave and he has brought a large box to your office containing lots of paper (the documentation?) and two CDs. The first is the <em>XDoctor</em> installation disk containing an installer for Windows, MacOS and Linux. The other contains about 500,000 lines of Java code and another 10,000 lines of C code. Looking kind of desperately at this box sitting on your desk, youâre wondering âWhere on earth do I start?â</p>
</div>
<div class="sect2">
<h3 id="forces-1"><a class="anchor" href="#forces-1"></a>Forces</h3>
<div class="paragraph">
<p>It is surprising how often reengineering projects get started. Not only does it happen after a fusion of two companies, but we also encountered projects in which code libraries were obtained from companies that later went bankrupt, or in which complete maintenance teams quit their project leaving behind a very valuable but incomprehensible piece of code. Of course, the obvious question to ask is âWhere do I start?â It turns out that this is one of the crucial questions to answer during a reengineering project, which is why we devote an entire chapter to its answer.</p>
</div>
<div class="paragraph">
<p>All the patterns in this cluster can be applied to the very early stages of a reengineering project: youâre facing a system that is completely new for you, and within a few days you must determine whether something can be done with it and present a plan how to proceed. Making such an initial assessment is difficult, however, because you quickly need accurate results while considering the long-term effects of your decisions. To deal with the inherent conflict between quick, accurate and longer term effects, the patterns in this cluster must resolve the following forces.</p>
</div>
<div class="ulist">
<ul>
<li>
<p><em>Legacy systems are large and complex.</em> Scale is always an issue when dealing with legacy systems <sup class="footnote">[<a id="_footnoteref_1" class="footnote" href="#_footnote_1" title="View footnote.">1</a>]</sup>. However, there is only so much a single reengineering team can do and when the legacy system is too big or too complex you canât do the job in one shot. <em>Consequently, split the system into manageable pieces, where a manageable piece is one you can handle with a single reengineering team.</em><br></p>
<div class="paragraph">
<p>How much a single team can manage varies with the goal of the reengineering project, the state of the original system, the experience and skills in your team and the culture in your organization. Our teams consisted of three to five persons and they could handle between 500.000 and a million lines of code. However, these figures will certainly have to be adapted for the reengineering project you are facing. As a rule of the thumb, assume that a single team can reengineer as much code as they can write from scratch. Improve your estimates during the reengineering project by keeping logs of how much your team actually reengineered.<br></p>
</div>
<div class="paragraph">
<p>If you need to split the code up, stay as close as possible to current system structure and the organization of the maintenance team. Once you have a good understanding of the system structure, consider alternatives which are better suited for the project goal.</p>
</div>
</li>
<li>
<p><em>Time is scarce.</em> Wasting time early on in a project has severe consequences later on. This is especially relevant during reverse engineering, because there you feel uncertain and then it is tempting to start an activity that will keep you busy for a while instead of addressing the root of the problem. <em>Consequently, consider time as your most precious resource.</em> Therefore, defer all time-consuming activities until later and use the first days of the project to assess the feasibility of the projectâs goals. All patterns in this cluster are meant to quickly identify the opportunities and risks for your project and as such will help you set the overall direction of the project.</p>
</li>
<li>
<p><em>First impressions are dangerous.</em> Making important decisions based on incomplete knowledge implies that there is a chance you will make the wrong decision. There is no way to avoid that risk during your first contact with a system, however you can minimize its impact if you <em>always double-check your sources</em>.</p>
</li>
<li>
<p><em>People have different agendas.</em> Normally, you will join a group of people where several members will have lots of experience with the system to be reengineered. Perhaps members of the original development team are still available or maybe the reengineering team includes persons who have been maintaining the system for some time. At least there will be end users and managers who believe enough in this system to request a reengineering project. You are supposed to complement the team with your reengineering skills and expertise, hence you should know who you are dealing with.+</p>
<div class="paragraph">
<p>Typically, your new colleagues will fall into three categories. The first category are the <em>faithful</em>, the people who believe that reengineering is necessary and who thrust that you are able to (help them) do it. The second is the category of the <em>sceptical</em>, who believe this whole reengineering business is just a waste of time either because they want to protect their jobs or either because they think the whole project should start again from scratch. The third category is the category of the <em>fence sitters</em>, who do not have a strong opinion on whether this reengineering will pay off, so they just wait and see what happens. <em>Consequently, in order to make the project a success, you must keep convincing the faithful, gain credit with the fence sitters and be wary of the sceptics.</em></p>
</div>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="overview-1"><a class="anchor" href="#overview-1"></a>Overview</h3>
<div class="paragraph">
<p>Wasting time is the largest risk when you have your first contact with a system, therefore these patterns should be applied during a short time span, say one week. After this week you should grasp the main issues and</p>
</div>
<div class="paragraph">
<p><span class="image"><img src="./media/media/image5.jpg" alt="image" width="432" height="243"></span></p>
</div>
<div class="paragraph">
<p>Figure 3.1: Assess the <em>feasibility</em> of the project during your First Contact with the system.</p>
</div>
<div class="paragraph">
<p>based on that knowledge plan further activities, or â when necessary â cancel the project.</p>
</div>
<div class="paragraph">
<p>The patterns Chat with the Maintainers and Interview During Demo will help you get acquainted with the people involved. As a rule of the thumb, spend four days to gather information and use the last day of the week to compile all this information into a first project plan. There is no strict order in which to apply the patterns, although the order as suggested by the sequence in the book is kind of typical. Nevertheless, we have often find ourselves combining fragments of these patterns because of the necessity to double-check. For instance, during a second meeting with the maintainers we usually start with an Interview During Demo but ask questions about what we have learned from Read all the Code in One Hour and Skim the Documentation. Also, after an interview we quickly check the source code and documentation to confirm what has been said.</p>
</div>
<div class="paragraph">
<p>In certain situations we have experienced that some patterns are not applicable due to a lack of resources. For instance, if all the maintainers have left the company you cannot Chat with the Maintainers. Also, certain systems lack an external user-interface and then it is pointless to try an Interview During Demo with an end-user. This isnât necessarily a problem, because some of these patterns may be irrelevant for your project goal anyway. However, the absence of resources is an extra risk to the project and it should be recorded as such in the first project plan.</p>
</div>
</div>
<div class="sect2">
<h3 id="what-next"><a class="anchor" href="#what-next"></a>What Next</h3>
<div class="paragraph">
<p>Once you have the necessary information, it is time to compile the first project plan. Such a plan is very similar to the plans you normally use when launching a project and the standard document templates used in your company should therefore be used. When necessary, bend the rules to include at least the following items.</p>
</div>
<div class="ulist">
<ul>
<li>
<p><em>Project Scope.</em> Prepare a short (half a page) description of the project, including its context, its goals and the criteria that will be used to verify whether you reached those goals. Involve the Users [p. 169] and Agree on Maxims [p. 22] to write this part of the plan.</p>
</li>
<li>
<p><em>Opportunities.</em> Identify those factors you expect will contribute to achieve the project goals. List the items that you have discovered during the first contact, such as the availability of skilled maintainers and power-users, the readability of the source code or the presence of up-to date documentation.</p>
</li>
<li>
<p><em>Risks.</em> Consider elements that may cause problems during the course of the project. List those items that you did not find or where the quality was inferior, such as missing code libraries or the absence of test suites. If possible, include an assessment for the likelihood (unlikely, possible, likely) and the impact (high, moderate, low) for each risk. Special attention must be paid to the critical risks, i.e. the ones that are possible/likely and have a moderate/high impact or the ones that are likely but have a low impact.</p>
</li>
<li>
<p><em>Go / No-go decision.</em> At some point you will have to decide whether the project should be continued or cancelled. Use the above opportunities and risks to argue that decision.</p>
</li>
<li>
<p><em>Activities.</em> (In case of a âgoâ decision) Prepare a fish-eye view of the upcoming period, explaining how you intend to reach the project goal. In a fish-eye view, the short term activities are explained in considerable detail while for the later activities a rough outline is sufficient. Most likely, the short term activities will correspond to the patterns described in Initial Understanding. For the later activities check the subsequent chapters.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>The list of activities should exploit the opportunities and reduce the (critical) risks. For instance, if you list the presence of up-to date documentation as an opportunity and the absence of a test suite as a critical risk, then you should plan an activity which will build a test suite based on the documentation.</p>
</div>
</div>
<div class="sect2">
<h3 id="chat-with-the-maintainers"><a class="anchor" href="#chat-with-the-maintainers"></a>3.1 Chat with the Maintainers</h3>
<div class="paragraph">
<p><strong>Intent</strong> <em>Learn about the historical and political context of your project through discussions with the people maintaining the system.</em></p>
</div>
<div class="sect3">
<h4 id="problem"><a class="anchor" href="#problem"></a>Problem</h4>
<div class="paragraph">
<p>How do you get a good perspective on the historical and political context of the legacy system you are reengineering?</p>
</div>
<div class="paragraph">
<p><em>This problem is difficult because:</em></p>
</div>
<div class="ulist">
<ul>
<li>
<p>Documentation, if present, typically records decisions about the solution, not about the factors which have influenced that solution. Consequently, the important events in the history of the system (<em>i.e.</em>, its historical context) are rarely documented.</p>
</li>
<li>
<p>The system is valuable (otherwise they wouldnât bother to reengineer it) yet management has lost control (otherwise they wouldnât need to reengineer the system). At least some of the people related issues concerning the software system are messed up, thus the political context of a legacy system is problematic by nature.</p>
</li>
<li>
<p>Persons working with the system might mislead you. Sometimes people will deliberately deceive you, especially when they are responsible for the problematic parts of the system or when they want to protect their jobs. Most of the time they will mislead you out of ignorance, especially when chief developers are now working on other projects and the junior staff are the only ones left for system maintenance.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p><em>Yet, solving this problem is feasible because:</em></p>
</div>
<div class="ulist">
<ul>
<li>
<p>You are able to talk to the <em>maintenance team</em>. While they might not know everything about the original system context, they most likely know a great deal about how the system got to its current state.</p>
</li>
</ul>
</div>
</div>
<div class="sect3">
<h4 id="solution"><a class="anchor" href="#solution"></a>Solution</h4>
<div class="paragraph">
<p>Discuss with the system maintainers. As technical people who have been intimately involved with the legacy system, they are well aware of the systemâs history and the people-related issues that influenced that history.</p>
</div>
<div class="paragraph">
<p>To avoid misleading information, treat the maintainers as âbrothers in armsâ. Try to strike a kind of bargain where you will make their job easier (more rewarding, more appreciated, â whatever is most likely to convince them) if they will just take some time to explain you about what they are doing. This has the extra benefit that it will gain you the respect you need for the later phases of your reengineering project.</p>
</div>
<div class="sect4">
<h5 id="hints"><a class="anchor" href="#hints"></a>Hints</h5>
<div class="paragraph">
<p>Here are some questions that may help you while discussing with the maintainers. It is best to ask these questions during an informal meeting (no official minutes, no official agenda) although you should be prepared to make notes after the meeting to record your main conclusions, assumptions and concerns.</p>
</div>
<div class="ulist">
<ul>
<li>
<p>What was the easiest bug you had to fix during the last month? And what was the most difficult one? How long did it take you to fix each of them? Why was it so easy or so difficult to fix that particular bug?</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Those kinds of questions are good starters because they show that you are interested in the maintenance work. Answering the questions also gives the maintainers the opportunity to show what they excel at, which will make them less protective of their job. Finally, the answers will provide you with some concrete examples of maintenance problems you might use in later, more high-level discussions.</p>
</div>
<div class="ulist">
<ul>
<li>
<p>How does the maintenance team collect bug reports and feature requests? Who decides which request gets handled first? Who decides to assign a bug report or feature request to a maintainer? Are these events logged in some kind of database? Is there a version or configuration management system in place?</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>These questions help to understand the organization of the maintenance process and the internal working habits of the maintenance team. As far as the political context concerns, it helps to assess the relationship within the team (task assignment) and with the end users (collection of bug reports).</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Who was part of the development/maintenance team during the course of years? How did they join/leave the project? How did this affect the release history of the system?</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>These are questions which directly address the history of the legacy system. It is a good idea to ask about persons because people generally have a good recollection of former colleagues. By afterwards asking how they joined or left the project, you get a sense for the political context as well.</p>
</div>
<div class="ulist">
<ul>
<li>
<p>How good is the code? How trustworthy is the documentation?</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>This question is especially relevant to see how well the maintenance team itself can assess the state of the system. Of course you will have to verify their claims yourself afterwards (see Read all the Code in One Hour and Skim the Documentation).</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Why is this reengineering project started? What do you expect from this project? What will you gain from the results?</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>It is crucial to ask what the maintainers will gain from the reengineering project as it is something to keep in mind during the later phases. Listen for differences â sometimes subtle â in what management told you they expect from the project and what the maintainers expect from it. Identifying the differences will help you get a sense of the political context.</p>
</div>
</div>
</div>
<div class="sect3">
<h4 id="tradeoffs"><a class="anchor" href="#tradeoffs"></a>Tradeoffs</h4>
<div class="sect4">
<h5 id="pros"><a class="anchor" href="#pros"></a>Pros</h5>
<div class="ulist">
<ul>
<li>
<p><em>Obtains information effectively.</em> Most of the significant events in the life-time of a software system are passed on orally. Discussing with the maintainers is the most effective way to tap into this rich information source.</p>
</li>
<li>
<p><em>Get acquainted with your colleagues.</em> By discussing with the maintainers you have a first chance to appraise your colleagues. As such, youâre likely to gain the necessary credibility that will help you in the later phases of the reengineering project.</p>
</li>
</ul>
</div>
</div>
<div class="sect4">
<h5 id="cons"><a class="anchor" href="#cons"></a>Cons</h5>
<div class="ulist">
<ul>
<li>
<p><em>Provides anecdotal evidence only.</em> The information you obtain is anecdotal at best. The human brain is necessarily selective regarding which facts it remembers, thus the recollection of the maintainers may be insufficient. Worse, the information may be incomplete to start with, since the maintainers are often not the original developers of the system. Consequently, you will have to complement the information you obtained by other means (see for instance Skim the Documentation, Interview During Demo, Read all the Code in One Hour and Do a Mock Installation).</p>
</li>
</ul>
</div>
</div>
<div class="sect4">
<h5 id="difficulties"><a class="anchor" href="#difficulties"></a>Difficulties</h5>
<div class="ulist">
<ul>
<li>
<p><em>People protect their jobs.</em> Some maintainers may not be willing to provide you with the information you need because they are afraid of losing their jobs. Itâs up to you to convince them that the reengineering project is there to make their job easier, more rewarding, more appreciated. Consequently, you should ask the maintainers what they expect from the reengineering project themselves.</p>
</li>
<li>
<p><em>Teams may be unstable.</em> Software maintenance is generally considered a second-class job, often left to junior programmers and often leading to a maintenance team which changes frequently. In such a situation, the maintainers cannot tell you about the historical evolution of a software system, yet it tells you a great deal about its political context. Indeed, you must be aware of such instability in the team, as it will increase the risk of your project and reduce the reliability of the information you obtain. Consequently, you should ask who has been part of the development/maintenance team over the course of the years.</p>
</li>
</ul>
</div>
</div>
</div>
<div class="sect3">
<h4 id="example"><a class="anchor" href="#example"></a>Example</h4>
<div class="paragraph">
<p>While taking over <em>XDoctor</em>, your company has been trying to persuade the original development team to stay on and merge the two software systems into one. Unfortunately, only one member â Dave â has agreed to stay and the three others have left for another company. As it is your job to develop a plan for how to merge the two products, you invite Dave for lunch to have an informal chat about the system.</p>
</div>
<div class="paragraph">
<p>During this chat you learn a great deal. The good news is that Dave was responsible for implementing the internet communication protocols handling the transactions with the health insurances. As this was one of the key features lacking in your product, youâre happy to have this experience added to your team. More good news is that Dave tells you his former colleagues were quite experienced in object-oriented technology, so you suspect a reasonable design and readable source code. Finally, you hear that few bug reports were submitted and that most of them have been handled fast. Likewise, the list of pending product enhancements exists and is reasonably small. So you conclude that the customers are quite happy with the product and that your project will be strategically important.</p>
</div>
<div class="paragraph">
<p>The not so good news is that Dave is a hard core C-programmer who was mainly ignored by his colleagues and left out of the design activity for the rest of the system. When you ask about his motives to stay in the project he tells you that he originally joined because he was interested to experiment with internet technology but that he is kind of bored with the low-level protocol stuff he has been doing and wants to do more interesting work. Of course, you ask him what he means with âmore interestingâ and he replies that he wants to program with objects.</p>
</div>
<div class="paragraph">
<p>After the discussion, you make a mental note to check the source code to assess the quality of the code Dave has written. You also want to have a look at the list of pending bugs and requests for enhancements to compare the functionality of the two products you are supposed to merge. Finally, you consider contacting the training department to see whether they have courses on object-oriented programming as this may be a way to motivate your new team member.</p>
</div>
</div>
<div class="sect3">
<h4 id="rationale"><a class="anchor" href="#rationale"></a>Rationale</h4>
<div class="paragraph">
<p>âThe major problems of our work are not so much technological as sociological in nature.ââ Tom De Marco, [DL99]</p>
</div>
<div class="paragraph">
<p>Accepting the premise that the sociological issues concerning a software project are far more important then the technological ones, any reengineering project must at least know the political context of the system under study.</p>
</div>
<div class="paragraph">
<p><em>âOrganizations which design systems are constrained to produce designs which are copies of the communications structure of these organizations.â
â Melvin Conway, [Con68]</em></p>
</div>
<div class="paragraph">
<p>Conwayâs law is often paraphrased as: âIf you have 4 groups working on a compiler; youâll get a 4-pass compilerâ</p>
</div>
<div class="paragraph">
<p>One particular reason why it is important to know about the way the development team was organized, is because it is likely that this structure will somehow reflect the structure of the source code.</p>
</div>
<div class="paragraph">
<p>A second reason is that before formulating a plan for a reengineering project, you must know the capabilities of your team members as well as the peculiarities of the software system to be reverse engineered. Discussing with the maintainers is one of the ways â and given the âtime is scarceâ principle, a very efficient one â to obtain that knowledge.</p>
</div>
<div class="paragraph">
<p>âMaintenance fact #1: In the late â60s and throughout the 70âs, production system support and maintenance were clearly treated as second-class work.
Maintenance fact #2: In 1998, support and maintenance of production systems continues to be treated as second-class work.â
â Rob Thomsett, [Tho98]</p>
</div>
<div class="paragraph">
<p>While talking with the maintainers, you should be aware that software maintenance is often considered second-class work. If thatâs the case for the maintenance team you are talking with, it may seriously disturb the discussion. Either because the maintenance team has changed frequently, in which case the maintainers themselves are unaware of the historical evolution. Or because the people you discuss with are very protective about their job, in which case they will not tell you what you need to know.</p>
</div>
</div>
<div class="sect3">
<h4 id="known-uses"><a class="anchor" href="#known-uses"></a>Known uses</h4>
<div class="paragraph">
<p>During our experience with reengineering projects we made it a habit to kick-off the project during a meeting with the maintenance team. Only in retrospect did we understand how crucial such a meeting is to build up the trust required for the rest of the project. We learned the hard way that maintainers are very proud about their job and very sensitive to critique. Therefore, we emphasize that such a kick-off meeting must be âmaintainer orientedâ, i.e. aimed to let the maintainers show what they do well and what they want to do better. Coming in with the attitude that you â the newcomer â will teach these stupid maintainers how to do a proper job will almost certainly lead to disasters.</p>
</div>
<div class="paragraph">
<p><em>âThe RT-100 â was developed by a third-party software vendor in the late 1980s and acquired by Nortel in 1990. For the next three years Nortel enhanced and maintained it before outsourcing it to another vendor to be systematically rewritten. This effort failed and the system was returned to Nortel in mid 1994. By this time, the original design team has been disbanded and scattered, and the productâs six customers organizations were quite unhappy.
_RT-100 was assigned to Nortelâs Atlanta Technology Park laboratory. No staff members there had any experience with ACD software, and, due to another projectâs cancellation, staff morale was quite low.â
â Spencer Rugaber and Jim White, [RW98]</em></p>
</div>
<div class="paragraph">
<p>The above quote is from a paper which describes the story of a reengineering project, and depicts very well the typical desperation a reengineering project had to start with. Yet â as described in the paper itself â this early assessment of the historical and political context made it possible for the project to succeed, because they knew very well which factors would make the stakeholders happy and consequently could motivate the new reengineering team.</p>
</div>
<div class="paragraph">
<p>In one of the case-studies of the DESEL project (Designing for Ease of System Evolution), Stephen Cook reports that it is crucial to talk to the maintainers as they know best which aspects of the domain are likely to change and which ones are likely to remain stable [CHR01]. As such, the maintainers have submerged knowledge about how the system could have been built, knowledge which is seldom documented. Yet, during this discussion one must emphasize a âdesign for evolutionâ mind-set, to force the maintainers to detach themselves from the latest problems they have been solving.</p>
</div>
</div>
<div class="sect3">
<h4 id="related-patterns"><a class="anchor" href="#related-patterns"></a>Related Patterns</h4>
<div class="paragraph">
<p>There are several pattern languages which explicitly deal with the way a software development team is organized [Cop95] [Har96] [Tay00] [BDS<sup>+</sup>00]. Although meant for a forward engineering situation, it is good to be aware of them while discussing with the maintainers, because it may help you assess the situation more quickly.</p>
</div>
</div>
<div class="sect3">
<h4 id="what-next-1"><a class="anchor" href="#what-next-1"></a>What Next</h4>
<div class="paragraph">
<p>During the discussion, you should avoid jumping to conclusions. Therefore, make sure that whatever you learn out of the discussion is verified against other sources. Typically these sources are the people working with the system (Interview During Demo), the documentation (Skim the Documentation) and the system itself (<em>i.e.</em>, Read all the Code in One Hour &amp; Do a Mock Installation).</p>
</div>
<div class="paragraph">
<p>With this verification, you have a solid basis to write down an initial plan for tackling the legacy system, including the possibility to cancel the project altogether. The discussion with the maintainers will influence this plan in various ways. First of all, you have a sense for the willingness of the maintenance team to cooperate, which will affect the work plan considerably. Second, you know the history of the system, including those parts that make it valuable and those events that caused most of the maintenance problems. Your plan will aim to resurrect the valuable parts and tackle those maintenance problems. Third, you have a sense for how the maintenance team communicates with the other stakeholders, which is important to get the plan accepted.</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="read-all-the-code-in-one-hour"><a class="anchor" href="#read-all-the-code-in-one-hour"></a>3.2 Read all the Code in One Hour</h3>
<div class="paragraph">
<p><strong>Intent</strong> <em>Assess the state of a software system by means of a brief, but intensive code review.</em></p>
</div>
<div class="sect3">
<h4 id="problem-1"><a class="anchor" href="#problem-1"></a>Problem</h4>
<div class="paragraph">
<p>How can you get a first impression of the quality of the source code?</p>
</div>
<div class="paragraph">
<p><em>This problem is difficult because:</em></p>
</div>
<div class="ulist">
<ul>
<li>
<p>The quality of the source code will vary quite a lot, depending on the people that have been involved in the development and maintenance of the system.</p>
</li>
<li>
<p>The system is large, so there is too much data to inspect for an accurate assessment.</p>
</li>
<li>
<p>Youâre unfamiliar with the software system, so you do not know how to filter out whatâs relevant.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p><em>Yet, solving this problem is feasible because:</em></p>
</div>
<div class="ulist">
<ul>
<li>
<p>You have reasonable <em>expertise</em> with the implementation language being used, thus you can recognize programming idioms and code smells.</p>
</li>
<li>
<p>Your reengineering project has a <em>clear goal</em>, so you can assess the kind of code quality required to obtain that goal.</p>
</li>
</ul>
</div>
</div>
<div class="sect3">
<h4 id="solution-1"><a class="anchor" href="#solution-1"></a>Solution</h4>
<div class="paragraph">
<p>Grant yourself a reasonably short amount of study time (<em>i.e.</em>, approximately one hour) to read the source code. Make sure that you will not be disturbed (unplug the telephone and disconnect your e-mail) and take notes sparingly to maximize the contact with the code.</p>
</div>
<div class="paragraph">
<p>After this reading session, produce a short report about your findings, including</p>
</div>
<div class="ulist">
<ul>
<li>
<p>a general assessment of whether reengineering seems feasible and why (not);</p>
</li>
<li>
<p>entities which seem important (<em>i.e.</em>, classes, packages, Â·Â·Â·);</p>
</li>
<li>
<p>suspicious coding styles discovered (<em>i.e.</em>, âcode smellsâ [FBB<sup>+</sup>99]);</p>
</li>
<li>
<p>parts which must be investigated further (<em>i.e.</em>, tests).</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Keep this report short, and name the entities like they are mentioned in the source code.</p>
</div>
<div class="sect4">
<h5 id="hints-1"><a class="anchor" href="#hints-1"></a>Hints</h5>
<div class="paragraph">
<p>The âtime is scarceâ principle demands some preparation. A checklist might help you focus your effort during the reading session. Such a checklist may be compiled from various sources.</p>
</div>
<div class="ulist">
<ul>
<li>
<p>The development team may have employed <em>code reviews</em> as part of their quality assurance. If they did, make sure you incorporate the checklists used during the reviews. If they didnât, try some generic checklists used to review the kind of code you are dealing with.</p>
</li>
<li>
<p>Some development teams applied <em>coding styles</em> and if they did, it is good to be aware of them. Naming conventions especially are crucial to scan code quickly.</p>
</li>
<li>
<p>The programmers might have used <em>coding idioms</em> (<em>i.e.</em>, C++ [Cop92] [Mey98] [Mey96]; Smalltalk [Bec97]) which help you recognize typical language constructs.</p>
</li>
<li>
<p>You probably have some <em>questions</em> that you would like an answer to.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Below are some additional items you might add to your checklist because they provide good entry points for further examination.</p>
</div>
<div class="ulist">
<ul>
<li>
<p><em>Functional tests and unit tests</em> convey important information about the functionality of a software system. They can help to verify whether the system is functioning as expected, which is very imported during reengineering (see Tests: Your Life Insurance!).</p>
</li>
<li>
<p><em>Abstract classes and methods</em> reveal design intentions.</p>
</li>
<li>
<p>Classes <em>high in the hierarchy</em> often define domain abstractions; their subclasses introduce variations on a theme.</p>
</li>
<li>
<p>Occurrences of the Singleton [p. 295] pattern may represent information that is constant for the entire execution of a system.</p>
</li>
<li>
<p>Surprisingly <em>large structures</em> often specify important chunks of functionality.</p>
</li>
<li>
<p><em>Comments</em> reveal a lot about the design intentions behind a particular piece of code, yet may often be misleading.</p>
</li>
</ul>
</div>
</div>
</div>
<div class="sect3">
<h4 id="tradeoffs-1"><a class="anchor" href="#tradeoffs-1"></a>Tradeoffs</h4>
<div class="sect4">
<h5 id="pros-1"><a class="anchor" href="#pros-1"></a>Pros</h5>
<div class="ulist">
<ul>
<li>
<p><em>Start efficiently.</em> Reading the code in a short amount of time is very efficient as a starter. Indeed, by limiting the time and yet forcing yourself to look at all the code, you mainly use your brain and coding expertise to filter out what seems important.</p>
</li>
<li>
<p><em>Judge sincerely.</em> By reading the code directly you get an unbiased view of the software system including a sense for the details and a glimpse on the kind of problems you are facing. Because the source code describes the functionality of the system â no more, no less â it is the only accurate source of information.</p>
</li>
<li>
<p><em>Learn the developers vocabulary.</em> Acquiring the vocabulary used inside the software system is essential to understand it and communicate about it with other developers. This pattern helps to acquire such a vocabulary.</p>
</li>
</ul>
</div>
</div>
<div class="sect4">
<h5 id="cons-1"><a class="anchor" href="#cons-1"></a>Cons</h5>
<div class="ulist">
<ul>
<li>
<p><em>Obtain low abstraction.</em> Via this pattern, you will get some insight in the solution domain, but only very little on how these map onto problem domain concepts. Consequently, you will have to complement the information you obtained with other, more abstract representations (for instance Skim the Documentation and Interview During Demo).</p>
</li>
</ul>
</div>
</div>
<div class="sect4">
<h5 id="difficulties-1"><a class="anchor" href="#difficulties-1"></a>Difficulties</h5>
<div class="ulist">
<ul>
<li>
<p><em>Does not scale.</em> Reading <em>all</em> the code does not scale very well, from our experience a rate of 10,000 lines of code per hour is reasonable. When facing large or complex code, donât try to spend more time to read more code as intensive reading is most effective when done is short bursts of time (no more than 2 hours). Instead, if you have a clear criterion to split the source code, try to pass a series of sessions. Otherwise, just go through all of the code and mark those parts that seem more important than others (based on Chat with the Maintainers) and then read in different sessions.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>However, given the âTime is Scarceâ principle, you should force yourself to be brief. Consequently, when dealing with large or complex code, donât bother too much with the details but remind yourself of the goal of reading the code, which is an initial assessment of the suitability for reengineering.</p>
</div>
<div class="ulist">
<ul>
<li>
<p><em>Comments may mislead you.</em> Be careful with comments in the code. Comments can help you in understanding what a piece of software is supposed to do. However, just like other kinds of documentation, comments can be outdated, obsolete or simply wrong. Consequently, when finding comments mark on your checklist whether it seems helpful and whether it seems outdated.</p>
</li>
</ul>
</div>
</div>
</div>
<div class="sect3">
<h4 id="example-1"><a class="anchor" href="#example-1"></a>Example</h4>
<div class="paragraph">
<p>From the discussion with Dave (the sole person left from the original development team and the one responsible for the low-level C-code) you recall that their system was mainly written in Java, with some low-level parts written in C and the database queries in SQL. You have experience with all these languages, so you are able to read the code.</p>
</div>
<div class="paragraph">
<p>You start by preparing a check-list and besides the normal items (coding styles, tests, abstract classes and methods, classes high in the hierarchy, Â·Â·Â·) you add a few items concerning some questions you want resolved. One of them is âReadability of the C-codeâ, because you want to verify the coding style of Dave, your new team member. A second is the âQuality of the database schemaâ, because you know that the data of the two systems sooner or later will have to be integrated. A third is the âHandling of currenciesâ, because Switzerland will join the Euro-region and within six months all financial data must be converted to this new currency.</p>
</div>
<div class="paragraph">
<p>From reading the C-code, you learn that this part is quite cryptic (short identifiers with mysterious abbreviations, long multi-exit loops, Â·Â·Â·). Nevertheless, the modules handling the internet protocols have unit tests, which makes you feel more confident about the possibility to incorporate them into your system.</p>
</div>
<div class="paragraph">
<p>The Java code presents a problem of scale: you canât read 50.000 lines of code in a single hour. Therefore, you pick some files at random and you immediately discover that most class names have a two-character prefix, which is either UI or DB. You suspect a naming convention marking a 2tiered architecture (database layer and user-interface layer) and you make a note to investigate this further. Also, you recognize various class- and attribute names as being meaningful for the health care domain (such as Class DBPatient with attributes name, address, health insurance, Â·Â·Â·). You even perceive a class DBCurrency, so you suppose that switching to Euro wonât cause a lot of problems, since the developers took the necessary precautions. Most of the classes and methods have comments following the Javadoc conventions, so you suspect that at least some of the documentation will be up-to date. Finally, you identified a large singleton object which contains various strings that are displayed on the screen, which leads you to conclude that it will even be possible to localize the system.</p>
</div>
<div class="paragraph">
<p>All this looks rather promising, however there are also a number of discouraging observations. What makes you most pessimistic is the presence of numerous long methods with large parameter lists and complex conditionals. Many of them seem to mix UI-logic (enabling/disabling of buttons and menu-items) with business-logic (updating database records). One thing (the calculation of prices) seems especially complicated and you make a note to investigate this further.</p>
</div>
<div class="paragraph">
<p>Concerning the database, you again recognize various table names and column names that are meaningful in the context of the health care domain. At first glance, the schema looks normalized, so here as well reverse engineering seems promising. The database also employs some stored procedures, which warrants further investigation.</p>
</div>
<div class="paragraph">
<p>After the reading session, you summarize your conclusions in the following note.</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Incorporating the internet protocols is feasible: unit-tests and responsible programmer available.</p>
</li>
<li>
<p>Suspect a 2-tiered architecture based on naming convention. What about the business logic â mixed in with UI? (further verification!)</p>
</li>
<li>
<p>Readable code with meaningful identifiers; reverse engineering looks promising.</p>
</li>
<li>
<p>Currency object is present: Euro-conversion looks feasible (further investigation!)</p>
</li>
<li>
<p>Javadoc conventions used; verify documentation.</p>
</li>
<li>
<p>Calculation of prices seems complicated; why?</p>
</li>
<li>
<p>Database schema looks promising. Stored procedures requires further investigation.</p>
</li>
</ul>
</div>
</div>
<div class="sect3">
<h4 id="rationale-1"><a class="anchor" href="#rationale-1"></a>Rationale</h4>
<div class="paragraph">
<p>Code reviews are widely acknowledged as being a very effective means to find problems in programs written by peers [GG93] [Gla97]. Two important prerequisites have to be met in order to make such reviews costeffective: (a) a <em>checklist</em> must be prepared to help the reviewer focus on the relevant questions and (b) a review session must be kept <em>short</em> because reviewers cannot concentrate for a very long time (2 hours at maximum).</p>
</div>
<div class="paragraph">
<p>I took a course in speed reading and read âWar and Peaceâ in twenty minutes. Itâs about Russia.â Woody Allen</p>
</div>
<div class="paragraph">
<p>There is an important difference between traditional code reviews and the ones you perform during your first contact with a software system. The former is typically meant to detect errors, while the latter is meant to get a first impression. This difference implies that you need to care less about details and thus that you can read more code. Typical guidelines for code-reviews state that about 150 statements per hour can be reviewed [BP94]. However, during your first contact you donât need such a detailed analysis and thus can increase the volume of code to be reviewed. We didnât perform any serious empirical investigation, but from our experience 10,000 lines of code per hour seems reasonable.</p>
</div>
</div>
<div class="sect3">
<h4 id="known-uses-1"><a class="anchor" href="#known-uses-1"></a>Known Uses</h4>
<div class="paragraph">
<p>The original pattern was suggested by Kent Beck, who stated that it is one of the techniques he always applies when starting a consultant job on an existing system. Robson [RBCM91] reports code reading as âthe crudest method of gaining knowledge about a systemâ and acknowledges that it is the method most commonly used to understand an existing program. Some case studies reports also mention that reading the source code is one of the ways to start a reengineering project [BH95] [JC00].</p>
</div>
<div class="paragraph">
<p>While writing this pattern, one of our team members applied it to reverse engineer the Refactoring Browser [RBJ97]. The person was not familiar with Smalltalk, yet was able to get a feel for the system structure by a mere inspection of class interfaces. Also, a special hierarchy browser did help to identify some of the main classes and the comments provided some useful hints to what parts of the code were supposed to do. Applying the pattern took a bit more than an hour, which seemed enough for a relatively small system and slow progress due to the unfamiliarity with Smalltalk.</p>
</div>
<div class="paragraph">
<p>One particularly interesting occurrence of this pattern took place towards the end of the FAMOOS project. During the course of one week, a heterogeneous team of reverse engineers went for an on-site visit to participate in a kind of reverse engineering contest. The assignment was to invest four days and use the available reverse engineering tools to learn as much as possible about a particular C++ system. The fifth day was then used to report the findings to the original developers for verification. One of the team members finished his assignment too early, and took the opportunity to Read all the Code in One Hour. It turned out that this one person had a much better overview of the system: he could participate in all discussions and could even explain some of the comments of the developers.</p>
</div>
</div>
<div class="sect3">
<h4 id="what-next-2"><a class="anchor" href="#what-next-2"></a>What Next</h4>
<div class="paragraph">
<p>After you Read all the Code in One Hour you should Do a Mock Installation to evaluate the suitability for reengineering. You may complement your findings if you Skim the Documentation and carry out an Interview During Demo to maximize your chances of getting a coherent view of the system. Before actually making a decision on how to proceed with the reengineering project, it is probably worthwhile to Chat with the Maintainers once more.</p>
</div>
<div class="paragraph">
<p>At the end of your first contact with the system, you should decide on how to proceed with (or cancel) the project. Reading the code will influence this decision in various ways. First of all, you have assessed the quality of the code (<em>i.e.</em>, the presence of coding idioms and suspicious coding styles) and thus of the feasibility of reengineering project. Second, you have identified some important entities, which are good starting points for further exploration.</p>
</div>
<div class="paragraph">
<p>The list of the important entities (<em>i.e.</em>, classes, packages, Â·Â·Â·) resulting from Read all the Code in One Hour can be used to start Analyze the Persistent Data [p. 77] and Study the Exceptional Entities [p. 96]. This way you can refine your understanding of the source code, especially the way it represents the problem domain.</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="skim-the-documentation"><a class="anchor" href="#skim-the-documentation"></a>3.3 Skim the Documentation</h3>
<div class="paragraph">
<p><strong>Intent</strong> <em>Assess the relevance of the documentation by reading it in a limited amount of time.</em></p>
</div>
<div class="sect3">
<h4 id="problem-2"><a class="anchor" href="#problem-2"></a>Problem</h4>
<div class="paragraph">
<p>How to identify those parts of the documentation that might be of help?</p>
</div>
<div class="paragraph">
<p><em>This problem is difficult because:</em></p>
</div>
<div class="ulist">
<ul>
<li>
<p>Documentation, if present, is usually intended for the development team or the end users and as such not immediately relevant for reengineering purposes. Worse, it is typically out of date with respect to the current state of affairs, thus it may contain misleading information.</p>
</li>
<li>
<p>You do not yet know how the reengineering project will proceed, hence you cannot know which parts of the documentation will be relevant.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p><em>Yet, solving this problem is feasible because:</em></p>
</div>
<div class="ulist">
<ul>
<li>
<p>Some form of <em>documentation</em> is available, so at least there is a description that was intended to help the humans concerned with the system.</p>
</li>
<li>
<p>Your reengineering project has a <em>clear goal</em>, so you can select those parts of the documentation that may be valuable and those parts that will be useless.</p>
</li>
</ul>
</div>
</div>
<div class="sect3">
<h4 id="solution-2"><a class="anchor" href="#solution-2"></a>Solution</h4>
<div class="paragraph">
<p>Prepare a list summarizing those aspects of the system that seem interesting for your reengineering project. Then, match this list against the documentation and meanwhile make a crude assessment of how up to date the documentation seems. Finally, summarize your findings in a short report, including</p>
</div>
<div class="ulist">
<ul>
<li>
<p>a general assessment of whether the system documentation will be useful and why (not);</p>
</li>
<li>
<p>a list of those parts of the documentation that seem useful and why (<em>e.g.</em>, requirement specifications, desired features, important constraints, design diagrams, user and operator manuals);</p>
</li>
<li>
<p>for each part, an impression of how up to date the description is.</p>
</li>
</ul>
</div>
<div class="sect4">
<h5 id="hints-2"><a class="anchor" href="#hints-2"></a>Hints</h5>
<div class="paragraph">
<p>Depending on the goal of the reengineering project and the kind of documentation you have at your disposal, you may steer the reading process to match your main interest. For instance, if you want insight into the original system requirements then you should look inside the system specification, while knowledge about which features are actually implemented should be collected from the end-user manual or tutorial notes. If you have the luxury of choice, avoid spending too much time trying to understand the design documentation (<em>i.e.</em>, class diagrams, database schemas, Â·Â·Â·): rather record the presence and reliability of such documents as this will be of great help in the later stages of reengineering.</p>
</div>
<div class="paragraph">
<p>Check whether the documentation is outdated with respect to the actual system. Always compare version dates with the date of delivery of the system and make note of those parts that you suspect are unreliable.</p>
</div>
<div class="paragraph">
<p>The fact that you are limited in time should force you to think how you can extract the most useful information. Below are some hints for things to look out for.</p>
</div>
<div class="ulist">
<ul>
<li>
<p>A <em>table of contents</em> gives you a quick overview of the structure and the information presented.</p>
</li>
<li>
<p><em>Version numbers and dates</em> tell you how up to date that part of the documentation is.</p>
</li>
<li>
<p><em>Figures</em> are a a good means to communicate information. A list of figures, if present, may provide a quick access path to certain parts of the documentation.</p>
</li>
<li>
<p><em>Screen-dumps, sample print-outs, sample reports, command descriptions</em>, reveal a lot about the functionality provided by the system.</p>
</li>
<li>
<p><em>Formal specifications</em> (<em>e.g.</em>, state-charts), if present, usually correspond with crucial functionality.</p>
</li>
<li>
<p>An <em>index</em>, if present contains the terms the author considers significant.</p>
</li>
</ul>
</div>
</div>
</div>
<div class="sect3">
<h4 id="tradeoffs-2"><a class="anchor" href="#tradeoffs-2"></a>Tradeoffs</h4>
<div class="sect4">
<h5 id="pros-2"><a class="anchor" href="#pros-2"></a>Pros</h5>
<div class="ulist">
<ul>
<li>
<p><em>Provides a high abstraction level.</em> Documentation is supposed to be read by humans, thus at a certain level of abstraction. It may be that this abstraction level is not high enough for your reengineering project, but at least you can skip a few decoding steps.</p>
</li>
<li>
<p><em>Focus on relevant parts.</em> By preparing yourself with a list of what seems interesting the reading session becomes goal-oriented, as such increasing your chances of finding something worthwhile. Moreover, by making a quick assessment of how up to date the description is, you avoid to waste time on irrelevant parts.</p>
</li>
</ul>
</div>
</div>
<div class="sect4">
<h5 id="cons-2"><a class="anchor" href="#cons-2"></a>Cons</h5>
<div class="ulist">
<ul>
<li>
<p><em>Misses crucial facts.</em> A quick read in overview mode is likely to miss crucial facts recorded in the documentation. However, you can counter this effect to some degree by preparing yourself a list of what you would like to find.</p>
</li>
<li>
<p><em>You may find irrelevant information only.</em> There is a small chance that not a single part of the documentation seems relevant for your reengineering project. Even in such a situation, the time spent on reading is worthwhile because now you can justify not to worry about the documentation.</p>
</li>
</ul>
</div>
</div>
<div class="sect4">
<h5 id="difficulties-2"><a class="anchor" href="#difficulties-2"></a>Difficulties</h5>
<div class="ulist">
<ul>
<li>
<p><em>Targets a different audience.</em> Documentation is costly to produce, hence is written for the end users (<em>e.g.</em>, user manuals) or the development team (<em>e.g.</em>, design). Documentation is also costly to maintain, hence only the stable parts of the system are documented. Consequently, the information you find may not be directly relevant, hence will require careful interpretation.</p>
</li>
<li>
<p><em>Documentation contains inconsistencies.</em> Documentation is almost always out of date with respect to the actual situation. This is quite dangerous during the early phases of a reengineering project, because you lack the knowledge to recognize such inconsistencies. Consequently, avoid to make important decisions based on documentation only â first verify your findings by other means (in particular, Read all the Code in One Hour and Interview During Demo).</p>
</li>
</ul>
</div>
</div>
</div>
<div class="sect3">
<h4 id="example-2"><a class="anchor" href="#example-2"></a>Example</h4>
<div class="paragraph">
<p>After your informal chat with Dave and your code reading sessions you have some general idea what would be the interesting aspects of the system. You decide to skim through the documentation to see whether it contains relevant information.</p>
</div>
<div class="paragraph">
<p>You prepare yourself by compiling a list of aspects you would like to read about. Besides obvious items like design diagrams, class interface descriptions (Javadoc?) and database schema, the list includes Euro (does the user manual say something about Euro conversions?) and the specification of internet protocol.</p>
</div>
<div class="paragraph">
<p>Next, you go to Dave and ask him for all of the documentation concerning the software system. Dave looks at you with a small grin on his face: âYouâre not really gonna read all of that, are you?â âNot exactly,â you say to him, âbut at least I want to know whether we can do something with it.â Dave looks in the box he has given you earlier and hands you three folders full of paper â the design documentation â and one booklet â the user manual.</p>
</div>
<div class="paragraph">
<p>You start with the user manual and â bingo: in the index you discover an entry for Euro. Turning to the corresponding pages, you see that the Euro is actually a chapter on its own consisting of about five pages, so you mark those page numbers for further study. Next you skim through the table of contents and there you notice a title âSwitching to French / Germanâ. Reading these pages you see that localizing the software is a documented feature. Localizing wasnât in your checklist but it is still important so you gladly add a note about it. All of this looks rather promising, so you verify the release date of the user manual and you see that it is quite recent. A good start indeed!</p>
</div>
<div class="paragraph">
<p>Opening the first folder (entitled âClassesâ) of the design documentation, you find more or less what you were expecting: a print-out of the class interface as generated by Javadoc. Not that interesting to read on paper, but you continue to leaf through the pages anyway. Your first impression is that the actual descriptions coming with each of the classes and methods are quite shallow. An impression which gets confirmed when you examine three random pages in more detail. Next, you look for descriptions for those classes interfacing with the C-code implementing the internet protocol and there you even find empty descriptions. The litmus test with the release date of the documentation reveals that this documentation is quite old, so you make a note to check the online documentation.</p>
</div>
<div class="paragraph">
<p>The second folder contains a nice surprise: it is a generated description of the database schema, describing for each table what the purpose of each column is. Just like with the Javadoc class interface descriptions, the documentation itself is quite shallow but at least you have a way of finding what each record in the database is supposed to represent. Here as well, the litmus test with the document release date tells you to verify the online version of the same documentation.</p>
</div>
<div class="paragraph">
<p>At first glance, the third folder seems to contain rubbish: various copies of miscellaneous documents which seem only vaguely related with your project. The first document is a price-list for medicines, the next ten are extracts from the health care legislation. Still you continue to leaf through the pages and you stumble upon some finite state diagrams which appear to describe the internet protocol used to communicate with the health insurances. Apparently, the document is a copy from some pages out of a technical specification but unfortunately no references to the original are included. Even the release date for this document is missing, so you donât have the means to verify whether this specification is outdated.</p>
</div>
<div class="paragraph">
<p>You conclude the reading session with the following report:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>User manual is clear and up-to date: good source for black-box description of functionality.</p>
</li>
<li>
<p>Euro is provided for (pp. 513-518); localization as well (pp. 723-725).</p>
</li>
<li>
<p>Class interfaces descriptions are generated; shallow but verify on line.</p>
</li>
<li>
<p>Documentation for database schema is generated; shallow but verify on line.</p>
</li>
<li>
<p>Finite state-machines for the internet protocol? Status questionable: verify with Dave.</p>
</li>
<li>
<p>One folder containing miscellaneous documents (price-lists, instruction leaflets,&#8230;&#8203;)</p>
</li>
</ul>
</div>
</div>
<div class="sect3">
<h4 id="rationale-2"><a class="anchor" href="#rationale-2"></a>Rationale</h4>
<div class="paragraph">
<p>âIt is not unusual for a software development organization to spend as much as 20 or 30 percent of all software development effort on documentation.â
â Roger Pressman, [Pre94]</p>
</div>
<div class="paragraph">
<p>Documentation, as opposed to source code, is intended to explain the software system at an abstraction level well suited for humans. Therefore, the documentation will certainly contain information ânuggetsâ; the only problem is how to find the relevant ones. Finding relevant information is made difficult because of two typical circumstances present in almost all reengineering projects.</p>
</div>
<div class="paragraph">
<p>âAll of the case-studies face the problem of non-existent, unsatisfactory or inconsistent documentationâ
â ESEC/FSE 1997 Workshop on Object-Oriented Re-engineering, [DG97]</p>
</div>
<div class="paragraph">
<p>First of all, the documentation is likely to be out of sync with respect to the actual situation. For the five case-studies we investigated during the FAMOOS project, âinsufficient documentationâ was the only problem all maintainers complained about. Nevertheless, even outdated information may be useful, because at least it tells you how the system was supposed to behave in the past. This is a good starting point to infer how it is used today.</p>
</div>
<div class="paragraph">
<p>âThe documentation that exists for these systems usually describes isolated parts but not the overall architecture. Moreover, the documentation is often scattered throughout the system and on different mediaâ
Kenny Wong, <em>et al.</em>, [WTMS95]</p>
</div>
<div class="paragraph">
<p>Second, documentation is normally produced in a forward engineering context, hence not intended for reengineering purposes. Generated design documentation (<em>e.g.</em>, database schemas, Javadoc) for instance, is typically quite up-to date, yet too fine-grained to be useful during the initial phases of a reengineering project. User manuals are black box descriptions of the software system, and thus cannot serve as blueprints of whatâs inside the boxes. Here as well you should see the documentation as a good starting point to infer what youâre really interested in.</p>
</div>
</div>
<div class="sect3">
<h4 id="known-uses-2"><a class="anchor" href="#known-uses-2"></a>Known Uses</h4>
<div class="paragraph">
<p>A study by Fjeldstadt and Hamlen reported that âin making an enhancement, maintenance programmers studied the original program about three-and-a-half times as long as they studied the documentation, but just as long as they spent implementing the enhancement.â [Cor89] quoting [FH79]. This equation gives a good impression of the relative importance studying the documentation should have.</p>
</div>
<div class="paragraph">
<p>âThe case-study began with an effort to understand the existing design of CTAS in general and the CM in particular. â The documentation for CTAS includes motivation and architecture overview, software structures, user manuals and research papers on the underlying algorithms. However, there appears to be no document that explains in high-level terms what the system computes or what assumptions it makes about its environment. Nor is there a design document that explains the relationship between the CTAS components: how they communicate, what services they offer, and so forth. We were forced to infer this information from the code, a challenge common to many commercial development efforts.â
â Daniel Jackson &amp; John Chapin, [JC00]</p>
</div>
<div class="paragraph">
<p>The above quotation summarizes quite well that you need to study the documentation, yet that it will not tell you all you need to know. The casestudy they are referring to concerns an air-traffic control system (CTAS) where they reverse- and reengineered a key component <em>CommunicationsManager</em> (CM) of about 80 KLOC C++ code.</p>
</div>
<div class="paragraph">
<p>The following anecdote reveals how documentation might mislead you. In one of the FAMOOS case-studies we were asked to evaluate wether a distributed system connecting about a dozen subsystems could be scaled up to connect approximately hundred subsystems. During this evaluation, we studied the class responsible for maintaining all of the TCP/IP connections where the comments described how all of the open connections were maintained in a kind of look-up table. We did find a look-up table in the code, but we were unable to map the description of how it worked back to operations manipulating the table. After half a day of puzzling, we gave up and decided to ask the maintainer. His matter-offact response was, âAh, but this class comment is obsolete. Now that you mention it, I should have deleted it when I redesigned that class.â</p>
</div>
</div>
<div class="sect3">
<h4 id="what-next-3"><a class="anchor" href="#what-next-3"></a>What Next</h4>
<div class="paragraph">
<p>You may want to Read all the Code in One Hour immediately after Skim the Documentation to verify certain findings. It may also be worthwhile to Chat with the Maintainers and Interview During Demo to confirm certain suspicions.</p>
</div>
<div class="paragraph">
<p>At the end of your first contact with the system, you should decide on how to proceed with (or cancel) the project. Once you have discovered relevant documentation you know that you at least do not have to reproduce this information. Even better, for those parts of the documentation that are relevant but seem inaccurate you have some good starting points for further exploration (for instance Analyze the Persistent Data [p. 77] and Speculate about Design [p. 87]).</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="interview-during-demo"><a class="anchor" href="#interview-during-demo"></a>3.4 Interview During Demo</h3>
<div class="paragraph">
<p><strong>Intent</strong> <em>Obtain an initial feeling for the appreciated functionality of a software system by seeing a demo and interviewing the person giving the demo.</em></p>
</div>
<div class="sect3">
<h4 id="problem-3"><a class="anchor" href="#problem-3"></a>Problem</h4>
<div class="paragraph">
<p>How can you get an idea of the typical usage scenarios and the main features of a software system?</p>
</div>
<div class="paragraph">
<p><em>This problem is difficult because:</em></p>
</div>
<div class="ulist">
<ul>
<li>
<p>Typical usage scenarios vary quite a lot depending on the type of user.</p>
</li>
<li>
<p>If you ask the users, they have a tendency to complain about whatâs wrong, while for reverse engineering purposes youâre mainly interested in whatâs valuable.</p>
</li>
<li>
<p>The system is large, so there is too much data to inspect for an accurate assessment.</p>
</li>
<li>
<p>Youâre unfamiliar with the software system, so you do not know how to filter out whatâs relevant.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p><em>Yet, solving this problem is feasible because:</em></p>
</div>
<div class="ulist">
<ul>
<li>
<p>You can exploit the presence of a working system and a few users who can demonstrate how they use the software system.</p>
</li>
</ul>
</div>
</div>
<div class="sect3">
<h4 id="solution-3"><a class="anchor" href="#solution-3"></a>Solution</h4>
<div class="paragraph">
<p>Observe the system in operation by seeing a demo and interviewing the person who is demonstrating. Note that the interviewing part is at least as enlightening as the demo.</p>
</div>
<div class="paragraph">
<p>After this demo, take about the same amount of time to produce a report about your findings, including:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>some typical usage scenarios;</p>
</li>
<li>
<p>the main features offered by the system and whether they are appreciated or not;</p>
</li>
<li>
<p>the system components and their responsibilities;</p>
</li>
<li>
<p>bizarre anecdotes that reveal the folklore around using the system.</p>
</li>
</ul>
</div>
<div class="sect4">
<h5 id="hints-3"><a class="anchor" href="#hints-3"></a>Hints</h5>
<div class="paragraph">
<p>The user who is giving the demo is crucial to the outcome of this pattern so take care when selecting the person. Therefore, do the demonstration several times with different persons giving the demo. This way you will see variations in what people find important and you will hear different opinions about the value of the software system. Always be wary of enthusiastic supporters or fervent opponents: although they will certainly provide relevant information, you must spend extra time to look for complementary opinions in order to avoid prejudices.</p>
</div>
<div class="paragraph">
<p>Below are some hints concerning people you should be looking for, what kind of information you may expect from them and what kind of questions you should ask. Of course which people you should talk to depends very much on the goal of your reengineering project and the kind of organization surrounding it, hence this list is provided as a starting point only.</p>
</div>
<div class="ulist">
<ul>
<li>
<p>An <em>end-user</em> should tell you how the system looks like from the outside and explain some detailed usage scenarios based on the daily working practices. Ask about the working habits before the software system was introduced to assess the scope of the software system within the business processes.</p>
</li>
<li>
<p>A <em>manager</em> should inform you how the system fits within the rest of the business domain. Ask about the business processes around the system to check for unspoken motives concerning your reengineering project. This is important as reengineering is rarely a goal in itself, it is just a means to achieve another goal.</p>
</li>
<li>
<p>A person from the <em>sales department</em> ought to compare your software system with competing systems. Ask for a demo of the functionality most requested by the users (this is not necessarily the same as most appreciated!) and ask how this has evolved in the past and how it might evolve in the future. Use the opportunity to get insight into the various types of end-users that exist and the way the software system is likely to evolve.</p>
</li>
<li>
<p>A person from the <em>help desk</em> should demonstrate you which features cause most of the problems. During this part of the demo, ask how they explain it to their users, because this may reveal mismatches between the actual business practices and the way it is modelled by the software system. Try to get them to divulge bizarre anecdotes to get a feeling for the folklore around the software system.</p>
</li>
<li>
<p>A <em>system administrator</em> should show you all that is happening behind the scenes of the software system (<em>i.e.</em>, startup and shutdown, backup procedures, data archival, Â·Â·Â·). Ask for past horror stories to assess the reliability of the system.</p>
</li>
<li>
<p>A <em>maintainer/developer</em> may demonstrate you some of the subsystems. Ask how this subsystem communicates with the other subsystems and why (and who!) it was designed that way. Use the opportunity to get insight in the architecture of the system and the trade-offs that influenced the design.</p>
</li>
</ul>
</div>
</div>
<div class="sect4">
<h5 id="variants"><a class="anchor" href="#variants"></a>Variants</h5>
<div class="paragraph">
<p><em>Demonstrate to yourself</em>. A scaled-down variant of Interview During Demo consists of the reverse engineer who demonstrates the system to him- or herself via a trial-and-error process. Such a demonstration obviously lacks the group dynamics that boosts the demonstration, but on the other hand may serve as a preparation technique for a discussion with the designers/maintainers.</p>
</div>
</div>
</div>
<div class="sect3">
<h4 id="tradeoffs-3"><a class="anchor" href="#tradeoffs-3"></a>Tradeoffs</h4>
<div class="sect4">
<h5 id="pros-3"><a class="anchor" href="#pros-3"></a>Pros</h5>
<div class="ulist">
<ul>
<li>
<p><em>Focuses on valued features.</em> The fact of giving a demo will gently coerce the interviewee to demonstrate those features which are appreciated. As a reverse engineer, thatâs of course your main interest.</p>
</li>
<li>
<p><em>Provides lots of qualitative data.</em> Conducting an interview typically results in a wealth of relevant information, which is very hard to extract by other means.</p>
</li>
<li>
<p><em>Increases your credibility.</em> Performing an interview, shows to the interviewee that there is a genuine interest in his or her opinions about that system. The interview thus provides a unique opportunity to enlarge the end-users confidence in the result of your reengineering project.</p>
</li>
</ul>
</div>
</div>
<div class="sect4">
<h5 id="cons-3"><a class="anchor" href="#cons-3"></a>Cons</h5>
<div class="ulist">
<ul>
<li>
<p><em>Provides anecdotal evidence only.</em> The information you obtain is anecdotal at best, just like it is with Chat with the Maintainers. Interviewees will almost certainly omit important facts, either because they forgot or either because they deemed it uninteresting. This effect will be countered to some degree by demonstration, yet prepare to complement the information you obtained by other means (see for instance Skim the Documentation, Read all the Code in One Hour and Do a Mock Installation).</p>
</li>
<li>
<p><em>Time may be lacking.</em> At least one person should be able to do the demonstration. This seems a simple requirement but may be hard to achieve in practice. Some systems (embedded systems for example) just donât have human users and â given the âtime is scarceâ principle â sometimes it will take too long to make an appointment with someone who is willing to demonstrate the system.</p>
</li>
</ul>
</div>
</div>
<div class="sect4">
<h5 id="difficulties-3"><a class="anchor" href="#difficulties-3"></a>Difficulties</h5>
<div class="ulist">
<ul>
<li>
<p><em>Requires interviewing experience.</em> The way the questions are phrased has considerable impact on the outcome of the interview. Unfortunately, not all reverse engineers have the necessary skills to conduct good interviews. When youâre unexperienced, rely on flow of the demonstration to trigger the right kind of questions.</p>
</li>
<li>
<p><em>Selecting interviewees may be difficult.</em> You should avoid to interview enthusiastic supporters or fervent opponents. Unfortunately, in the beginning of a reengineering project you lack the knowledge to make a good selection. Consequently, rely on other personsâ opinions to make the selection, but prepare to adjust the results based on the enthusiasm (or lack of it) of the interviewees.</p>
</li>
<li>
<p><em>How to handle real-time software.</em> For certain kinds of systems (especially real-time systems), it is impossible to answer questions while operating the software system. In such a situation, jot down your questions while seeing the demo, and do the actual interview afterwards.</p>
</li>
</ul>
</div>
</div>
</div>
<div class="sect3">
<h4 id="example-3"><a class="anchor" href="#example-3"></a>Example</h4>
<div class="paragraph">
<p>Now that you checked the source code and the documentation youâre almost convinced that reengineering the <em>XDoctor</em> system will be feasible. However, you still have some doubts about what precisely should be reverse engineered because you donât really know what the users appreciate in the system. Via the sales department, you get in touch with one of the current users and you make an appointment for the next day. Youâre also worried about the state of the internet protocol (incl. the state-chart specification you discovered in the documentation) and the way it fits in with the rest of the system, so you step to Dave and ask him whether he can give you a demo of the internet protocols.</p>
</div>
<div class="paragraph">
<p>Dave is quite pleased to show you his work and immediately starts to type on his keyboard. âSee, now I launched the serverâ he says, pointing at a little console window that appeared on the screen. âWait a secondâ, you reply, âwhat command did you type there?â. âLSVR; you know, for Launch Serverâ. A bit surprised you ask Dave if there is some kind of manual explaining how to start-up and shut-down this server. Dave explains that there isnât, but that it is quite easy to infer from the batch file starting the whole system. He even tells you that there are some command-line options associated with LSVR and that they are all documented in a READ.ME file and via the -h(elp) option. Next, Dave starts a test program (yes, it is invoked via LSVRTST) and in the console window you see that the server is actually receiving traffic, while the test program is spitting out a long log of all the messages sent and received. Of course, you ask him how he knows that the test succeeded and to your dismay he states that this is done by manually inspecting the log. You decide to switch topics and ask him why this subsystem is called a server, because you would guess that it is actually running on the client machine. This question triggers a heated discussion which eventually leads to an architecture diagram like the one depicted in figure 6, showing a remote server (managed by the health insurances and accepting), a local server (the L in LSVR probably stands for âlocalâ and not âlaunchâ) and some local clients. From this discussion you kind of understand how the complete system is working. The basic idea is that there are several client computers on various desks connected to a local server via a LAN-network. The local server maintains the database and the internet connections to the health insurances. With the diagram on a little sheet of paper, you ask Dave where this internet protocol originated from. This question again triggers a long story which reminds you that the protocol is designed in Germany (hence the reason why itâs documented with state-charts) and now adopted by the national health insurance companies.</p>
</div>
<div class="paragraph">
<p>The next day, you put on your suit and drive off to have a meeting with doctor Mary Johanssen. While introducing yourself, you get the impression that she is not so pleased. You explain the reason of your visit and during the conversation you understand that the doctor is quite worried about your company taking over the <em>XDoctor</em> software. You do your very best to assure her that the main purpose of the demonstration and interview is precisely to learn how your company may best serve the current users and that they do not intend to stop supporting it. Reassured, she starts the actual demonstration. Not surprisingly, the most appreciated feature is the automatic transaction processing with the health insurances, because âit means that I can save on a secretary to do the paperworkâ. However, Doctor Johanssen also shows you some other features you were not aware of: built-in e-mail, export to spreadsheet (âI just e-mail this file to my bookkeeperâ),</p>
</div>
<div class="paragraph">
<p><span class="image"><img src="./media/image6.png" alt="image" width="426" height="183"></span></p>
</div>
<div class="paragraph">
<p>Figure 3.2: The architecture diagram as you inferred it from the discussion with the maintainer.</p>
</div>
<div class="paragraph">
<p>payments in multiple currencies (âReal good to deal with Eurosâ). During the course of the demo she tells you that in the beginning the system was a bit unstable (apparently she served as an betatester) and that there are some weird mistakes (the list of patients is sorted by first name instead of family name) but all in all she is very pleased with the system.</p>
</div>
<div class="paragraph">
<p>Once you are back in your office you write a small report, which includes the sequence of commands for testing the local server plus the usage scenarioâs for the automatic transaction processing and the payment with multiple currencies. Your report also includes the architecture diagram (figure 6) and the following observations.</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Testing of internet protocols is manually: investigate regression tests.</p>
</li>
<li>
<p>Internet protocol spec comes from a consortium of German health insurances.</p>
</li>
<li>
<p>Sorting of patient list: by first name instead of last name.</p>
</li>
</ul>
</div>
</div>
<div class="sect3">
<h4 id="rationale-3"><a class="anchor" href="#rationale-3"></a>Rationale</h4>
<div class="paragraph">
<p><em>âThe ability to respond flexibly to the intervieweeâs responses is one of the reasons why interviews are so widely usedâ
â Simon Bennett, et al., [BMF99]</em></p>
</div>
<div class="paragraph">
<p><em>âInterviews are well suited to exploratory studies where one does not know yet what one is looking for, since the interviewer can adjust the interview to the situationâ
â Jakob Nielsen, [Nie99]</em></p>
</div>
<div class="paragraph">
<p>Interviewing people working with a software system is essential to get a handle on the important functionality and the typical usage scenarioâs. However, asking predefined questions does not work, because in the initial phases of reengineering you do not know what to ask. Merely asking what people like about a system will result in vague or meaningless answers. On top of that, you risk getting a very negative picture because users have a tendency to complain about a legacy system.</p>
</div>
<div class="paragraph">
<p><em>âThe real challenge of analysis begins when the expert must communicate the concept to someone else â to an analyst. Since the concept is often very rich and expansive, it is generally not possible for experts adequately to communicate their entire understanding in a single, holistic expression.â
â Adele Goldberg &amp; Kenny Rubin, [GR95]</em></p>
</div>
<div class="paragraph">
<p>Compared to a forward engineering situation, a reverse engineer has one major advantage: there is a working software system available and you can exploit its presence. In such a situation it is safe to hand over the initiative to the user by requesting a demo. First of all, a demo allows users to tell the story in their own words, yet is comprehensible because the demo imposes some kind of tangible structure. Second, because users must start from a working system, they will adopt a more positive attitude explaining what works. Finally, during the course of the demo, the interviewer can ask lots of precise questions, getting lots of precise answers, this way digging out the expert knowledge about the systemâs usage.</p>
</div>
</div>
<div class="sect3">
<h4 id="known-uses-3"><a class="anchor" href="#known-uses-3"></a>Known Uses</h4>
<div class="paragraph">
<p>The main idea of this pattern â let the user explain the system while using it â is commonly used for evaluating user-interfaces. âThinking aloud may be the single most valuable usability engineering method. Basically, a thinking-aloud test involves having a test subject use the system while continuously thinking out loud.â [Nie99] The same idea is also often applied during rapid prototyping for requirements elicitation [Som96].</p>
</div>
<div class="paragraph">
<p>One anecdote from the very beginning of the FAMOOS project â an application of the <em>Demonstrate to yourself</em> variant of this pattern â shows how ignorant questions arising from seeing a software system in action may trigger dormant expertise within the maintenance team. For one of the case studies â a typical example of a 3-tiered system with a database layer, domain objects layer and user-interface layer â we were asked âto get the business objects outâ. Two separate individuals were set to that task, one took a source code browser and a CASE tool and extracted some class diagrams that represented those business objects. The other installed the system on his local PC and spent about an hour playing around with the user interface (that is, he demonstrated the system to himself) to come up with a list of ten questions about some strange observations he made. Afterwards, a meeting was organized with the chief analyst-designer of the system and the two individuals that tried to reverse engineer the system. When the analyst-designer was confronted with the class-diagrams he confirmed that these were indeed the business objects, but he couldnât tell us whether there was something missing, nor did he tell us anything about the rationale behind his design. It was only when we asked him the ten questions that he launched off into a very enthusiastic and very detailed explanation of the problems he was facing during the design â he even pointed to our class diagrams during his story! After having listened to the analyst-designer, the first reaction of the person that extracted the class diagrams from the source code was âGee, I never read that in the source codeâ.</p>
</div>
</div>
<div class="sect3">
<h4 id="related-patterns-1"><a class="anchor" href="#related-patterns-1"></a>Related Patterns</h4>
<div class="paragraph">
<p>A lot of good advice concerning how to interact with end users is embodied in the âCustomer Interaction Patternsâ [Ris00]. The main message of these patterns is that âItâs a Relationship, Not a Saleâ, emphasizing that your contacts with the end users should aim to develop a relationship of trust.</p>
</div>
</div>
<div class="sect3">
<h4 id="what-next-4"><a class="anchor" href="#what-next-4"></a>What Next</h4>
<div class="paragraph">
<p>For optimum results, you should carry out several attempts of Interview During Demo with different kinds of people. Depending on your taste, you may perform these attempts before, after or interwoven with Read all the Code in One Hour and Skim the Documentation. Afterwards, consider to Chat with the Maintainers to verify some of your findings.</p>
</div>
<div class="paragraph">
<p>At the end of your first contact with the system, you should decide on how to proceed with (or cancel) the project. By seeing the demonstrations, you get a feeling for how the people use the system and which features are appreciated. As such you know the valuable parts of the software system and these are probably the ones that must be reverse engineered. The usage scenarios will also serve as an input for patterns like Speculate about Design [p. 87] and Record Business Rules as Tests [p. 159].</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="do-a-mock-installation"><a class="anchor" href="#do-a-mock-installation"></a>3.5 Do a Mock Installation</h3>
<div class="paragraph">
<p><strong>Intent</strong> <em>Check whether you have the necessary artefacts available by installing the system and recompiling the code.</em></p>
</div>
<div class="sect3">
<h4 id="problem-4"><a class="anchor" href="#problem-4"></a>Problem</h4>
<div class="paragraph">
<p>How can you be sure that you will be able to (re)build the system?</p>
</div>
<div class="paragraph">
<p><em>This problem is difficult because:</em></p>
</div>
<div class="ulist">
<ul>
<li>
<p>The system is new for you, so you do not know which files you need to build the system.</p>
</li>
<li>
<p>The system may depend on libraries, framework, patches and youâre uncertain whether you have the right versions available.</p>
</li>
<li>
<p>The system is large and complex and the exact configuration under which the system is supposed to run is unclear.</p>
</li>
<li>
<p>The maintainers may answer these questions, or you may find the answers in the manual, but you still must verify whether this answer is complete.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p><em>Yet, solving this problem is feasible because:</em></p>
</div>
<div class="ulist">
<ul>
<li>
<p>You have access to the <em>source code</em> and the necessary build tools (<em>i.e.</em>, the makefiles, compilers, linkers).</p>
</li>
<li>
<p>You have the ability to <em>re-install</em> the system in an environment that is similar to that of the running system (<em>i.e.</em>, the installation CD and a computer with the right operating system).</p>
</li>
<li>
<p>Maybe the system includes some kind of <em>self test</em> (see Tests: Your Life Insurance!), which you can use to verify whether the build or install succeeded.</p>
</li>
</ul>
</div>
</div>
<div class="sect3">
<h4 id="solution-4"><a class="anchor" href="#solution-4"></a>Solution</h4>
<div class="paragraph">
<p>Try to install and build the system in a clean environment during a limited amount of time (at most one day). Run the self test if the system includes one.</p>
</div>
<div class="sect4">
<h5 id="hints-4"><a class="anchor" href="#hints-4"></a>Hints</h5>
<div class="paragraph">
<p>The main idea is to verify whether you are able to replicate the install and build processes, not to understand them completely.</p>
</div>
<div class="paragraph">
<p>Log all small failures you encounter during the build and installation process and the way you solved them, because this will tell you about the configuration of the system and its dependencies on libraries, frameworks and patches. For example you may learn that the system cannot be compiled on a certain location, needs an old legacy library only accessible from a particular machine, or needs a particular patch of the libraries.</p>
</div>
<div class="paragraph">
<p>It is possible that at the end of the day you did not succeed to build or install the system completely. This corresponds to a high probability/high impact risk for your reengineering project and therefore, before you continue, you must plan to study the build and install procedures and adapt them where necessary.</p>
</div>
<div class="paragraph">
<p>After this build and install experiment, prepare a report containing:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><em>version numbers</em> of libraries, frameworks and patches used;</p>
</li>
<li>
<p><em>dependencies</em> between the infrastructure (database, network toolkits, ports, Â·Â·Â·);</p>
</li>
<li>
<p><em>problems</em> you encountered and how you tried to solve them;</p>
</li>
<li>
<p>suggestions for <em>improvement</em>;</p>
</li>
<li>
<p>(in case of incomplete installation or build) your <em>assessment</em> of the situation, including possibilities for solutions and workarounds.</p>
</li>
</ul>
</div>
</div>
</div>
<div class="sect3">
<h4 id="tradeoffs-4"><a class="anchor" href="#tradeoffs-4"></a>Tradeoffs</h4>
<div class="sect4">
<h5 id="pros-4"><a class="anchor" href="#pros-4"></a>Pros</h5>
<div class="ulist">
<ul>
<li>
<p><em>Essential prerequisite.</em> The ability to (re)build or (re)install the system is essential for a reengineering project, therefore you must assess this issue early on. If building or installing proves to be difficult or impossible, plan the necessary corrective actions.</p>
</li>
<li>
<p><em>Demands precision.</em> Replicating the build and installation process forces you to be precise about the components required. Especially for migration projects this information is crucial because all the components must be available on the target platform as well.</p>
</li>
<li>
<p><em>Increase your credibility.</em> After the build or install you will have firsthand experience with the steps that prove to be difficult. It should be easy to offer some concrete suggestions for improvement, which will undoubtedly increase your credibility with the maintenance team.</p>
</li>
</ul>
</div>
</div>
<div class="sect4">
<h5 id="cons-4"><a class="anchor" href="#cons-4"></a>Cons</h5>
<div class="ulist">
<ul>
<li>
<p><em>Tedious activity.</em> You will feel very unproductive while you are busy tracking down the causes behind your failures to install the system, especially since most of the problems depend on trivial details that do not interest you now. You can counter this effect to some extent by limiting the amount of time you devote to Do a Mock Installation, but then you will feel even more unproductive because you will not have succeeded in building or installing the system.</p>
</li>
<li>
<p><em>No certainty.</em> Although this pattern demands precision, there is no guarantee that you will actually succeed to build the system after you have reengineered some of its components. Especially when a reliable self-test is missing you cannot verify whether your build or install was complete.</p>
</li>
</ul>
</div>
</div>
<div class="sect4">
<h5 id="difficulties-4"><a class="anchor" href="#difficulties-4"></a>Difficulties</h5>
<div class="ulist">
<ul>
<li>
<p><em>Easy to get carried away.</em> Building or installing a complex system may easily fail due to external factors (missing components, unclear installation scripts). It is tempting to continue fixing these annoying problems due to the ânext time it will workâ effect. Rather than getting carried away with these details, it is important not to lose sight of the main goal, which is not to build the system, but to gain insight into the build process. Consequently you should limit the time you spend, and focus on documenting the problems that arise so you can address them later.</p>
</li>
</ul>
</div>
</div>
</div>
<div class="sect3">
<h4 id="example-4"><a class="anchor" href="#example-4"></a>Example</h4>
<div class="paragraph">
<p>You have carried out an Interview During Demo with some end users, and consequently have a feeling for the important features that should be preserved during your reengineering project. However, before accepting the project you still must verify whether you will be able to change the system. Hence, you decide to do a quick experiment to see whether you carry out a clean build of the system.</p>
</div>
<div class="paragraph">
<p>From the box that Dave has left in your office, you take the second CD containing all the source code. Browsing the directories you notice one top-level makefile and you decide to give it a try. You copy all the files to the Linux partition of your system and type the command make all at the prompt. Everything goes smoothly for a while and the system reports numerous successful java compilations. Unfortunately, after a few minutes the make fails due to a missing library java.sql. You realize that you still have a JDK1.1 installed, while you remember that the documentation mentioned that it should have been JDK1.3. Reluctantly, you trash the whole directory structure, uninstall JDK1.1, download and install a JDK1.3 (downloading takes forever so you fetch yourself a cup of real coffee), and then start again. This time the make proceeds smoothly until the compiling of the C-code starts. The first compilation immediately fails due to a missing library file and you open the C-file to see what exactly is causing this failure. Apparently something must be wrong with the search paths, because assert.h is a standard library you know is available in your system. By then it is almost lunch-time and since you planned to finish this build experiment today, you decide to leave the whole C-compilation for later. Dave is here anyway, and since he wrote this C-code he will surely be able to show you how to compile it.</p>
</div>
<div class="paragraph">
<p>After lunch, you want to verify whether what you built is OK. A grep of "void main(" reveals that <em>XDoctor</em>.java file contains the main entry so you type java <em>XDoctor</em> to launch the system. And indeed, the start-up screen you recognize from the demonstration appears and a little status window appears telling that the <em>âthe system is connecting to the databaseâ</em>. Immediately thereafter, the system fails with a <em>âsomething unexpected happensâ</em> message and you suspect this is due to the missing database. You decide to investigate this issue later and turn your attention to the installation procedure.</p>
</div>
<div class="paragraph">
<p>You put the installation-CD in the CD-drive of your Macintosh to see whether you are able to install the system. Automatically, the typical installation window appears and you proceed through the installation process smoothly. After the installation process completes, the installer asks you to reboot your computer before launching the system. You make a note to verify which system extensions are installed, reboot your computer and then double-click the <em>XDoctor</em> icon which appeared on your desktop. Unfortunately, a window appears which asks you to provide a license key. Studying the CD-box you read that you must have received the license key in a separate letter which of course you did not receive. âToo badâ, you think âit would have been nice to run a demo-version of the system when no license key is provided, just as we do with our <em>proDoc</em>â. Frustrated you decide to give up and write the following report.</p>
</div>
<div class="ulist">
<ul>
<li>
<p>make with a JDK1.3 appears to work; could not verify whether this build was complete.</p>
</li>
<li>
<p>C-compilation fails: request Dave to demonstrate the build</p>
</li>
<li>
<p>Investigate licensing in further detail: how is the system protected?</p>
</li>
<li>
<p><em>Suggestion:</em> if no license key is provided, run in demo-mode (cf. <em>proDoc</em>).</p>
</li>
<li>
<p><em>Suggestion:</em> verify pre-conditions when calling XDoctor.main(); system exits with âsomething unexpectedly happensâ after a fresh build.</p>
</li>
</ul>
</div>
</div>
<div class="sect3">
<h4 id="known-uses-4"><a class="anchor" href="#known-uses-4"></a>Known Uses</h4>
<div class="paragraph">
<p>In one of the FAMOOS case studies, we had to reengineer a distributed system that was communicating over sockets with a central server by means of a little command language. We received a tape containing a tarfile which â according to the letter attached â âcontains everything that is requiredâ. Rebuilding and reinstalling the system proved to be difficult, however, and we had to dive into the installation scripts and ask the maintainers for clarification. In the end, we could not communicate with the central server due to security and connection problems, but we were able to test the system in simulation mode. Although the experiment did not succeed completely, it gave us insights into the systemâs architecture. In particular, the way the simulation mode mimicked the central server and the way this was encoded in the source code and the makefiles provided us with information that turned out to be crucial during the rest of the project.</p>
</div>
<div class="paragraph">
<p>Towards the end of the first day of an auditing project we carried out, we requested to see a clean install the following morning. We considered this to be an innocent request meant to prepare things for an Interview During Demo, but during the installation we discovered that one maintainer had to stay overnight to prepare the installation CD. From the subsequent discussion we learned that the system wasnât meant to be installed: the user base was fixed and the system was designed to download weekly updates over the internet. This explained many peculiarities we observed during a previous effort to Read all the Code in One Hour and helped us a lot to expose the design issues during the remainder of the auditing project.</p>
</div>
<div class="paragraph">
<p>When working with a configuration management system, it is a good idea to first try to import the code into a clean configuration before recompiling it. In case of a Smalltalk system for instance, one general piece of advice is to first try to load the Envy configuration maps that compose the system and then load the code into a clean image [PK01].</p>
</div>
</div>
<div class="sect3">
<h4 id="what-next-5"><a class="anchor" href="#what-next-5"></a>What Next</h4>
<div class="paragraph">
<p>It can be a good idea to Chat with the Maintainers before you report your conclusions. They may be able to confirm your findings and clear up some misconceptions. Concrete suggestions for improvement are best discussed with the maintainers, because it is the best way to convince them that you really mean to help them.</p>
</div>
<div class="paragraph">
<p>When the build or installation fails completely, you may want to combine Interview During Demo with Do a Mock Installation. In that case, invite a maintainer to demonstrate the build or installation process and ask questions about those steps you have found unclear.</p>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="initial-understanding"><a class="anchor" href="#initial-understanding"></a>4. Initial Understanding</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Your company develops and distributes a medical information system named <em>proDoc</em> for use by doctors. Now the company has bought a competing software <em>XDoctor</em> product that provides internet support to perform transactions with various health insurance companies. The two products should be merged into a single system.</p>
</div>
<div class="paragraph">
<p>A first evaluation of <em>XDoctor</em> has revealed that a few components should somehow be recovered and integrated into yours. Of course, to successfully recover a software component, you must understand its inner structure as well as its connections with the rest of the system. For instance, your company has promised that customers âwonât lose a single byte of dataâ, hence you must recover the database contents and consequently understand the database structure and how the upper layers depend on it. Also, your company has promised to continue and even expand the transaction support with health insurance companies, hence you must recover the network communication component used to communicate with these remote services.</p>
</div>
<div class="sect2">
<h3 id="forces-2"><a class="anchor" href="#forces-2"></a>Forces</h3>
<div class="paragraph">
<p>Situations similar to this one occur frequently in reengineering projects. After the First Contact [p. 33] with the system and its users, it is clear what kind of functionality is valuable and why it must be recovered. However, you lack knowledge about the overall design of the software system, so you cannot predict whether this functionality can be lifted out of the legacy system and how much effort that will cost you. Such initial understanding is crucial for the success of a reengineering project and this chapter will explain how to obtain it.</p>
</div>
<div class="paragraph">
<p>The patterns in First Contact should have helped you to get some first ideas about the software system. Now is the right time to refine those ideas into an initial understanding and to document that understanding in order to support further reverse engineering activities. The main priority at this stage of reverse engineering is to set up a reliable foundation for the rest of your project, thus you must make sure that your discoveries are correct and properly documented.</p>
</div>
<div class="paragraph">
<p>How to properly document your discoveries depends largely on the scope of your project and the size of the your team. A complicated reverse engineering project involving more than ten developers, demands some standard document templates and a configuration management system. At the other extreme, a run-of-the-mill project involving less than three persons may be able to manage just fine with some loosely structured files shared on a central server. However, there are a few inherent forces that apply to any situation.</p>
</div>
<div class="ulist">
<ul>
<li>
<p><em>Data is deceptive.</em> To understand an existing software system you must collect and interpret data and summarize it in a coherent view. There is usually more than one way to interpret data and when choosing between alternatives you will make assumptions that are not always backed up by concrete evidence. <em>Consequently, double-check your sources to make sure you build your understanding on a solid foundation.</em></p>
</li>
<li>
<p><em>Understanding entails iteration.</em> Understanding occurs inside the human brain, thus corresponds to a kind of learning process. Reverse engineering techniques must support the way our minds assimilate new ideas, hence be very flexible and allow for a lot of iteration and backtracking. <em>Consequently, plan for iteration and feedback loops in order to stimulate a learning process.</em></p>
</li>
<li>
<p><em>Knowledge must be shared.</em> Once you understand the system it is important to share this knowledge with your colleagues. Not only will it help them to do their job, it will also result in comments and feedback that may improve your understanding. <em>Therefore, put the map on the wall:</em> publish your discoveries in a highly visible place and make explicit provisions for feedback. How to do this will depend on the team organization and working habits. Team meetings in general are a good way to publish information (see Speak to the Round Table [p. 24]), but a large drawing on the wall near the coffee machine may serve just as well.</p>
</li>
<li>
<p><em>Teams need to communicate.</em> Building and documenting your understanding of a system is not a goal; it is a means to achieve a goal. The real goal of understanding the system is to communicate effectively with the other persons involved in the project, thus the way you document your understanding must support that goal. There is for instance no point in drawing UML class diagrams if your colleagues only know how to read ER-diagrams; there is no point in writing use cases if your end users canât understand their scope. <em>Consequently, use their language:</em> choose the language for documenting your understanding so that your team members can read, understand and comment on what you have documented.</p>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="overview-2"><a class="anchor" href="#overview-2"></a>Overview</h3>
<div class="paragraph">
<p>When developing your initial understanding of a software system, incorrect information is your biggest concern. Therefore these patterns rely mainly on source-code because this is the only trustworthy information source.</p>
</div>
<div class="paragraph">
<p>In principle, there are two approaches for studying source-code: one is top-down, the other is bottom-up. In practice, every reverse engineering approach must incorporate a little bit of both, still it is worthwhile to make the distinction. With the top-down approach, you start from a high-level representation and verify it against the source-code (as for instance described in Speculate about Design). In the bottom-up approach, you start from the source-code, filter out whatâs relevant and cast the relevant entities into a higher-level representation. This is the approach used in Analyze the Persistent Data and Study the Exceptional Entities.</p>
</div>
<div class="paragraph">
<p>There is no preferred order in which to apply each of these patterns. It may be natural to first Analyze the Persistent Data, then refine the resulting model via Speculate about Design and finally exploit this knowledge to Study the Exceptional Entities. Therefore the patterns are presented in that order. However, large parts of your system wonât have anything to do with a database (some systems lack any form of persistent data) and then Speculate about Design must be done without having studied the database. And when you lack the inspiration to start with Speculate about Design, then Study the Exceptional Entities will surely provide you with an initial hypothesis.</p>
</div>
<div class="paragraph">
<p>The amount of time you should devote to each of these patterns depends largely on the goal of your reengineering project. In principle, none of these patterns will take long, but each of them should be applied several times. You cannot predict how many cycles will be necessary, because the assessment whether your team understands enough to proceed with the rest of the project can only be done after the patterns have been applied.</p>
</div>
<div class="paragraph">
<p>Therefore, these patterns must be applied on a case-by-case basis.</p>
</div>
<div class="paragraph">
<p><span class="image"><img src="./media/image7.jpg" alt="image" width="432" height="269"></span></p>
</div>
<div class="paragraph">
<p>Figure 4.1: Obtain an Initial Understanding of a software system and cast it into a higher-level representation.</p>
</div>
</div>
<div class="sect2">
<h3 id="what-next-6"><a class="anchor" href="#what-next-6"></a>What Next</h3>
<div class="paragraph">
<p>You should make sure to reflect your increased understanding in the project plan. For instance, Analyze the Persistent Data and Speculate about Design will document parts of the system, and this documentation must be added to the Opportunities. On the other hand, Study the Exceptional Entities will reveal some suspicious components and these must be added to the Risks.</p>
</div>
<div class="paragraph">
<p>Once you have obtained a solid foundation for your understanding, you should fill in the details for those components that are important for the rest of your project. Activities described in Detailed Model Capture [p. 105] may help you to fill in those details.</p>
</div>
</div>
<div class="sect2">
<h3 id="analyze-the-persistent-data"><a class="anchor" href="#analyze-the-persistent-data"></a>4.1 Analyze the Persistent Data</h3>
<div class="paragraph">
<p><strong>Intent</strong> <em>Learn about objects that are so valuable they must be kept inside a database system.</em></p>
</div>
<div class="sect3">
<h4 id="problem-5"><a class="anchor" href="#problem-5"></a>Problem</h4>
<div class="paragraph">
<p>Which object structures represent the valuable data?</p>
</div>
<div class="paragraph">
<p><em>This problem is difficult because:</em></p>
</div>
<div class="ulist">
<ul>
<li>
<p>Valuable data must be kept safe on some external storage device (<em>i.e.</em>, a file system, a database). However, such data stores often act as an attic: they are rarely cleaned up and may contain lots of junk.</p>
</li>
<li>
<p>When loaded in memory, the valuable data is represented by complex object structures. Unfortunately there lies a big gap between the data structures provided by external storage devices and the object structures living in main memory. Inheritance relationships for instance are seldom explicitly provided in a legacy database.</p>
</li>
<li>
<p>âValuableâ is a relative property. It is possible that large parts of the saved data are irrelevant for your reengineering project.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p><em>Yet, solving this problem is feasible because:</em></p>
</div>
<div class="ulist">
<ul>
<li>
<p>The software system employs some form of a database to make its data persistent. Thus there exists some form of database schema providing a static description of the data inside the database.</p>
</li>
<li>
<p>The database comes with the necessary tools to inspect the actual objects inside the database, so you can exploit the presence of legacy data to fine-tune your findings.</p>
</li>
<li>
<p>You have some expertise with mapping data-structures from your implementation language onto a database schema, enough to reconstruct a class diagram from the database schema.</p>
</li>
<li>
<p>You have a rough understanding of the systemâs functionality and the goals of your project (for example obtained via First Contact), so you can assess which parts of the database are valuable for your project.</p>
</li>
</ul>
</div>
</div>
<div class="sect3">
<h4 id="solution-5"><a class="anchor" href="#solution-5"></a>Solution</h4>
<div class="paragraph">
<p>Analyze the database schema and filter out which structures represent valuable data. Derive a class diagram representing those entities to document that knowledge for the rest of the team.</p>
</div>
<div class="sect4">
<h5 id="steps"><a class="anchor" href="#steps"></a>Steps</h5>
<div class="paragraph">
<p>The steps below assume that the system makes use of a <em>relational database</em>, which is commonly the case for object-oriented applications. However, in case youâre confronted with another kind of database system, many of these steps may still be applicable. The steps themselves are guidelines only: they must be applied iteratively, with liberal doses of intuition and backtracking.</p>
</div>
<div class="paragraph">
<p><em>Preparation.</em> To derive a class diagram from a relational database schema, first prepare an initial model representing the tables as classes. You may do this by means of a software tool, but a set of index cards may serve just as well.</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>Enumerate all table names and for each one, create a class with the same name.</p>
</li>
<li>
<p>For each table, collect all column names and add these as attributes to the corresponding class.</p>
</li>
<li>
<p>For each table, determine candidate keys. Some of them may be read directly from the database schema, but usually a more detailed analysis is required. Certainly check all (unique) indexes as they often suggest candidate keys. Naming conventions (names including ID or #) may also indicate candidate keys. In case of doubt, collect data samples and verify whether the candidate key is indeed unique within the database population.</p>
</li>
<li>
<p>Collect all foreign keys relationships between tables and create an association between the corresponding classes. Foreign key relationships may not be maintained explicitly in the database schema and then you must infer these from column types and naming conventions. Careful analysis is required here, as homonyms (= identical column name and type, yet different semantics) and synonyms (= different column name or type, yet identical semantics) may exist. To cope with such difficulties, at least verify the indexes and view declarations as these point to frequent traversal paths. If possible, verify the join clauses in the SQL statements executed against the database. Finally, confirm or refute certain foreign key relationships by inspecting data samples.</p>
</li>
</ol>
</div>
<div class="paragraph">
<p><em>Incorporate inheritance.</em> After the above steps, you will have a set of classes that represents the tables being stored in the relational database. How-</p>
</div>
<div class="paragraph">
<p>Figure 4.2: Mapping a series of relational tables onto an inheritance hierarchy. (a) one to one; (b) rolled down; (c) rolled up</p>
</div>
<div class="paragraph">
<p>ever, because relational databases cannot represent inheritance relationships, you have to infer these from the foreign keys. (The terminology for the three representations of inheritance relations in steps 5-7 stems from [Fro94].)</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p><em>One to one</em> (Figure 4.2 (a)). Check tables where the primary key also serves as a foreign key to another table, as such foreign keys may represent inheritance relationships. Examine the SELECT statements that are executed against these tables to see whether they usually involve a join over this foreign key. If this is the case, analyze the table names and the corresponding source code to verify whether this foreign key indeed represents an inheritance relationship. If it does, transform the association that corresponds with the foreign key into an inheritance relationship.</p>
</li>
<li>
<p><em>Rolled down</em> (Figure 4.2 (b)). Check tables with common sets of column definitions, as these probably indicate a situation where the class hierarchy is spread over several tables, each table representing one non-abstract class. Define a common superclass for each cluster of duplicated column definitions and move the corresponding attributes inside the new class. Check the source code for the name applicable for the newly created classes.</p>
</li>
<li>
<p><em>Rolled up</em> (Figure 4.2 (c)). Check tables with many columns and lots of optional attributes as these may indicate a situation where a complete class hierarchy is represented in a single table. If you have found such a table, examine all the SELECT statements that are executed against this table. If these SELECT statements explicitly request for subsets of the columns, then you may break this one class into several classes depending on the subsets requested. For the names of these classes, check for an encoding of subtype information like for instance a âkindâ column holding an enumeration type number.</p>
</li>
</ol>
</div>
<div class="paragraph">
<p><em>Incorporate associations.</em> Note that the class diagram extracted from the database may be too small: it is possible that classes in the actual inheritance hierarchy have been omitted in the database because they did not define any new attributes. Also, table- and column-names may sound bizarre. Therefore, consider to verify the class diagram against the source code (see Speculate about Design) as this may provide extra insight. Afterwards, refine the remaining associations.</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>Determinate association classes, <em>i.e.</em>, classes that represent the fact that two objects are associated. The most common example is a many-to-many association, which is represented by a table having a candidate key consisting of two foreign keys. In general, all tables where the candidate keys are concatenations of multiple foreign keys are potential cases of an association class.</p>
</li>
<li>
<p>Merge complementary associations. Sometimes a class A will have a foreign key association to class B and class B an inverse foreign key to class A. In that case, merge the two associations into a single association navigable in both directions.</p>
</li>
<li>
<p>Resolve foreign key targets. When inheritance hierarchies have been rolled up or down in the database, foreign key targets may become ambiguous after the table has been decomposed in its constituting classes. Foreign key targets may be too high or too low in the hierarchy, in which case the corresponding association will have too little or too many participating classes. Resolving such situation typically requires analyzing data-samples and SQL statements to see which classes actually participate in the association.</p>
</li>
<li>
<p>Identify qualified associations, <em>i.e.</em>, associations that can be navigated by providing a certain look-up key (the qualifier). Common examples are ordered one-to-many associations, where the ordering number serves as the qualifier. In general, all tables where the candidate key combines a foreign key with extra columns are potential qualified associations; the extra columns then represent the qualifier.</p>
</li>
<li>
<p>Note multiplicities for the associations. Since all associations are derived from foreign key relationships, all associations are by construction optional 1-to-many associations. However, by inspecting nonnull declarations, indices and data samples one can often determine the minimum and maximum multiplicities for each of the roles in the association.
<em>Verification.</em> Note the recurring remark that the database schema alone is too weak as a basis to derive a complete class diagram. Fortunately, a legacy system has a populated database and programs manipulating that database. Hence, data samples and embedded SQL statements can be used to verify the reconstructed classes.</p>
<div class="ulist">
<ul>
<li>
<p><em>Data samples.</em> Database schemas only specify the constraints allowed by the underlying database system and model. However, the problem domain may involve other constraints not expressed in the schema. By inspecting samples of the actual data stored in the database you can infer other constraints.</p>
</li>
<li>
<p><em>SQL statements.</em> Tables in a relational database schema are linked via foreign keys. However, it is sometimes the case that some tables are always accessed together, even if there is no explicit foreign key. Therefore, it is a good idea to check which queries are actually executed against the database engine. One way to do this is to extract all embedded SQL statements in the program. Another way is to analyze all executed queries via the tracing facilities provided with the database system.</p>
</li>
</ul>
</div>
</li>
</ol>
</div>
<div class="paragraph">
<p><em>Incorporate operations.</em> It should be clear that the class diagram you extract from a database will only represent the data-structure, not the operations used to manipulate those structures. As such, the resulting class diagram is necessarily incomplete. By comparing the code with the model extracted from the database (see Speculate about Design and Look for the Contracts [p. 123]) it is possible to incorporate the operations for the extracted classes.</p>
</div>
</div>
</div>
<div class="sect3">
<h4 id="tradeoffs-5"><a class="anchor" href="#tradeoffs-5"></a>Tradeoffs</h4>
<div class="sect4">
<h5 id="pros-5"><a class="anchor" href="#pros-5"></a>Pros</h5>
<div class="ulist">
<ul>
<li>
<p><em>Improves team communication.</em> By capturing the database schema you will improve the communication within the reengineering team and with other developers associated with the project (in particular the maintenance team). Moreover, many if not all of the people associated with the project will be reassured by the fact that the data schema is present, because lots of development methodologies stress the importance of the database design.</p>
</li>
<li>
<p><em>Focus on valuable data.</em> A database provides special features for backup and security and is therefore the ideal place to store the valuable data. Once you understand the database schema it is possible to extract the valuable data and preserve it during future reengineering activities.</p>
</li>
</ul>
</div>
</div>
<div class="sect4">
<h5 id="cons-5"><a class="anchor" href="#cons-5"></a>Cons</h5>
<div class="ulist">
<ul>
<li>
<p><em>Has limited scope.</em> Although the database is crucial in many of todayâs software systems, it involves but a fraction of the complete system. As such, you cannot rely on this pattern alone to gain a complete view of the system.</p>
</li>
<li>
<p><em>Junk data.</em> A database will contain a lot more than the valuable data and depending on how old the legacy system is a lot of junk data may be stored just because nobody did care to remove it. <em>Therefore, you must match the database schema you recovered against the needs of your reengineering project.</em></p>
</li>
<li>
<p><em>Requires database expertise.</em> The pattern requires a good deal of knowledge about the underlying database plus structures to map the database schema into the implementation language. As such, the pattern should preferably be applied by people having expertise in mappings from the chosen database to the implementation language.</p>
</li>
<li>
<p><em>Lacks behavior.</em> The class diagram you extract from a database is very data-oriented and includes little or no behavior. A truly objectoriented class diagram should encapsulate both data and behavior, so in that sense the database schema shows only half of the picture. However, once the database model exists, it is possible to add the missing behavior later.</p>
</li>
</ul>
</div>
</div>
<div class="sect4">
<h5 id="difficulties-5"><a class="anchor" href="#difficulties-5"></a>Difficulties</h5>
<div class="ulist">
<ul>
<li>
<p><em>Polluted database schema.</em> The database schema itself is not always the best source of information to reconstruct a class diagram for the valuable objects. Many projects must optimize database access and as such often sacrifice a clean database schema. Also, the database schema itself evolves over time, and as such will slowly deteriorate. _Therefore, it is quite important to refine the class diagram via analysis of data samples and embedded SQL statements.</p>
</li>
</ul>
</div>
</div>
</div>
<div class="sect3">
<h4 id="example-5"><a class="anchor" href="#example-5"></a>Example</h4>
<div class="paragraph">
<p>While taking over <em>XDoctor</em>, your company has promised to continue to support the existing customer base. In particular, you have guaranteed customers that they wonât lose a single byte of data, and now your boss asks you to recover the database structure. From the experience with your own product, you know that doctors care a lot about their patient files and that it is unacceptable to lose such information. Therefore you decide that you will start by analyzing the way patient files are stored inside the database.</p>
</div>
<div class="paragraph">
<p>You start by browsing all table names looking for a table named Patient, but unfortunately you donât find one. However, there is a close match in a table named Person, where column names like insuranceID suggest that at least some patient information is stored. Nevertheless, many column names are optional, so you suspect a rolled up representation where</p>
</div>
<div class="paragraph">
<p>Figure 4.3: Identify a qualified association via a key consisting of a foreign key (patientID) and two extra columns (date, nr). patient information is mixed with information from other kinds of persons. Therefore, you check the source-code and look for all embedded SQL statements querying the table Person (<em>i.e.</em>,grep "SELECT * Person"). Indeed, there are two classes where such a query is used, namely Patient and Salesman and from the subsets of columns queried in each class, you infer the inheritance hierarchy depicted in Figure 4.2.</p>
</div>
<div class="paragraph">
<p>Now that you recovered the Patient, you start looking for the table that stores the treatments a patient received. And indeed there is a table Treatment which has a foreign key to the table Person. However, since you have decomposed Person into the classes Patient and Salesman, it is necessary to resolve the target of the foreign key. You join the tables Person and Treatment over patientID (SELECT DISTINCT name, kind FROM Person, Treatment WHERE Person.id = Treatment.patientID) and see that all selected persons indeed have a kind which corresponds to a Patient. Therefore, you set the target of the foreign key leaving from Treatment to</p>
</div>
<div class="paragraph">
<p>Patient (see left side of Figure 4.2). Next, you verify the indices defined on Treatment and notice that there is a unique index on the columns patientID - date - nr, which makes you conclude that these columns serve as a candidate key. Since the candidate key on Treatment consists of a foreign key combined with two extra columns, you suspect a qualified association. To confirm this assumption you analyze a data sample (SELECT name, date, nr FROM Person, Treatment WHERE Person.id = Treatment.patientID ORDER BY name, date, nr) and see that the date and the number uniquely identify a treatment for a given patient. As a consequence, you transform the foreign key into a qualified association had-treatment with a multiplicity of one on each role.</p>
</div>
</div>
<div class="sect3">
<h4 id="rationale-4"><a class="anchor" href="#rationale-4"></a>Rationale</h4>
<div class="paragraph">
<p><em>The object model is important for database applications because it concisely describes data structure and captures structural constraints.
â Michael Blaha, et al. [BLM98]</em></p>
</div>
<div class="paragraph">
<p>Having a well-defined central database schema is a common practice in larger software projects that deal with persistent data. Not only does it specify common rules on how to access certain data structures, it is also a great aid in dividing the work between team members. Therefore, it is a good idea to extract an accurate model of the database before proceeding with other reverse engineering activities.</p>
</div>
<div class="paragraph">
<p>Note that extracting a database model is essentially a bottom-up approach: you start from the rough information contained in the database schema and you polish it up until you have a satisfactory class diagram. A bottom up approach works quite well in such a situation, because a database schema is already an abstraction from a more detailed representation.</p>
</div>
<div class="paragraph">
<p><em>All data should be hidden within its class.
â Arthur Riel, Heuristic 2.1 [Rie96]</em></p>
</div>
<div class="paragraph">
<p>Information hiding is an important design principle, and most authors agree that for a class this implies that all data should be encapsulated within the class and only accessed via the operations defined on that class. Unfortunately, the class diagram you extract from a database will expose all of its data, because thatâs the nature of a database. Therefore, this class diagram is just a first step towards a well-designed interface to the database.</p>
</div>
</div>
<div class="sect3">
<h4 id="known-uses-5"><a class="anchor" href="#known-uses-5"></a>Known Uses</h4>
<div class="paragraph">
<p>The reverse engineering and reengineering of database systems is a well explored area of research [Arn92] [MJS+00]. Several experiments indicate that it is feasible to recover the database structure, even for these database systems that are poorly designed. [PB94] for instance reports about an experiment concerning the reverse engineering of a data dictionary of a leading RDBMS vendor, as well as a production database storing data about mechanical parts. [HEH+96] describes a prototype database reverse engineering toolkit, as well as five industrial cases where the toolkit has been applied. To illustrate the unpredictable nature of database reverse engineering, [JSZ97] reports on the use of a fuzzy reasoning engine as the core of a tool that extracts class diagrams out of relational database schemas.</p>
</div>
</div>
<div class="sect3">
<h4 id="what-next-7"><a class="anchor" href="#what-next-7"></a>What Next</h4>
<div class="paragraph">
<p>Analyze the Persistent Data results in a class diagram for the persistent data in your software system. Such a class diagram is quite rough and is mainly concerned with the structure of the data and not with its behavior. However, it may serve as an ideal initial hypothesis to be further refined by applying Speculate about Design and Look for the Contracts [p. 123].</p>
</div>
<div class="paragraph">
<p>If you need to migrate to another database, you should cast your understanding of the database model in a test suite as explained in Tests: Your Life Insurance! [p. 135].</p>
</div>
<div class="paragraph">
<p>Note that there exist patterns, idioms and pattern languages that describe various ways to map object-oriented data structures on relational database counterparts [BW96] [KC98b]. Consulting these may help you when you are reverse engineering a database schema.</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="speculate-about-design"><a class="anchor" href="#speculate-about-design"></a>4.2 Speculate about Design</h3>
<div class="paragraph">
<p><strong>Intent</strong> <em>Progressively refine a design against source code by checking hypotheses about the design against the source code.</em></p>
</div>
<div class="sect3">
<h4 id="problem-6"><a class="anchor" href="#problem-6"></a>Problem</h4>
<div class="paragraph">
<p>How do you recover the way design concepts are represented in the source-code?</p>
</div>
<div class="paragraph">
<p><em>This problem is difficult because:</em></p>
</div>
<div class="ulist">
<ul>
<li>
<p>There are many design concepts and there are countless ways to represent them in the programming language used.</p>
</li>
<li>
<p>Much of the source-code wonât have anything to do with the design but rather with implementation issues (glue code, user-interface control, database connections,-).</p>
</li>
</ul>
</div>
<div class="paragraph">
<p><em>Yet, solving this problem is feasible because:</em></p>
</div>
<div class="ulist">
<ul>
<li>
<p>You have a <em>rough understanding</em> of the systemâs functionality (for example obtained via Skim the Documentation [p. 52] and Interview During Demo [p. 59]), and you therefore have an initial idea which design issues should be addressed.</p>
</li>
<li>
<p>You have <em>development expertise</em>, so you can imagine how you would design the problem yourself.</p>
</li>
<li>
<p>You are <em>somewhat familiar</em> with the main structure of the source code (for example obtained by Read all the Code in One Hour [p. 45]) so that you can find your way around.</p>
</li>
</ul>
</div>
</div>
<div class="sect3">
<h4 id="solution-6"><a class="anchor" href="#solution-6"></a>Solution</h4>
<div class="paragraph">
<p>Use your development expertise to conceive a hypothetical class diagram representing the design. Refine that model by verifying whether the names in the class diagram occur in the source code and by adapting the model accordingly. Repeat the process until your class diagram stabilizes.</p>
</div>
<div class="sect4">
<h5 id="steps-1"><a class="anchor" href="#steps-1"></a>Steps</h5>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>With your understanding of the system, develop a class diagram that serves as your initial hypothesis of what to expect in the source code. For the names of the classes, operations and attributes make a guess based on your experience and potential naming conventions (see Skim the Documentation [p. 52]).</p>
</li>
<li>
<p>Enumerate the names in the class diagram (that is, names of classes, attributes and operations) and try to find them in the source code, using whatever tools you have available. Take care as names inside the source-code do not always match with the concepts they represent.<sup class="footnote">[<a id="_footnoteref_2" class="footnote" href="#_footnote_2" title="View footnote.">2</a>]</sup> To counter this effect, you may rank the names according to the likelihood that they appear in the source code.</p>
</li>
<li>
<p>Keep track of the names that appear in source code (confirm your hypothesis) and the names which do not match with identifiers in the source code (contradict your hypothesis). Remember that mismatches are positive, as these will trigger the learning process that you must go through when understanding the system.</p>
</li>
<li>
<p>Adapt the class diagram based on the mismatches. Such adaptation may involve</p>
<div class="olist loweralpha">
<ol class="loweralpha" type="a">
<li>
<p><em>renaming</em>, when you discover that the names chosen in the source code do not match with your hypothesis;</p>
</li>
<li>
<p><em>remodelling</em>, when you find out that the source-code representation of the design concept does not correspond with what you have in your model. For instance, you may transform an operation into a class, or an attribute into an operation.</p>
</li>
<li>
<p><em>extending</em>, when you detect important elements in the source-code that do not appear in your class diagram;</p>
</li>
<li>
<p><em>seeking alternatives</em>, when you do not find the design concept in the source- code. This may entail trying synonyms when there are few mismatches but may also entail defining a completely different class diagram when there are lots of mismatches.</p>
</li>
</ol>
</div>
</li>
<li>
<p>Repeat steps 2-4 until you obtain a class diagram that is satisfactory.</p>
</li>
</ol>
</div>
</div>
<div class="sect4">
<h5 id="variants-1"><a class="anchor" href="#variants-1"></a>Variants</h5>
<div class="paragraph">
<p><em>Speculate about Business Objects.</em> A crucial part of the system design is the way concepts of the problem domain are represented as classes in the source code. You can use a variant of this pattern to extract those so-called âbusiness objectsâ.</p>
</div>
<div class="paragraph">
<p>One way to build an initial hypothesis is to use the noun phrases in the requirements as the initial class names and the verb phrases as the initial method names (See [WBWW90] [BS97] [Boo94] for in-depth treatments of finding classes and their responsibilities).You should probably augment this information via the usage scenarios that you get out of Interview During Demo [p. 59] which may help you to find out which objects fulfil which roles. (See [JCJO92] [SW98] for scenarios and use cases and [Ree96] [RG98] for role modeling.)</p>
</div>
<div class="paragraph">
<p><em>Speculate about Patterns.</em> Patterns are ârecurring solutions to a common design problem in a given contextâ. Once you know where a certain pattern has been applied, it reveals a lot about the underlying system design. This variant verifies a hypothesis about occurrences of architectural [BMR<sup>+</sup>96], analysis [Fow97] or design patterns [GHJV95].</p>
</div>
<div class="paragraph">
<p><em>Speculate about Architecture.</em> âA software architecture is a description of the subsystem and components of a software system and the relationships between themâ [BMR<sup>+</sup>96] (a.k.a. Components and Connectors [SG96]). The software architecture is typically associated with the coarse level design of a system and as such it is crucial in understanding the overall structure. Software architecture is especially relevant in the context of a distributed system with multiple cooperating processes, an area where reverse engineering is quite difficult.</p>
</div>
<div class="paragraph">
<p>This variant builds and refines a hypothesis about which components and connectors exist, or in the context of a distributed system, which processes exist, how they are launched, how they get terminated and how they interact. Consult [BMR+96] for a catalogue of architectural patterns and [SG96] for a list of well-known architectural styles. See [Lea96] for some typical patterns and idioms that may be applied in concurrent programming and [SSRB00] for architectural patterns in distributed systems.</p>
</div>
</div>
</div>
<div class="sect3">
<h4 id="tradeoffs-6"><a class="anchor" href="#tradeoffs-6"></a>Tradeoffs</h4>
<div class="sect4">
<h5 id="pros-6"><a class="anchor" href="#pros-6"></a>Pros</h5>
<div class="ulist">
<ul>
<li>
<p><em>Scales well.</em> Speculating about what youâll find in the source code is a technique that scales up well. This is especially important because for large object-oriented programs (over a 100 classes) a bottom-up approach quickly becomes impractical.</p>
</li>
<li>
<p><em>Investment pays off.</em> The technique is quite cheap in terms of resources and tools, definitely when considering the amount of understanding one obtains.</p>
</li>
</ul>
</div>
</div>
<div class="sect4">
<h5 id="cons-6"><a class="anchor" href="#cons-6"></a>Cons</h5>
<div class="ulist">
<ul>
<li>
<p><em>Requires expertise.</em> A large repertoire of knowledge about idioms, patterns, algorithms, techniques is necessary to recognize what you see in the source code. As such, the pattern should preferably be applied by experts.</p>
</li>
<li>
<p><em>Consumes much time.</em> Although the technique is quite cheap in terms of resources and tools, it requires a substantial amount of time before one derives a satisfactory representation.</p>
</li>
</ul>
</div>
</div>
<div class="sect4">
<h5 id="difficulties-6"><a class="anchor" href="#difficulties-6"></a>Difficulties</h5>
<div class="ulist">
<ul>
<li>
<p><em>Maintain consistency.</em> You should plan to keep the class diagram up to date while your reverse engineering project progresses and your understanding of the software system grows. Otherwise your efforts will be wasted. Therefore, make sure that your class diagram relies heavily on the naming conventions used in the source-code and that the class diagram is under the control of the configuration management system.</p>
</li>
</ul>
</div>
</div>
</div>
<div class="sect3">
<h4 id="example-6"><a class="anchor" href="#example-6"></a>Example</h4>
<div class="paragraph">
<p>While taking over <em>XDoctor</em>, your company has promised to continue to support the existing customer base. And since Switzerland will be joining the Euro-region within six months, the marketing department wants to make sure that Euro conversions will be supported properly. A first evaluation has revealed that the Euro is supported to some degree (<em>i.e.</em>, it was described in the user manual and there exists a class named Currency). Now, your boss asks you to investigate whether they can meet the legal obligations, and if not, how long it will take to adapt the software.</p>
</div>
<div class="paragraph">
<p>From a previous code review, you learned that the design is reasonably good, so you suspect that the designers have applied some variant of the Quantity [p. 294] pattern. Therefore, you define an initial hypothesis in the form of the class diagram depicted in Figure 4.4 (a). There is one class Money holding two attributes; one for the amount of money (a floating point number) and one for the currency being used (an instance of the Currency class). You assume operations on the Money class to perform the standard calculations like addition, substraction, multiplication, Â·Â·Â· plus one operation for converting to another currency. Currency should have subclasses for every currency supported and then operations to support the conversion from one currency into another. Of course, some questions are left unanswered and you note them down on your class diagram.</p>
</div>
<div class="olist loweralpha">
<ol class="loweralpha" type="a">
<li>
<p>Initial hypothesis where the open questions are inserted as Notes</p>
</li>
</ol>
</div>
<div class="paragraph">
<p><span class="image"><img src="./media/image8.jpg" alt="image" width="432" height="145"></span></p>
</div>
<div class="olist loweralpha">
<ol class="loweralpha" type="a">
<li>
<p>Refined hypothesis after verification against the source code; the modificationsare shown as Notes</p>
</li>
</ol>
</div>
<div class="paragraph">
<p><span class="image"><img src="./media/image9.jpg" alt="image" width="432" height="159"></span></p>
</div>
<div class="paragraph">
<p>Figure 4.4: Refining the hypotheses concerning the Euro representation. (a) subclasses for the different currencies; (b) flyweight approach for the currencies</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>What is the precision for an amount of Money?</p>
</li>
<li>
<p>Which calculations are allowed on an instance of Money?</p>
</li>
<li>
<p>How do you convert an instance of Money into another currency?</p>
</li>
<li>
<p>How is this conversion done internally? How is the support from the Currency class?</p>
</li>
<li>
<p>Which are the currencies supported?</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>To answer these questions you verify your hypothesis against the source code and you adapt your class diagram accordingly. A quick glance at the filenames reveals a class Currency but no class named Money; a grep-search on all of the source code confirms that no class Money exists. Browsing which packages import Currency, you quickly find out that the actual name in the source code is Price and you rename the Money class accordingly.</p>
</div>
<div class="paragraph">
<p>Looking inside the Price class reveals that the amount of money is represented as a fixed point number. There is a little comment-line stating:</p>
</div>
<div class="paragraph">
<p>Michael (Oct 1999) ---- Bug Report #324 ---- Replaced Float by BigDecimal due to rounding errors in the floating point representation. Trimmed down the permitted calculation operations as well.</p>
</div>
<div class="paragraph">
<p>Checking the interface of the Price class you see that the calculation operations are indeed quite minimal. Only addition and negation (apparently substraction must be done via an addition with a negated operand) and some extra operations to take percentages and multiply with other numbers. However, you also spot a convert operation which confirms your hypothesis concerning the conversion of prices.</p>
</div>
<div class="paragraph">
<p>Next you look for subclasses of Currency, but you donât seem to find any. Puzzled, you start thinking about alternative solutions and after a while you consider the possibility of a Flyweight [p. 294]. After all, having a separate subclass for each currency is a bit of an overhead because no extra behavior is involved. Moreover, with the flyweight approach you can save a lot of memory by representing all occurrences of the Euro-currency with a single Euro-object. To verify this alternative, you look for all occurrences of constructor methods for Currency â a grep Currency does the trick â and you actually discover a class Currencies which encapsulates a global table containing all currencies accepted. Looking at the initialize method, you learn that the actual table contains entries for two currencies:</p>
</div>
<div class="paragraph">
<p>Euro and Belgian Francs.</p>
</div>
<div class="paragraph">
<p>Finally, you study the actual conversion in a bit more detail by looking at the Price.convert operation and the contents of the Currency class. After some browsing, you discover that each Currency has a single conversion factor. This makes you wonder: isnât conversion supposed to work in two ways and between all possible currencies? But then you check all invocations of the conversionFactor method and you deduce that the conversion is designed around the notion of a default currency (<em>i.e.</em>, the Currencies.default() operation) and that the conversionFactor is the one that converts the given currency to the default one. Checking the Price.convert operation, you see that there is indeed a test for default currency in which case the conversion corresponds to a simple multiplication. In the other case, the conversion is done via a two step calculation involving an intermediate conversion to the default currency.</p>
</div>
<div class="paragraph">
<p>Youâre quite happy with your findings and you adapt your class diagram to the one depicted in figure 10(b). That model is annotated with the modifications you made to the original hypothesis, thus you store both the original and refined model into the configuration management system so that your colleagues can reconstruct your deduction process. You also file the following report summarizing your findings.</p>
</div>
<div class="paragraph">
<p><em>Conversion to Euro.</em> Facilities for Euro conversion are available, but extra work is required. One central class (Currencies) maintains a list of supported currencies including one default currency (Currencies.default). To convert to Euro, the initialization of this class must be changed so that the default becomes Euro. All prices stored in the database must also be converted, but this is outside the scope of my study.</p>
</div>
<div class="paragraph">
<p>Follow-up actions:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Adapt initialization of class Currencies so that it reads the default currency and conversion factors from the configuration file.</p>
</li>
<li>
<p>Check the database to see how Prices should be converted.</p>
</li>
</ul>
</div>
</div>
<div class="sect3">
<h4 id="rationale-5"><a class="anchor" href="#rationale-5"></a>Rationale</h4>
<div class="paragraph">
<p>The naive approach to design extraction is bottom-up: first build a complete class diagram from source code and afterwards condense it by removing the noise. Unfortunately, the bottom-up approach does not work for large scale systems, because one typically gets a lot of white noise to start from (see for example Figure 4.5, showing an inheritance hierarchy with associations for a medium-sized system). Moreover, such a bottomup approach does not improve your understanding very much, because it forces you to focus on the irrelevant noise instead of the important concepts.</p>
</div>
<div class="paragraph">
<p><span class="image"><img src="./media/image10.png" alt="image" width="426" height="204"></span></p>
</div>
<div class="paragraph">
<p>Figure 4.5: White-noise obtained by a bottom-up design extraction approach.</p>
</div>
<div class="paragraph">
<p>The figure shows a fragment of an inheritance hierarchy augmented with all method invocations and attribute accesses for a medium sized system. The visualization is performed by CodeCrawler [DDL99] [Lan99].</p>
</div>
<div class="paragraph">
<p><em>âWe get things wrong before we get things right.â
â Alistair Cockburn, [Coc93]</em></p>
</div>
<div class="paragraph">
<p>In order to gain a true understanding of the legacy problem, you must go through a learning process. Speculate about Design is intended to stimulate such a learning process and therefore evidence that contradicts your hypothesis is as valuable as evidence that confirms it. Indeed, mismatches force you to consider alternative solutions and assess their pros and cons, and that is the moment when true understanding emerges.</p>
</div>
</div>
<div class="sect3">
<h4 id="known-uses-6"><a class="anchor" href="#known-uses-6"></a>Known Uses</h4>
<div class="paragraph">
<p>In [MN97], there is a report of an experiment where a software engineer at Microsoft applied this pattern (it is called âthe Reflection Modelâ in the paper) to reverse engineer the C-code of Microsoft Excel. One of the nice sides of the story is that the software engineer was a newcomer to that part of the system and that his colleagues could not spend too much time to explain it to him. Yet, after a brief discussion he could come up with an initial hypothesis and then use the source code to gradually refine his understanding. Note that the paper also includes a description of a lightweight tool to help specifying the model, the mapping from the model to the source code and the checking of the code against the model.</p>
</div>
<div class="paragraph">
<p>The articles [Big89] [BMW93] [BMW94], report several successful uses of this pattern (there it is called the âconcept assignment problemâ). In particular, the authors describe a tool-prototype named DESIRE, which includes advanced browsing facilities, program slicing and a Prolog-based query language. The tool has been used by a number of people in different companies to analyze programs of up to 220 KLOC. Other well- known applications are reported by the Rigi group, which among others have applied this pattern on a system consisting of over 2 million lines of PL/AS code [WTMS95].</p>
</div>
<div class="paragraph">
<p>It has been shown that such an approach can be used to map an object-oriented design onto a procedural implementation purely based on a static analysis of the source-code [GW99] [WG98]. Nevertheless, newer approaches try to exploit richer and more diverse information sources. DALI for instance also analyses information from makefiles and profilers [BCK98] [KC98a] [KC99]. Gaudi on the other hand, verifies the hypothesis against a mixture of the static call graphs with run-time traces [RD99].</p>
</div>
</div>
<div class="sect3">
<h4 id="what-next-8"><a class="anchor" href="#what-next-8"></a>What Next</h4>
<div class="paragraph">
<p>After this pattern, you will have a class diagram representing a part of the design. You may want to Study the Exceptional Entities to get an impression of the design quality. If you need a more refined model, consider the patterns in Detailed Model Capture [p. 105]. When your reverse engineering efforts are part of a migration or reengineer project, you should cast your understanding of design in a test suite as explained in Tests: Your Life Insurance! [p. 135]</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="study-the-exceptional-entities"><a class="anchor" href="#study-the-exceptional-entities"></a>4.3 Study the Exceptional Entities</h3>
<div class="paragraph">
<p><strong>Intent</strong> <em>Identify potential design problems by collecting measurements and studying the exceptional values.</em></p>
</div>
<div class="sect3">
<h4 id="problem-7"><a class="anchor" href="#problem-7"></a>Problem</h4>
<div class="paragraph">
<p>How can you quickly identify potential design problems in large software systems?</p>
</div>
<div class="paragraph">
<p><em>This problem is difficult because:</em></p>
</div>
<div class="ulist">
<ul>
<li>
<p>There is no easy way to discern problematic from good designs. Assessing the quality of a design must be done in the terms of the problem it tries to solve, thus can never be inferred from the design alone.</p>
</li>
<li>
<p>To confirm that a piece of code represents a design problem, you must first unravel its inner structure. With problematic code this is typically quite difficult.</p>
</li>
<li>
<p>The system is large, thus a detailed assessment of the design quality of every piece of code is not feasible.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p><em>Yet, solving this problem is feasible because:</em></p>
</div>
<div class="ulist">
<ul>
<li>
<p>You have a <em>metrics tool</em> at your disposal, so you can quickly collect a number of measurements about the entities in the source-code.</p>
</li>
<li>
<p>You have a <em>rough understanding</em> of the systemâs functionality (for example obtained via First Contact), so you can assess the quality of the design in the system context.</p>
</li>
<li>
<p>You have the necessary <em>tools to browse</em> the source-code, so you can verify manually whether certain entities are indeed a problem.</p>
</li>
</ul>
</div>
</div>
<div class="sect3">
<h4 id="solution-7"><a class="anchor" href="#solution-7"></a>Solution</h4>
<div class="paragraph">
<p>Measure the structural entities forming the software system (<em>i.e.</em>, the inheritance hierarchy, the packages, the classes and the methods) and look for exceptions in the quantitative data you collected. Verify manually whether these anomalies represent design problems.</p>
</div>
<div class="sect4">
<h5 id="hints-5"><a class="anchor" href="#hints-5"></a>Hints</h5>
<div class="paragraph">
<p>Identifying problematic designs in a software system via measurements is a delicate activity which requires expertise in both data collection and interpretation. Below are some hints you might consider to get the best out of the raw numbers.</p>
</div>
<div class="ulist">
<ul>
<li>
<p><em>Which tool to use?</em> There are many tools â commercial as well as public domain â which measure various attributes of source code entities. Nevertheless, few development teams make regular use of such tools and therefore it is likely that you will have to look for a metrics tool before applying this pattern.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>In principle, start by looking at the tools used by the development team and see whether they can be used to collect data about the code. For instance, a code verification tool such as lint can serve as basis for your measurements. Start looking for a metrics tool only when none of the development tools currently in use may collect data for you. If thatâs the case, simplicity should be your main tool adoption criterion as you do not want to spend your precious time on installing and learning. The second tool adoption criterion is how easy the metrics tool integrates with the other development tools in use.</p>
</div>
<div class="ulist">
<ul>
<li>
<p><em>Which metrics to collect?</em> In general, it is better to stick to the simple metrics, as the more complex ones involve more computation, yet will rarely perform better.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>For instance, to identify large methods it is sufficient to count the lines of code by counting all carriage returns or new-lines. Most other method size metrics require some form of parsing and this effort is usually not worth the gain.</p>
</div>
<div class="ulist">
<ul>
<li>
<p><em>Which metric variants to use?</em> Usually, it does not make a lot of difference which metric variant is chosen, as long as the choice is clearly stated and applied consistently. Here as well, it is preferable to choose the most simple variant, unless you have a good reason to do otherwise.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>For instance, while counting the lines of code, you should decide whether to include or exclude comment lines, or whether you count the lines after the source code has been normalized via pretty printing. However, when looking for potential design problems it usually does not pay off to do the extra effort of excluding comment lines or normalizing the source code.</p>
</div>
<div class="ulist">
<ul>
<li>
<p><em>Which thresholds to apply?</em> Due to the need for reliability, it is better <em>not</em>
to apply thresholds.<sup class="footnote">[<a id="_footnoteref_3" class="footnote" href="#_footnote_3" title="View footnote.">3</a>]</sup> First of all, because selecting threshold values must be done based on the coding standards applied in the development team and these you do not necessarily have access to. Second, thresholds will distort your perspective on the anomalies inside the system as you will not know how many normal entities there are.</p>
</li>
<li>
<p><em>How to interpret the results?</em> An anomaly is not necessarily problematic, so care must be taken when interpreting the measurement data. To assess whether an entity is indeed problematic, it is a good idea to simultaneously inspect different measurements for the same entity. For instance, do not limit yourself to the study of large classes, but combine the size of the class with the number of subclasses and the number of superclasses, because this says something about where the class is located in the class hierarchy.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>However, formulas that combine different measurements in a single number should be avoided as you loose the sense for the constituting elements. Therefore it is better to present the results in a table, where the first column shows the name of the entity, and the remaining columns show the different measurement data. Sorting these tables according to the different measurement columns will help you to identify exceptional values.</p>
</div>
<div class="ulist">
<ul>
<li>
<p><em>How to identify anomalies quickly?</em> Although it is possible to identify exceptional values in a tabular representations of measurement data, such an approach is tedious and error-prone. Most metric tools include some visualization features (histograms, scatter plots, Â·Â·Â·) to help you scan large volumes of measurements and this is usually a better way to quickly focus on potential design problems.</p>
</li>
<li>
<p><em>Should I browse the code afterwards?</em> Measurements alone cannot determine whether a entity is truly problematic: some human assessment is always necessary. Metrics are a great aid in quickly identifying entities that are potential problems but code browsing is necessary for confirmation. Note that large entities are usually quite complicated, thus understanding the corresponding source code may prove to be difficult.</p>
</li>
<li>
<p><em>What about normal entities?</em> Experienced programmers tend to distribute important functionality over a number of well- designed components. Conversely, exceptional entities are quite often irrelevant as truly important code would have been refactored. Therefore, you should be aware that you are only applying a heuristic: its possible that you are studying code which does not represent a design problem simply because it is deemed unimportant.</p>
</li>
</ul>
</div>
</div>
</div>
<div class="sect3">
<h4 id="tradeoffs-7"><a class="anchor" href="#tradeoffs-7"></a>Tradeoffs</h4>
<div class="sect4">
<h5 id="pros-7"><a class="anchor" href="#pros-7"></a>Pros</h5>
<div class="ulist">
<ul>
<li>
<p><em>Scales well.</em> Metrics are readily applicable to large scale systems, mainly because with metric tools about 20% of all the entities require further investigation. When different metrics are combined properly (preferably using some form of visualization) one can deduce quite rapidly which parts of the system represent potential design problems.</p>
</li>
<li>
<p><em>Overview mode is appealing.</em> With proper tool support you can produce visual representations of the metrics data that provide immediate insight into the good as well as the problematic parts of the design.</p>
</li>
</ul>
</div>
</div>
<div class="sect4">
<h5 id="cons-7"><a class="anchor" href="#cons-7"></a>Cons</h5>
<div class="ulist">
<ul>
<li>
<p><em>Results are inaccurate.</em> Some of the entities having exceptional measurements will turn out not to be problematic. Metrics are only a heuristic and false positives are likely to occur. Moreover, the metric may reveal problems that are not worth solving because the solutions will not contribute to your reengineering goal. Unfortunately, this you will only know after you analyzed the source code.</p>
</li>
<li>
<p><em>Missing priorities.</em> Identifying a potential problem is easy, the real difficult part is assessing the severity of the problem. Especially during a reengineering project, you identify far more problems than you have time to solve. Prioritizing the list requires a good understanding of both the system and the reengineering project.</p>
</li>
</ul>
</div>
</div>
<div class="sect4">
<h5 id="difficulties-7"><a class="anchor" href="#difficulties-7"></a>Difficulties</h5>
<div class="ulist">
<ul>
<li>
<p><em>Data is tedious to interpret.</em> To measure the quality of a piece of code, you must collect several measurements. Interpreting and comparing such multi-valued tuples is quite tedious especially when dealing with large software systems. Therefore, use visualizations which allow you to analyze different measurements simultaneously.</p>
</li>
<li>
<p><em>Requires expertise.</em> The interpretation of measurement data is difficult and requires a lot of expertise. Fortunately, part of this expertise is documented in the form of design heuristics (see among others [Rie96] [LK94]) and the rest can be acquired on the job.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p><span class="image"><img src="./media/image12.png" alt="image" width="257" height="132"></span></p>
</div>
<div class="paragraph">
<p>Figure 4.6: Class size overview with node size showing the lines of code and gray value showing the number of instance variables.</p>
</div>
</div>
</div>
<div class="sect3">
<h4 id="example-7"><a class="anchor" href="#example-7"></a>Example</h4>
<div class="paragraph">
<p>The analysis of the database and the design of <em>XDoctor</em> was quite reassuring. Although there were some things to improve, the overall quality was quite good. Yet, you want to confirm this feeling and therefore plan to collect a number of quality metrics and visualize them. (Of course the visualization can be done with ordinary spreadsheets, but in this case you decide to use the CodeCrawler tool [DDL99] [Lan99].)</p>
</div>
<div class="paragraph">
<p><em>Class Size Overview.</em> As a starter, you get an impression of the raw physical size of all the classes constituting <em>XDoctor</em>. You measure the class size in terms of number of lines of code (LOC) and number of instance variables (NIV) and use a <em>checkers graph</em> to show the relative proportion of the sizes. In such a graph all nodes are shown as squares where the size of the square is proportional to one size (here LOC) and the gray value is proportional to another size (here NIV).</p>
</div>
<div class="paragraph">
<p>Figure 4.6 shows the checker graph for <em>XDoctor</em>. The picture reveals that the class size is distributed quite evenly â which is reassuring â with a few noteworthy exceptions. For instance, there is the class B (with 1495 it is the largest in terms of lines of code) and class L (has most instance variables and second most lines of code). The classes in row Z are exceptional in the sense that they are very small, some of them even empty.</p>
</div>
<div class="paragraph">
<p><em>Class Inheritance.</em> Next, you get a feeling for the way inheritance is used by studying the various subtrees in the inheritance hierarchy. Therefore, you measure the classes in terms of hierarchy nesting level (HNL) and number of descendant classes (NDC). You include size measurements as well to assess the magnitude of the classes within the inheritance tree. Therefore, you collect the number of methods (NOM), number of instance variables (NIV) and number of lines of code (LOC) as well.</p>
</div>
<div class="paragraph">
<p><span class="image"><img src="./media/image13.png" alt="image" width="428" height="147"></span></p>
</div>
<div class="paragraph">
<p>Figure 4.7: Inheritance tree focussing on class size. The node width shows the number of instance variables, the node height shows the number of methods and the gray value shows the number of code lines.</p>
</div>
<div class="paragraph">
<p>You use an <em>inheritance tree</em> to visualize the various subtrees and the proportion of class sizes inside each of them. All nodes in such a tree have a rectangular shape where the height, width and gray value of each node show three measurements.</p>
</div>
<div class="paragraph">
<p>Figure 4.7 shows such an inheritance tree for <em>XDoctor</em>, where the height, width and gray value of each node represent NOM, NIV and LOC. To the left, you observe several normal inheritance trees, namely small ones where the size of the classes is quite similar. One exceptional value is the same B you noticed earlier, however you now see that it also has a large superclass A (defining 70 methods), making it even more suspicious. The L youâve seen before appears here as a solitary class. The hierarchies rooted in K, F and G seem quite interesting: they go deep (4 levels of inheritance) and have one large root class plus many smaller subclasses. H and I, plus M and N are both cases of large sibling classes, which may imply that too little is inherited from the common superclass. This must be verified via code browsing however.</p>
</div>
<div class="paragraph">
<p><em>Method Inheritance.</em> To analyze particular inheritance trees in further detail, you investigate how methods in a subclass relate to methods in their superclass. Therefore, you produce a table showing for each class the number of methods overriding a method defined in a superclass (NMO), the number of methods added to the superclass (NMA) and the number of methods extending a method defined in a superclass (NME). Here as well you use an inheritance tree to identify exceptional values in the measurements.</p>
</div>
<div class="paragraph">
<p>Figure 4.8 shows the A, G and F subtrees identified earlier, but now the height, width and gray value of each node represent NMO, NMA and NME. The root classes are displayed as narrow white rectangles, which is normal as root classes cannot override nor extend.</p>
</div>
<div class="paragraph">
<p><span class="image"><img src="./media/image14.png" alt="image" width="430" height="131"></span></p>
</div>
<div class="paragraph">
<p>Figure 4.8: Inheritance tree focussing on method inheritance. The node width shows the number of methods added, the node height shows the number of methods overridden and the gray value shows the number of methods extended.</p>
</div>
<div class="literalblock">
<div class="content">
<pre>As far as the subclasses concerns, you observe two phenomena. On the one hand, the subclasses of A add a lot, yet override very little, which suggests that code reuse is the main purpose of this inheritance tree. On the other hand, the subclasses of F and G override more methods than they add, which suggests a lot of hook methods and an inheritance tree aimed at specializing behavior. Here as well, these assumptions must be verified by code browsing.</pre>
</div>
</div>
<div class="paragraph">
<p><em>Method Size Overview.</em> An example of how to identify potential problems in the method bodies concerns the ratio of lines of code (LOC) and the number of messages sent (MSG). In most method bodies, these two measurements will correlate but methods where this correlation does not hold typically represent special code.</p>
</div>
<div class="paragraph">
<p>To study this correlation relationship one might divide the two measurements. <sup class="footnote">[<a id="_footnoteref_4" class="footnote" href="#_footnote_4" title="View footnote.">4</a>]</sup>. However, both are counting measurements having a ratio scale and then division is permitted.] However, then you lose the sense for the constituting measurements which makes interpretation difficult. Therefore, you visualize the relationship by means of a <em>correlation graph</em>, where each method is shown as a small square and where the x, y position shows the measurements that are supposed to correlate. In such a graph, the nodes where the measurements correlate cluster around a diagonal, while the exceptions are from the diagonal.</p>
</div>
<div class="paragraph">
<p>Figure 4.9 shows a correlation graph where the horizontal axis (left to right) represents the number of messages sent and the vertical axis (top to bottom) the number of lines of code. You observe a big cluster in the top left corner where most nodes are superimposed on each other.</p>
</div>
<div class="paragraph">
<p><span class="image"><img src="./media/image15.png" alt="image" width="170" height="261"></span></p>
</div>
<div class="paragraph">
<p>Figure 4.9: Correlation graph, with x-position showing the number of messages sent and y-position showing the lines of code.</p>
</div>
<div class="paragraph">
<p>This is reassuring because it implies that most methods have fewer than 15 lines of code and 10 messages sent. The exceptions appear at the edges of the picture. For instance, node A is a large method with 99 messages packed on 45 lines of code. Node D (and its neighbors) are also methods where many messages are packed on a single line of code. Via code browsing you see that many of them are initialization methods. At the other side of the diagonal there is node B, which represents a method with 16 lines of code yet no messages sent. Code browsing reveals that itâs a case where the whole method body has been commented out.</p>
</div>
</div>
<div class="sect3">
<h4 id="rationale-6"><a class="anchor" href="#rationale-6"></a>Rationale</h4>
<div class="paragraph">
<p><em>You cannot control what you cannot measure.
â Tom De Marco, [Mar82]</em></p>
</div>
<div class="paragraph">
<p>In several places in the literature it is mentioned that measuring source code helps in problem identification (see among others, [LK94] [FP96] [MLM96] [Nes88]). Most metric tools applied during these experiments visualize information by means of histograms and Kiviat diagrams. However, few research have studied the impact of thresholds while identifying exceptional entities; our own experience is that thresholds donât really matter [DD99].</p>
</div>
<div class="paragraph">
<p>Unfortunately, the current research is inconclusive with regards to the accuracy of the results. Up until now, no experiments exist that count how many problems remain undiscovered, nor is there any work on assessing the severity of the problems discovered. As such it is impossible to assess the reliability of metrics for reverse engineering.</p>
</div>
</div>
<div class="sect3">
<h4 id="known-uses-7"><a class="anchor" href="#known-uses-7"></a>Known Uses</h4>
<div class="paragraph">
<p>During the FAMOOS project one event provided anecdotal evidence for how well a simple approach may outperform more specialized and complex approaches. Once we visited a business unit for a few days to demonstrate our CodeCrawler tool. At first the developers were quite sceptical because they felt like they would see âyet another metrics toolâ. The first surprise came when we showed them results already during the first day. They told us that other tools would typically require several days configuration time before they could parse their C code because it made such heavy use of special C features and macros. Moreover, and this was the second surprise, this simplicity did not diminish the quality of our results. The programmers confirmed most of the design anomalies we discovered, yet were intrigued by some observations we made. During the subsequent discussions they at least considered design alternatives.</p>
</div>
</div>
<div class="sect3">
<h4 id="what-next-9"><a class="anchor" href="#what-next-9"></a>What Next</h4>
<div class="paragraph">
<p>Applying this pattern will result in an overall impression of design quality and the identification of a few potential design problems. With this knowledge you should at least reconsider whether the goal of your reengineering project is still attainable. If it is, you will probably want to solve some of these design problems, for instance using patterns in Redistribute Responsibilities [p. 217] and Transform Conditionals to Polymorphism [p. 245]. Solving some of these problems may require a more detailed understanding of that design, which may be obtained by patterns in Detailed Model Capture [p. 105].</p>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="detailed-model-capture"><a class="anchor" href="#detailed-model-capture"></a>5. Detailed Model Capture</h2>
<div class="sectionbody">
<div class="paragraph">
<p>The patterns in First Contact should have helped you to get acquainted with the software system, while those in Initial Understanding should have helped you to understand which are the most important entities in the system. Your main priority now is to build up a detailed model of those parts of the system that will be important for your reengineering effort.</p>
</div>
<div class="paragraph">
<p>Most of the patterns concerned with Detailed Model Capture entail considerably more technical knowledge, use of tools and investment of effort than the patterns we have applied up to now. This is only natural, since only after you have built up your Initial Understanding can you determine whether more intensive investment of effort will pay off.</p>
</div>
<div class="sect2">
<h3 id="forces-3"><a class="anchor" href="#forces-3"></a>Forces</h3>
<div class="paragraph">
<p>Although you already have an impression of the system, there are several forces at play that may make it difficult to extract a more detailed model:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><em>Details matter.</em> As argued by Brooks [Bro87], software engineering is different from other engineering disciplines because of the inherent lack of abstraction barriers. Other engineering disciplines rely on the laws of nature to hide irrelevant details, but software engineering must build on less solid foundations. <em>Consequently, it is essential to pay attention to the details.</em> The only question is how to filter out those details that do not matter, because you cannot possible investigate everything.</p>
</li>
<li>
<p><em>Design remains implicit.</em> As you read the code, many design decisions will become apparent to you, but it will not be clear why and how these decisions were made. In particular, it will be hard to tell which design decisions were easy to make, and which of them created a lot of grief. Nevertheless, such knowledge is crucial during a reengineering project because you want to avoid making the same mistakes over and over again. <em>Consequently, once you discover the underlying design rationale, make sure that it is properly recorded.</em> This way, your successors will be able to build on your discoveries rather than be forced to reinvent the wheel.</p>
</li>
<li>
<p><em>Design does evolve.</em> Change is an essential ingredient of a successful system, certainly in object-oriented development processes with their emphasis on iterative development. As a consequence, design documents will always be out-of date with respect to the actual situation. However, this also implies that change itself is the key to understand how and why the design of a system has evolved the way it is. _Consequently, assume that important design issues will be reflected in the source code and in the way this code has changed over time.</p>
</li>
<li>
<p><em>Static structure versus Dynamic behavior.</em> Object-oriented source code tells you which classes are defined, and how they are arranged in a class hierarchy. It is much harder to see which objects are instantiated at run-time, and how they collaborate to support the system. On a fine-grained level however, the latter is much more relevant than the former, especially due to the use of polymorphism. <em>Consequently, to extract the detailed design one must inevitably study the dynamic behavior.</em></p>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="overview-3"><a class="anchor" href="#overview-3"></a>Overview</h3>
<div class="paragraph">
<p>The patterns of Detailed Model Capture propose a series of activities that help you to expose design artifacts that are hidden in the code. Although some of these patterns, in particular Tie Code and Questions, are lightweight, most of them entail considerable effort, so you should evaluate carefully how much you expect to get out of applying them.</p>
</div>
<div class="paragraph">
<p>Figure 5.1 suggests some possible relationships between the patterns. Tie Code and Questions is perhaps the most fundamental of these patterns, and the easiest to apply. As you work through the source code, keep track of comments, questions, hypotheses and possible actions to perform by directly annotating the source code <em>at the point where the comment applies</em>. This pattern works well with the other patterns in this cluster, and can be productively applied throughout a reengineering project.</p>
</div>
<div class="paragraph">
<p>Refactor to Understand helps you to expose the design of cryptic code.</p>
</div>
<div class="paragraph">
<p><span class="image"><img src="./media/image16.jpg" alt="image" width="432" height="360"></span></p>
</div>
<div class="paragraph">
<p>Figure 5.1: The patterns of Detailed Model Capture help you to expose the design of the software system and keep track of your understanding.</p>
</div>
<div class="paragraph">
<p>It is important to understand that the intent of this pattern is <em>not</em> to improve the code base itself, but only to improve your understanding. It might well be that you decide to keep the results of your refactorings, but this should not be your goal at this point. Your refactorings should instead be treated as experiments to tests various hypotheses concerning the code.</p>
</div>
<div class="paragraph">
<p>Since the source code gives you only a very static view of the class hierarchy, it is useful to Step Through the Execution to learn what objects are instantiated and run time and how they interact.</p>
</div>
<div class="paragraph">
<p>Although it is very easy to extract the interfaces of the classes in the system, this will not tell you very much about how these interfaces can or should be used. What you really need is to do is Look for the Contracts supported by each class. The contracts tell you which client-supplier relationships exist, and how the public interface of a class supports that relationship. Idiomatic coding practices and design patterns typically express such contracts in direct way, so you should train yourself to recognize them.</p>
</div>
<div class="paragraph">
<p>Finally, though you may be able to extract various design artifacts from the source code, you will not necessarily be able to get an insight into how the system evolved that way. In particular, you may wonder whether certain design decisions were really justified, or whether they were arbitrary, and you may wonder how stable parts of the design are. By comparing different versions of the code base and focusing on places where functionality was <em>removed</em> or refactored, you will be able to Learn from the Past.</p>
</div>
</div>
<div class="sect2">
<h3 id="what-next-10"><a class="anchor" href="#what-next-10"></a>What Next</h3>
<div class="paragraph">
<p>Now that you have mastered the details of a part of your system, it is a good time to prepare for the actual reengineering by applying the patterns in Tests: Your Life Insurance!. In particular, as you Refactor to Understand, it is a good idea to Write Tests to Understand [p. 163], as this will give you confidence in your experiments. Also, patterns like Step Through the Execution, Look for the Contracts and Learn from the Past help you to see which components implement what functionality: this knowledge must be used to Test the Interface, Not the Implementation [p. 155] and to Record Business Rules as Tests [p. 159].</p>
</div>
</div>
<div class="sect2">
<h3 id="tie-code-and-questions"><a class="anchor" href="#tie-code-and-questions"></a>5.1 Tie Code and Questions</h3>
<div class="paragraph">
<p><strong>Intent</strong> <em>Keep the questions and answers concerning your reengineering activities synchronized with the code by storing them directly in the source files.</em></p>
</div>
<div class="sect3">
<h4 id="problem-8"><a class="anchor" href="#problem-8"></a>Problem</h4>
<div class="paragraph">
<p>How do you <em>keep track of your understanding</em> about a piece of code and the questions that you have, keep these <em>remarks synchronized with the code</em> during its future evolution, and <em>share them</em> with the other members of your team?</p>
</div>
<div class="paragraph">
<p><em>This problem is difficult because:</em></p>
</div>
<div class="ulist">
<ul>
<li>
<p>Writing up what you know and donât know about the system you are analyzing is tedious and time-consuming.</p>
</li>
<li>
<p>Your understanding is a moving target, so it is hard to keep a written document up-to-date.</p>
</li>
<li>
<p>If you donât write down your questions and insights as soon as they occur to you, you will not be able to keep track of them.</p>
</li>
<li>
<p>You want to share your knowledge with the team to maximize its value.</p>
</li>
<li>
<p>Logging questions and answers in log files, bulletin boards or email distribution lists may be convenient for disseminating knowledge within the team, and may provide a convenient searchable history of the teamâs understanding, but when you are looking at a piece of code, it will be hard to tell what questions and answers pertain to it.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p><em>Yet, solving this problem is feasible because:</em></p>
</div>
<div class="ulist">
<ul>
<li>
<p>You can annotate the code, and therefore record your understanding physically close to the code element it refers to.</p>
</li>
</ul>
</div>
</div>
<div class="sect3">
<h4 id="solution-8"><a class="anchor" href="#solution-8"></a>Solution</h4>
<div class="paragraph">
<p>While you are working on the code annotate it directly and immediately with the questions you are facing.</p>
</div>
<div class="paragraph">
<p><em>In principle there are two ways to annotate the code.</em></p>
</div>
<div class="ulist">
<ul>
<li>
<p><em>Comment-based Annotations.</em> This approach uses the commenting conventions of the programming language and as such is bettersuited for a text-oriented environment. A few conventions are needed to distinguish the normal comments from the annotations.</p>
</li>
</ul>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="comment">/* #to: John #by: SD #on: 3/12/99
Screws up when we have nested IFs. */</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Basic tools part of your program environment can then be used to search and modify annotations. With a little bit of extra effort one can easily build tools to query, extract and cross-index all commentbased annotations.</p>
</div>
<div class="ulist">
<ul>
<li>
<p><em>Method-based annotations.</em> This approach exploits the possibility to query which method invokes a given method, a feature provided by many of todayâs programming environments. The idea is to declare a global method accepting a few strings as an argument and having an empty method body. Each time you want to annotate a particular piece of code, you invoke that method passing your annotations as a parameter.</p>
</li>
</ul>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="local-variable">this</span>.annotateCode(<span class="string"><span class="delimiter">&quot;</span><span class="content">#to: John #by: SD #on: 3/12/99</span><span class="delimiter">&quot;</span></span>, <span class="string"><span class="delimiter">&quot;</span><span class="content">Screws up when we have nested IFs.</span><span class="delimiter">&quot;</span></span>);</code></pre>
</div>
</div>
<div class="paragraph">
<p>You can then use the querying and browsing facilities of your programming environment to identify the locations where this special method is invoked, thus where the annotations occur. Most programming environments can be extended by means of little scripts, in which case it is possible to develop tools to generate reports about all annotations.</p>
</div>
<div class="paragraph">
<p>Note that the less you change the code, the less likely it is that you will introduce errors. This makes the comment-based version safer than the method-based version.</p>
</div>
<div class="sect4">
<h5 id="hints-6"><a class="anchor" href="#hints-6"></a>Hints</h5>
<div class="ulist">
<ul>
<li>
<p>Record your annotations <em>as close as possible</em> to the code to which they refer.</p>
</li>
<li>
<p>Annotations may be <em>questions</em>, <em>hypotheses</em>, <em>âto doâ lists</em>, or simply <em>observations</em> about the code that you wish to record for future reference.</p>
</li>
<li>
<p>Use conventions to <em>identify your annotations</em>. In a team context, include, for example, the initials of the developer that made the comments and the date the comment was entered. This way you can easily query them.</p>
</li>
<li>
<p><em>Follow the corporate practices.</em> If comments are written in a language other than English, continue if you can. However, if you have the choice never write your annotations in a language different from that in which the source code is written (English in most cases). Otherwise, you create a different context and force the reader to switch between them.</p>
</li>
<li>
<p>When you discover the <em>answer</em> to any one of your questions, <em>immediately update</em> the annotation for the benefit of future readers, or simply <em>delete</em> the question if it is no longer relevant.</p>
</li>
</ul>
</div>
</div>
</div>
<div class="sect3">
<h4 id="tradeoffs-8"><a class="anchor" href="#tradeoffs-8"></a>Tradeoffs</h4>
<div class="sect4">
<h5 id="pros-8"><a class="anchor" href="#pros-8"></a>Pros</h5>
<div class="ulist">
<ul>
<li>
<p><em>Natural Synchronization.</em> You keep the code and the annotations in close physical proximity, and you thereby improve your chances of keeping them in sync. While modifying the code, you will more naturally modify the annotations, or remove them if they become obsolete.</p>
</li>
<li>
<p><em>Improves Team Communication.</em> Tie Code and Questions avoids that team members must open an extra communication channel (e-mail, bulletin boards, Â·Â·Â·). They must read the code they work with anyhow so you can multiplex the code as a communication channel.</p>
</li>
<li>
<p><em>Minimize Context Description.</em> When you annotate the code you are immediately in context. This way you will minimize the need to describe the context of your questions and keep your effort low while documenting your questions and annotations.</p>
</li>
</ul>
</div>
</div>
<div class="sect4">
<h5 id="cons-8"><a class="anchor" href="#cons-8"></a>Cons</h5>
<div class="ulist">
<ul>
<li>
<p><em>Passive in Nature.</em> Questions that you enter are not necessarily directed to anyone and even if they are, it is not certain that the addressee will read them or answer them in time. Additional tools are needed to collect the annotations and maybe even notify the appropriate persons.</p>
</li>
<li>
<p><em>Process Incompatibility.</em> Many companies are organized around a hierarchical reporting structure. Tie Code and Questions may be rejected by these organizations because it circumvents the normal communication channels. Also, some corporate practices impose strong constraints on what programmers are allowed to do with the code, which may limit the potential if this pattern. For instance, if annotations cannot be removed when they become obsolete, they will create too much noise to be useful.</p>
</li>
</ul>
</div>
</div>
<div class="sect4">
<h5 id="difficulties-8"><a class="anchor" href="#difficulties-8"></a>Difficulties</h5>
<div class="ulist">
<ul>
<li>
<p><em>Finding the Right Granularity.</em> As with any kind of comments, you should take care to introduce just the right amount of detail. Terse or cryptic annotations quickly lose their value, and verbose annotations will distract the reader from the code itself.</p>
</li>
<li>
<p><em>Motivating the Programmers to Write Comments.</em> Programmers generally do not like to write comments or documentation. One way of motivating them is to use the annotations during code reviews or status meetings: this way the comments have an immediate benefit.</p>
</li>
<li>
<p><em>Quality of the Answers.</em> As with any other kinds of documentation, it may happen that wrong answers are given. One way to deal with this situation is to review the annotations regularly within the team.</p>
</li>
<li>
<p><em>Eliminating the Annotations.</em> On certain occasions you may wish the remove the annotations. For instance, if you must deliver a âcleanâ version of the source-code to your customer, or if your compiler isnât smart enough to remove an invocation of an empty method body. In that case, make sure that you have the proper tools to filter out the annotations.</p>
</li>
</ul>
</div>
</div>
</div>
<div class="sect3">
<h4 id="rationale-7"><a class="anchor" href="#rationale-7"></a>Rationale</h4>
<div class="paragraph">
<p>This pattern has its roots in <em>literate programming</em> [RS89][Knu92]. A literate program reverses the usual relationship between program text and comments: executable code is embedded within documentation, not the other way around. Literate programming puts the emphasis on keeping the code and its documentation physically close. The physical proximity reduces the effort spent in keeping the code and its documentation in sync.</p>
</div>
</div>
<div class="sect3">
<h4 id="known-uses-8"><a class="anchor" href="#known-uses-8"></a>Known Uses</h4>
<div class="paragraph">
<p><em>Comment-based annotations.</em> Various programming environments provide implicit support for managing annotations within the code. Emacs, for example, has a built-in tool, called e-tags, which allows you to easily generate a cross-reference database of a a set of files [CRR96]. The Eiffel environment, on the other hand, allows you to assign different levels of visibility to your comments (and your code). If you assign private scope to your annotations you can easily separate the annotations yet make sure that these will not be seen externally.</p>
</div>
<div class="paragraph">
<p>The company MediaGeniX â a Belgian company operating in the multi-media sector â used a systematic code tagging mechanism to record information about changes. The programming environment was altered in such a way that every change to the code was automatically annotated with a tag that describes the motivation for the code change (bug fix, change request, new release), the name of developer, and the time of the modification. Only the last tag is kept in the code, but via the configuration management system it is possible to inspect previous tags and changes. The tag also includes a free field where the developers may write what they want and is often used for questions and answers.</p>
</div>
<div class="paragraph">
<p><em>Method-based annotations.</em> The Squeak development team [IKM<sup>+</sup>97] used this technique not so much to keep track of questions but as a means to facilitate communication in an open-source development project. In this team comments were introduced by invoking the method flag: defined in the class Object. Developers can query all senders of the flag: message to locate annotations. Furthermore, the method is defined to accept a symbol as its argument. This makes it possible to search more specifically, for example, for all the annotations flagged with the symbol #noteForJohn.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="smalltalk">Object&gt;&gt;flag: aSymbol

&quot;Send this message, with a relevant symbol as argument, to flag a message for subsequent retrieval. For example, you might put the following line in a number of messages:

self flag: #returnHereUrgently

Then, to retrieve all such messages, browse all senders of #returnHereUrgently.&quot;</code></pre>
</div>
</div>
<div class="paragraph">
<p>Figure 5.2 shows on the top pane all the senders of the flag: message in the Squeak2.7 environment. The bottom pane then shows the code of the method removeEmptyRows that contains a call to the method flag: highlighted. The flag: message is sent with argument #noteToJohn. The actual content of the annotation follows as a comment.</p>
</div>
</div>
<div class="sect3">
<h4 id="related-patterns-2"><a class="anchor" href="#related-patterns-2"></a>Related Patterns</h4>
<div class="paragraph">
<p>Tie Code and Questions works well in tandem with Refactor to Understand. Questions in the code may often be resolved by refactoring it. Conversely, as you Refactor to Understand, new questions will be raised and can be entered as annotations.</p>
</div>
<div class="paragraph">
<p><span class="image"><img src="./media/image17.jpg" alt="image" width="424" height="273"></span></p>
</div>
<div class="paragraph">
<p>Figure 5.2: Finding all senders of a message in Squeak.</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="refactor-to-understand"><a class="anchor" href="#refactor-to-understand"></a>5.2 Refactor to Understand</h3>
<div class="paragraph">
<p><strong>Intent</strong> <em>Iteratively refactor a part of a software system in order to validate and reflect your understanding of how it works.</em></p>
</div>
<div class="sect3">
<h4 id="problem-9"><a class="anchor" href="#problem-9"></a>Problem</h4>
<div class="paragraph">
<p>How can you understand a cryptic piece code?</p>
</div>
<div class="paragraph">
<p><em>This problem is difficult because:</em></p>
</div>
<div class="ulist">
<ul>
<li>
<p>Cryptic code is difficult to read, hence to understand.</p>
</li>
<li>
<p>You may have some idea how the code works, but it is hard to verify because the code does not reflect your ideas.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p><em>Yet, solving this problem is feasible because:</em></p>
</div>
<div class="ulist">
<ul>
<li>
<p>The piece of code is <em>relatively small</em> and has clearly defined boundaries.</p>
</li>
<li>
<p>Your development tools allow for <em>rapid edit-compile cycles</em>, so you can make some small changes and check whether youâre still able to compile the source-code or that your tests still run.</p>
</li>
<li>
<p>You have a <em>source-code browser</em> that allows you to query dependencies between source-code entities (<em>i.e.</em>, which methods invoke a given operation, which methods access a given attribute, &#8230;&#8203;), so that you can infer its purpose.</p>
</li>
</ul>
</div>
</div>
<div class="sect3">
<h4 id="solution-9"><a class="anchor" href="#solution-9"></a>Solution</h4>
<div class="paragraph">
<p>Iteratively rename and refactor the code to introduce meaningful names and to make sure the structure of the code reflects what the system is actually doing. Run regression tests after each change if they are available, else compile often to check whether your changes make sense. Decide what to do with the code after you have refactored it.</p>
</div>
<div class="sect4">
<h5 id="hints-7"><a class="anchor" href="#hints-7"></a>Hints</h5>
<div class="paragraph">
<p>Your primary goal here is to <em>understand the system</em>, not to improve the code. The changes you make to the code should therefore be treated as âexperimentsâ to test your understanding of the code. As a consequence, you should <em>make a copy of the code</em> before you start. After you have refactored the code, it is possible that you release any of the changes you make, but you do not want to make that decision up front. Perhaps your refactoring experiments will actually improve the code, but it is just as likely that you will make a mess of things since you do not yet understand the code. It does not really matter at this stage. After a first experience you will be in a better position to do a proper job of refactoring.</p>
</div>
<div class="paragraph">
<p>It is hard to do a good job of refactoring without having tests in place to verify that your changes have not broken anything. If adequate tests do not exist, you should <em>not</em> seriously consider keeping the results of your refactoring experiments. However, consider applying Write Tests to Understand [p. 163] in tandem with Refactor to Understand.</p>
</div>
<div class="paragraph">
<p>You should select refactoring operations that will make design decisions more explicit in the code. The typical refactorings applied during this iterative restructuring are Rename Attribute [p. 292], Rename Method [p. 292], and Extract Method [p. 291].</p>
</div>
<div class="paragraph">
<p>The following guidelines will help you to find out where and how to apply these refactorings to improve the readability of the code. Many of these guidelines are considered to be just good, standard practice in Smalltalk programming [Bec97]. They apply, however, equally well to other programming languages. They can be applied in any order; each of them participates in the understanding of the others.</p>
</div>
<div class="ulist">
<ul>
<li>
<p><em>Rename attributes to convey roles.</em> Focus on attributes with cryptic names. To find out about their roles, look at all the attribute accesses (including invocations of accessors methods). Afterwards, rename the attribute and its accessors according to its role, update all references and re-compile the system.</p>
</li>
<li>
<p><em>Rename methods to convey intent.</em> To retrieve the intent of a method that does not have an intention revealing name, investigate all invocations and attribute uses, and deduce the methodâs responsibility. Afterwards, rename the method according to its intent, update all invocations and re-compile the system.</p>
</li>
<li>
<p><em>Rename classes to convey purpose.</em> To capture the purpose of class having an unclear name, investigate clients of the class by examining who is invoking its operations or who is creating instances of it. Afterwards, rename the class according to its purpose, update all references and re-compile the system.</p>
</li>
<li>
<p><em>Remove duplicated code.</em> If you identify duplicated code, try to refactor it into a single location. As such, you will identify slight differences that you probably would not have noticed before refactoring and that are likely to reveal some subtle design issues.</p>
</li>
<li>
<p><em>Replace condition branches by methods.</em> If you encounter conditions with large branches, extract the leaves as new (private) methods. To name these methods, study the condition until you understand it well enough to choose an intention revealing name.</p>
</li>
<li>
<p><em>Refactor method bodies to a consistent level of abstraction.</em> Long method bodies with comments separating blocks of code violate the rule of the thumb that all statements in a single method body should have the same level of abstraction. Refactor such code by introducing a new (private) method for each separated block of code; name the method after the intent recorded in the comment.</p>
</li>
</ul>
</div>
</div>
</div>
<div class="sect3">
<h4 id="tradeoffs-9"><a class="anchor" href="#tradeoffs-9"></a>Tradeoffs</h4>
<div class="sect4">
<h5 id="pros-9"><a class="anchor" href="#pros-9"></a>Pros</h5>
<div class="ulist">
<ul>
<li>
<p><em>Expose design.</em> Not only will the refactoring process improve your understanding of the code, but this understanding will also become explicit in the structure of the code. This will make it easier to further document that understanding by means of Tie Code and Questions or Write Tests to Understand [p. 163].</p>
</li>
<li>
<p><em>Incremental validation.</em> Normally, understanding does not arise as part of a single revelation, but as the result of an iterative process in which earlier understanding is the base for the next iteration. Refactor to Understand encourages such an approach, because of its emphasis on small steps and frequent verification (either by running tests or either by compiling often).</p>
</li>
</ul>
</div>
</div>
<div class="sect4">
<h5 id="cons-9"><a class="anchor" href="#cons-9"></a>Cons</h5>
<div class="ulist">
<ul>
<li>
<p><em>Risk of introducing errors.</em> The less you change the code, the smaller your chances of introducing errors. Small refactorings should be behavior-preserving, but it may be non-trivial to verify that even simple refactorings do not break the code. If you do not have adequate regression tests in place, it can be risky to introduce changes, or costly to develop the needed tests. For these reasons it is important to attempt to Refactor to Understand only on a working copy of the software.</p>
</li>
</ul>
</div>
</div>
<div class="sect4">
<h5 id="difficulties-9"><a class="anchor" href="#difficulties-9"></a>Difficulties</h5>
<div class="ulist">
<ul>
<li>
<p><em>Tool Support.</em> Manually refactoring code can be tedious and risky [FBB<sup>+</sup>99]. Various tools, like the Refactoring Browser [RBJ97], greatly simplify the task of refactoring, and especially help to apply non-trivial refactorings such as Extract Method.</p>
</li>
<li>
<p><em>Acceptance of Changes.</em> Refactoring someone elseâs code may prove a lot harder than refactoring your own. A lot of companies have a strong culture of code ownership, so improving someone elseâs code is often considered an insult. That is one of the reasons why you should not necessarily release the refactored version to the rest of the team.</p>
</li>
<li>
<p><em>When to stop.</em> It is often difficult to stop changing code when you identify problems. Remember that your primary goal here is to just understand the system. When you have achieved that goal, it is time to stop.</p>
</li>
</ul>
</div>
</div>
</div>
<div class="sect3">
<h4 id="known-uses-9"><a class="anchor" href="#known-uses-9"></a>Known Uses</h4>
<div class="paragraph">
<p>Don Roberts and John Brant coined the term Refactor to Understand at ESUG â97 and Smalltalk Solutions â97 during a demonstration of the <em>Refactoring Browser</em>. They showed how they gradually understood an algorithm by renaming and refactoring its code. During the subsequent iterations of the pattern, the code slowly started to make sense and the design gradually became explicit in the code.</p>
</div>
<div class="paragraph">
<p>We applied this pattern ourselves during a FAMOOS case study. We had to understand a single method of about 3000 lines of C++, which was a deeply nested conditional. We first replaced the leaf condition branches by methods, gradually working our way up the nesting structure. After several iterations, we discovered that this method was actually implementing a complete parser for a small command language.</p>
</div>
<div class="paragraph">
<p>Harry Sneed reports several reengineering projects where a large Cobol program was refactored by removing all goto statements. However, he was later forced to reintroduce the go-to statements because the developers rejected his changes [Sne99].</p>
</div>
</div>
<div class="sect3">
<h4 id="related-patterns-3"><a class="anchor" href="#related-patterns-3"></a>Related Patterns</h4>
<div class="paragraph">
<p>âArranging the Furnitureâ [Tay00] is a pattern to help newcomers feel at home when they start in a new project. The pattern solution is: âAn adopter should be encouraged to âmove inâ by cosmetically arranging the code.â</p>
</div>
</div>
<div class="sect3">
<h4 id="what-next-11"><a class="anchor" href="#what-next-11"></a>What Next</h4>
<div class="paragraph">
<p>Refactor to Understand works well in tandem with Tie Code and Questions. Refactorings are more expensive to implement than simply annotating the code, so first annotate, and then refactor. Also, consider to Write Tests to Understand [p. 163] as you refactor. These two activities reinforce each other since tests document your understanding of how a software artifact works, and refactoring helps you to expose its design. Furthermore, tests will help you to verify that your refactorings didnât break anything.</p>
</div>
<div class="paragraph">
<p>When you have finished a round of Refactor to Understand, you must decide what to do with your changes. If you discard the experimental code, you should consider applying Tie Code and Questions to annotate the code base with the knowledge you have acquired.</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="step-through-the-execution"><a class="anchor" href="#step-through-the-execution"></a>5.3 Step Through the Execution</h3>
<div class="paragraph">
<p><strong>Intent</strong> <em>Understand how objects in the system collaborate by stepping through examples in a debugger.</em></p>
</div>
<div class="sect3">
<h4 id="problem-10"><a class="anchor" href="#problem-10"></a>Problem</h4>
<div class="paragraph">
<p>How do you discover which objects are instantiated at run-time and how they collaborate?</p>
</div>
<div class="paragraph">
<p><em>This problem is difficult because:</em></p>
</div>
<div class="ulist">
<ul>
<li>
<p>The source code exposes the class hierarchy, not the objects instantiated at run time and how they interact.</p>
</li>
<li>
<p>Collaborations are typically spread out through the code. Although it is easy to see which classes and methods are defined in a system, it can be hard to tell by reading the source code alone which sequence of events will lead to an object being created or a method being invoked.</p>
</li>
<li>
<p>In the presence of polymorphism, it can be especially difficult to tell which objects are clients of which service providers. Just because an object uses a certain interface that another object provides, does not mean that the former is actually a client of the latter.</p>
</li>
<li>
<p>Reading the code will not tell you what concrete scenarios can take place. The actual flow of execution will depend on the internal state of all participating objects and this cannot be inferred directly from the source code.</p>
</li>
<li>
<p>The source code will not tell you which objects are long-lived and which are ephemeral (<em>i.e.</em>, local to the execution of a single method).</p>
</li>
</ul>
</div>
<div class="paragraph">
<p><em>Yet, solving this problem is feasible because:</em></p>
</div>
<div class="ulist">
<ul>
<li>
<p>You are aware of some typical usage scenarios.</p>
</li>
<li>
<p>You can run the code inside a debugger.</p>
</li>
<li>
<p>Your attention is focussed on part of the system.</p>
</li>
</ul>
</div>
</div>
<div class="sect3">
<h4 id="solution-10"><a class="anchor" href="#solution-10"></a>Solution</h4>
<div class="paragraph">
<p>Run each of the scenarios and use your debugger to step through the code.</p>
</div>
<div class="paragraph">
<p>Observe which objects collaborate and how they are instantiated. Afterwards, generalize these observations and record your knowledge for future reference, possibly by means of Tie Code and Questions and Record Business Rules as Tests [p. 159].</p>
</div>
<div class="sect4">
<h5 id="hints-8"><a class="anchor" href="#hints-8"></a>Hints</h5>
<div class="paragraph">
<p>It is too time-consuming to step through every single statement of a running system. The assumption here is that you are focussed on some specific aspect of the system that is difficult to understand.</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Set <em>breakpoints</em> to interrupt execution when the system enters the code you are interested in.</p>
</li>
<li>
<p>Change the <em>internal state</em> of the objects to see how alternative execution paths are triggered.</p>
</li>
<li>
<p><em>Restart a method</em> currently on the execution stack to quickly verify a similar scenario.</p>
</li>
</ul>
</div>
</div>
</div>
<div class="sect3">
<h4 id="tradeoffs-10"><a class="anchor" href="#tradeoffs-10"></a>Tradeoffs</h4>
<div class="sect4">
<h5 id="pros-10"><a class="anchor" href="#pros-10"></a>Pros</h5>
<div class="ulist">
<ul>
<li>
<p><em>Realistic View.</em> By stepping through the running program, you get a precise picture of how the scenario unfolds. Moreover, you can inspect the internal state of the objects involved, see how new objects are created and observe which objects collaborate under which circumstances.</p>
</li>
<li>
<p><em>Handles complexity.</em> On a small scale it is possible to infer object collaborations from analyzing the source code. Slicing tools for instance may tell you which statements of the source code are affected by a given variable. For large and complex systems however, the number of possibilities and interactions is just too large. Therefore, the only reasonable way to learn how objects collaborate is to study the execution traces.</p>
</li>
</ul>
</div>
</div>
<div class="sect4">
<h5 id="cons-10"><a class="anchor" href="#cons-10"></a>Cons</h5>
<div class="ulist">
<ul>
<li>
<p><em>Scenario-based.</em> Your must restrict yourself to a limited set of scenarios, hence the observed object-collaborations are necessarily incomplete. Of course you must do your best to choose representative scenarios. Unfortunately, this choice brings you back to square one, because the only way to be sure that you have a representative set of scenarios is to verify whether they cover all possible objectcollaborations.</p>
</li>
<li>
<p><em>Restricted Applicability.</em> For systems where time plays a crucial role, stepping through the execution will give you an unrealistic view of the systemâs behavior. Worse, for concurrent or distributed systems the mere fact of stepping through concurrent code may perturb the execution of the system itself. As such, you get the same effects as in Heisenbergâs uncertainty experiments, where determining exact positions of quantum particles imply that other attributes about these particles become uncertain.</p>
</li>
</ul>
</div>
</div>
<div class="sect4">
<h5 id="difficulties-10"><a class="anchor" href="#difficulties-10"></a>Difficulties</h5>
<div class="ulist">
<ul>
<li>
<p><em>Dependency on Tools.</em> You need to have good debugger to Step Through the Execution. Not only must it allow to set and remove breakpoints dynamically, it also should provide the means to examine the state of the objects involved. And to easily verify alternative paths, the debugger should allow you to change the internal state of an object, or even restart a method currently on the execution stack.</p>
</li>
</ul>
</div>
</div>
</div>
<div class="sect3">
<h4 id="what-next-12"><a class="anchor" href="#what-next-12"></a>What Next</h4>
<div class="paragraph">
<p>You will need concrete scenarios in order to Step Through the Execution (possibly inferred from Interview During Demo [p. 59]). Consider encoding these scenarios as test cases. You can then iteratively Write Tests to Understand [p. 163] as you Step Through the Execution since the insights you gain into the states of collaborating objects can then be formulated as concrete tests.</p>
</div>
<div class="paragraph">
<p>As you Step Through the Execution, it is a good idea to keep an eye on the way collaborating objects use each otherâs interface. Afterwards, you can exploit the knowledge you have gained to Look for the Contracts.</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="look-for-the-contracts"><a class="anchor" href="#look-for-the-contracts"></a>5.4 Look for the Contracts</h3>
<div class="paragraph">
<p><strong>Intent</strong> <em>Infer the proper use of a class interface by studying the way clients currently use it.</em></p>
</div>
<div class="sect3">
<h4 id="problem-11"><a class="anchor" href="#problem-11"></a>Problem</h4>
<div class="paragraph">
<p>How do you determine which contracts a class supports? That is, how do you know what a class expects from its client classes in order to function as intended.</p>
</div>
<div class="paragraph">
<p><em>This problem is difficult because:</em></p>
</div>
<div class="ulist">
<ul>
<li>
<p>Client/supplier relationships and contracts are only implicit in the code. Although interfaces are easy to extract from the code, they do not necessarily tell you how to use them properly. If not explicitly documented, it can be hard to guess (a) the proper sequence in which methods should be invoked, (b) the valid parameters that should be supplied, (c) which methods should be invoked by which clients, (d) which methods should be overridden by subclasses.</p>
</li>
<li>
<p>Typing and scoping rules often force programmers to compromise the providerâs interface. Moreover, encapsulation constructs (<em>e.g.</em>, public/private declarations) are frequently misused to cope with implementation issues. For instance, database and user-interface toolkits often require the presence of public accessor methods.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p><em>Yet, solving this problem is feasible because:</em></p>
</div>
<div class="ulist">
<ul>
<li>
<p>You have a <em>good understanding</em> of the systemâs structure (for example obtained via Initial Understanding), so you can distinguish key classes from less important ones.</p>
</li>
<li>
<p>You trust that the class is being used properly by its clients and its subclasses.</p>
</li>
</ul>
</div>
</div>
<div class="sect3">
<h4 id="solution-11"><a class="anchor" href="#solution-11"></a>Solution</h4>
<div class="paragraph">
<p>Look for common programming idioms that expose the way clients make use of the class interface. Generalize your observations in the form of <em>contracts</em>, <em>i.e.</em>, explicit declarations of what a class expects from its clients.</p>
</div>
<div class="sect4">
<h5 id="hints-9"><a class="anchor" href="#hints-9"></a>Hints</h5>
<div class="paragraph">
<p>Your goal here is to understand how classes collaborate by exposing the way in which the interface to a class is used by its different clients. Since an exhaustive analysis of the code will probably exhaust you, you need some way to expose the contracts without stepping through every single line of code.</p>
</div>
<div class="paragraph">
<p>Although contracts are only implicit in the code, most frequently there will be hints in the code that a particular relationship exists between various classes. These hints may manifest themselves as idioms particular to the programming language in use, conventions in use by the development team, or even common design patterns.</p>
</div>
<div class="paragraph">
<p>What precisely you should look for will depend on the context, but here are a few examples that are generally useful:</p>
</div>
<div class="paragraph">
<p><em>Use Your Tools.</em> To get an overview of the relationships between classes, make the best use you can of the available tools. Although you could analyze the code by hand to infer relationships between classes, the process is tedious when applied to <em>more than a couple of classes</em>.</p>
</div>
<div class="paragraph">
<p>Many organizations use design extraction or round-trip engineering tools to document their systems. You can easily generate a draft view of the system you are analyzing without investing too much time. However, be prepared to be flooded with âboxes and arrowsâ diagrams containing irrelevant detail. Nevertheless, design extraction tools let you specify filters and ways to interpret code, so once your mappings are defined you can reuse them over multiple extractions.</p>
</div>
<div class="paragraph">
<p>The design overview can help you to identify key classes in the hierarchy (<em>i.e.</em>, abstract classes that many other classes inherit from), part-whole relationships, and so on.</p>
</div>
<div class="paragraph">
<p><em>Look for Key Methods.</em> Focus on the most important methods. With your knowledge of the system you will recognize key methods based on their signature.</p>
</div>
<div class="ulist">
<ul>
<li>
<p><em>Method Names.</em> Key methods are likely to bear intention revealing names [Bec97].</p>
</li>
<li>
<p><em>Parameter types.</em> Methods taking parameters with types corresponding to key classes in the system are likely to be important.</p>
</li>
<li>
<p><em>Recurring parameter types.</em> Parameters represent temporary associations between objects. When the same parameter types often recur in method signatures, they are likely to represent important associations.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p><em>Look For Constructor Calls.</em> To understand how and when to instantiate objects of a particular class, look for methods in other classes invoking the constructors.</p>
</div>
<div class="paragraph">
<p>Pay particular attention to which parameters are passed to the constructor, and whether the parameters are shared or not. This will help you determine which instance variables are parts of the constructed object, and which are merely references to shared objects.</p>
</div>
<div class="paragraph">
<p>Invocations of constructor methods may reveal a <em>part-whole relationship</em>. When a client stores the result of a constructor method in an attribute then this client will probably serve as the whole. On the other hand, when a client passes itself as an argument to a constructor method it is likely to act as a part.</p>
</div>
<div class="paragraph">
<p>Invocations of a constructor method may also expose a Factory Method [p. 293] or even an Abstract Factory [p. 293]. If they do, then you know that you will be able extend the system by subclassing the class under study.</p>
</div>
<div class="paragraph">
<p><em>Look for Template/Hook Methods.</em> To understand how to specialize a class, look for (protected) methods that are overridden by subclasses, and identify the public methods that call them. The public, calling method is almost certainly a Template Method [p. 296]. Check the class hierarchy to determine whether the overridden method is <em>abstract</em>, in which case subclasses must implement it, or whether a default implementation is provided. In the latter case, it is a <em>hook method</em>, and subclasses may choose to override it or be happy with the default.</p>
</div>
<div class="paragraph">
<p>For each template method check all other methods it invokes as these are likely to represent other hook methods.</p>
</div>
<div class="paragraph">
<p><em>Look for Super Calls.</em> To understand what assumptions a class makes about its subclasses, look for super calls. Super calls may be used by subclasses to extend an inherited method in an <em>ad hoc</em> way. But very often super calls express the fact that a particular method <em>must not be overridden by subclasses</em> unless the overridden method is explicitly invoked by a super call.</p>
</div>
<div class="paragraph">
<p>This idiom is heavily used in Java by classes that define multiple constructors. Any subclass of java.lang.Exception, for example, is expected to define both a default constructor and a constructor that takes a String argument. Those constructors should do nothing in particular except invoke the super constructor so that the exception subclass will be correctly initialized.</p>
</div>
</div>
</div>
<div class="sect3">
<h4 id="tradeoffs-11"><a class="anchor" href="#tradeoffs-11"></a>Tradeoffs</h4>
<div class="sect4">
<h5 id="pros-11"><a class="anchor" href="#pros-11"></a>Pros</h5>
<div class="ulist">
<ul>
<li>
<p><em>Reliable.</em> You can trust the source code more than the documentation.</p>
</li>
</ul>
</div>
</div>
<div class="sect4">
<h5 id="cons-11"><a class="anchor" href="#cons-11"></a>Cons</h5>
<div class="ulist">
<ul>
<li>
<p><em>Bad habits linger.</em> Just because certain practices appear in the code doesnât mean thatâs the right way to do things. The contracts that clients and subclasses adhere to are not necessarily the ones that the class actually supports.</p>
</li>
<li>
<p><em>Noise.</em> Browsing the source code is like mining â once in a while you will find a gem but you will have to dig through a lot of dirt first. By focusing your attention on idiomatic usages, you should be able to reduce the noise factor to a large degree.</p>
</li>
</ul>
</div>
</div>
</div>
<div class="sect3">
<h4 id="known-uses-10"><a class="anchor" href="#known-uses-10"></a>Known Uses</h4>
<div class="paragraph">
<p>Many researchers have investigated ways to analyze how clients use a class interface. For instance, Brown [Bro96], Florijn [FMvW97] and Wuyts [Wuy98] have all shown that it is possible to find symptoms of design patterns in code. Also, Schauer <em>et al.</em> [SRMK99] report about a technique to semi-automatically detect hook methods based on analysis of overridden methods. The latter technique scales quite well, due to their particular way of visualizing class hierarchies and emphasizing classes where many methods are overridden, hence are likely to define hook methods. Additionally, Steyaert <em>et al.</em> [SLMD96] have shown that it is possible to capture how subclasses depend on their superclasses (they have named these dependencies <em>reuse contracts</em>) and afterwards detect potential conflicts when the superclasses gets changed.</p>
</div>
</div>
<div class="sect3">
<h4 id="what-next-13"><a class="anchor" href="#what-next-13"></a>What Next</h4>
<div class="paragraph">
<p>One way to validate the contracts you have identified is to Step Through the Execution. Conversely, as you Step Through the Execution you will uncover collaborations between various objects. At that point you may Look for the Contracts that govern those collaborations.</p>
</div>
<div class="paragraph">
<p>If the code is hard to read, you may wish to Refactor to Understand before you Look for the Contracts. To understand how the contracts evolved to their current state, you might Learn from the Past.</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="learn-from-the-past"><a class="anchor" href="#learn-from-the-past"></a>5.5 Learn from the Past</h3>
<div class="paragraph">
<p><strong>Intent</strong> <em>Obtain insights into the design by comparing subsequent versions of the system.</em></p>
</div>
<div class="sect3">
<h4 id="problem-12"><a class="anchor" href="#problem-12"></a>Problem</h4>
<div class="paragraph">
<p>How can you discover why the system is designed the way it is? How can you learn which parts of the system are stable and which parts arenât?</p>
</div>
<div class="paragraph">
<p><em>This problem is difficult because:</em></p>
</div>
<div class="ulist">
<ul>
<li>
<p>The lessons learned during a development process are rarely recorded in documentation. Furthermore, the developersâ perceptions and memory of design decisions tend to warp over time. Therefore, you can only rely on source code and must reconstruct the learning process from there.</p>
</li>
<li>
<p>The system is large and has been released in successive versions, and therefore you have a large quantity of source code to analyze. Text comparison tools (such as Unix diff) will not scale up for the sizes youâre dealing with.</p>
</li>
<li>
<p>Even if you have a tool to identify the changes between two subsequent releases, most of the changes will concern adding <em>new</em> functionality. For the reconstruction of the learning process and how this consolidated into the class design, youâre main interest lies in what happened with the <em>old</em> functionality.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p><em>Yet, solving this problem is feasible because:</em></p>
</div>
<div class="ulist">
<ul>
<li>
<p>You have a <em>good understanding</em> of the systemâs structure (for example obtained via Initial Understanding), so youâre able to focus on appropriate subsystems.</p>
</li>
<li>
<p>You have access to the <em>subsequent releases</em> of the system, so you can reconstruct the changes by comparing the source code of the versions.</p>
</li>
<li>
<p>You have the means to examine what happened with individual source code entities. For instance, you have a <em>metrics tool</em> at your disposal, which allows you to quantify the size of entities in the sourcecode and use these numbers as a basis for comparison. As an alternative, you have a <em>configuration management</em> system that can provide you with information about particular changes to source-code entities.</p>
</li>
<li>
<p>You have enough <em>expertise with refactorings</em> in the implementation language being used, so you are able to recognize refactorings from their effects on source-code. Moreover, once you know which refactorings have been applied, you can use this expertise to make an educated guess at the underlying design rationale.</p>
</li>
<li>
<p>You have a <em>source-code browser</em> that allows you to query which methods invoke a given operation (even for polymorphic operations), so you can find out dependencies between classes and investigate how they are affected by the refactorings.</p>
</li>
</ul>
</div>
</div>
<div class="sect3">
<h4 id="solution-12"><a class="anchor" href="#solution-12"></a>Solution</h4>
<div class="paragraph">
<p>Use the metrics or configuration management tool to find entities where functionality has been <em>removed</em>, because such entities are a sign of a consolidating design. Also, look for entities which change often as these may point you to an unstable part of the design.</p>
</div>
<div class="sect4">
<h5 id="hints-10"><a class="anchor" href="#hints-10"></a>Hints</h5>
<div class="paragraph">
<p>Your goal is to get a feeling for how and why the system has evolved to its current state. In particular, you want to understand which parts of the system have been heavily refactored, which parts have become stable, and which parts are hot spots of activity.</p>
</div>
<div class="paragraph">
<p>Portions of the software system that have been heavily extended are simply a sign of growth, not of evolution of the design. On the other hand, portions where software has been <em>removed</em> are signs that the design of the system has been altered. By understanding how it has been altered, you can obtain insights into the stability of the design.</p>
</div>
<div class="paragraph">
<p><em>Unstable design.</em> If you detect repeated growth and refactoring in the same portion of the system, that should be a sign that the design is unstable. It may indicate opportunities to redesign that portion of the system to better accommodate the kinds of changes and extensions that habitually take place.</p>
</div>
<div class="paragraph">
<p><em>Mature and stable design.</em> A mature subsystem will exhibit some growth and refactoring, followed by a period of stability. Early versions of the subsystem will show growth followed by refactoring, followed by a period in which only new classes and subclasses are added. As the hierarchy stabilizes, classes near the top of the hierarchy will exhibit only moderate growth, but little refactoring.</p>
</div>
</div>
</div>
<div class="sect3">
<h4 id="tradeoffs-12"><a class="anchor" href="#tradeoffs-12"></a>Tradeoffs</h4>
<div class="sect4">
<h5 id="pros-11"><a class="anchor" href="#pros-11"></a>Pros</h5>
<div class="ulist">
<ul>
<li>
<p><em>Concentrates on important design artifacts,</em> because the changes point you to those places where the design is expanding or consolidating and this in turn provides insight into the underlying design rationale.</p>
</li>
<li>
<p><em>Provides an unbiased view of the system,</em> because you do not have to formulate assumptions about what to expect in the software (in contrast to top-down techniques like Speculate about Design [p. 87]).</p>
</li>
</ul>
</div>
</div>
<div class="sect4">
<h5 id="cons-12"><a class="anchor" href="#cons-12"></a>Cons</h5>
<div class="ulist">
<ul>
<li>
<p><em>Requires considerable experience,</em> in the sense that the reverse engineer must be well aware of how the refactorings interact with the coding idioms in the particular implementation language.</p>
</li>
<li>
<p><em>Considerable tool support is required,</em> especially (a) a metrics tool or a configuration management system; (b) a code browsers that is able to trace back polymorphic method invocations.</p>
</li>
</ul>
</div>
</div>
<div class="sect4">
<h5 id="difficulties-11"><a class="anchor" href="#difficulties-11"></a>Difficulties</h5>
<div class="ulist">
<ul>
<li>
<p><em>Imprecise for many changes,</em> because when too many changes have been applied on the same piece of code, it becomes difficult to reconstruct the change process.</p>
</li>
<li>
<p><em>Sensitive to renaming,</em> if one identifies classes and methods via their name<sup class="footnote">[<a id="_footnoteref_5" class="footnote" href="#_footnote_5" title="View footnote.">5</a>]</sup>. Then rename operations will show up as removals and additions which makes interpreting the data more difficult.</p>
</li>
</ul>
</div>
</div>
</div>
<div class="sect3">
<h4 id="rationale-8"><a class="anchor" href="#rationale-8"></a>Rationale</h4>
<div class="paragraph">
<p>Many object-oriented systems came into being via a combination of iterative and incremental development (see [Boo94] [GR95] [JGJ97] [Ree96]). That is, the original development team recognized their lack of problem domain expertise and therefore invested in a learning process where each learning phase resulted in a new system release. It is worthwhile to reconstruct that learning process because it will help you to understand the rationale embodied in the system design.</p>
</div>
<div class="paragraph">
<p>One way to reconstruct the learning process is to recover its primitive steps. In object-oriented parlance, these steps are called refactorings and consequently this pattern tells you how to recover refactorings like they have been applied in the past. The technique itself compares two subsequent releases of the source code identifying entities that decrease in size, because thatâs the typical symptom of functionality that has been moved elsewhere.</p>
</div>
</div>
<div class="sect3">
<h4 id="known-uses-11"><a class="anchor" href="#known-uses-11"></a>Known Uses</h4>
<div class="paragraph">
<p>We ran an experiment on three medium-sized systems implemented in Smalltalk. As reported in [DDN00], these case studies suggest that some simple heuristics can support the reverse engineering process by focusing attention on parts of the system where functionality has been removed. This way, we could for instance detect where a class had been split or where methods have been moved to a sibling class. Of course these refactorings must be examined in further detail to guess the intent behind the refactoring. This is never easy but in our experience has proven worthwhile. In one particular case for instance, we discovered several classes where methods had been moved to sibling classes. Closer examination revealed that the reengineer was moving these methods to break circular dependencies and was in fact introducing a layer.</p>
</div>
<div class="paragraph">
<p>Other researchers also report on examining changes to support the reverse engineering process. For instance, Ball <em>et al.</em> annotate code views with colors showing code age [BE96]. On the other hand, Jazayeri <em>et al.</em> use a three-dimensional visual representation for examining a systemâs software release history [JGR99]. The same people have also investigated which change requests affect which software modules to detect logical dependencies between software modules [GHJ98].</p>
</div>
</div>
<div class="sect3">
<h4 id="what-next-14"><a class="anchor" href="#what-next-14"></a>What Next</h4>
<div class="paragraph">
<p>Now that you discovered some stable parts in the design, you will probably want to reuse them. In that case take some precautions: first document the interfaces of that part (see Look for the Contracts) and then write the corresponding test cases (see Test the Interface, Not the Implementation [p. 155]).</p>
</div>
<div class="paragraph">
<p>On the other hand, the unstable parts of the design should probably be dismissed. Nevertheless, if the unstable part seems crucial for your reengineering project, then you must seek which change requests caused the instability. In that case, Chat with the Maintainers [p. 38] or even Interview During Demo [p. 59] and based on this knowledge decide how to restructure that part so that it is better suited for the kind of change requests that come in.</p>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="tests-your-life-insurance"><a class="anchor" href="#tests-your-life-insurance"></a>6. Tests: Your Life Insurance!</h2>
<div class="sectionbody">
<div class="paragraph">
<p>You are at the beginning of a reengineering project. You know that you will have to perform radical surgery on many parts of a valuable legacy system. You are wondering how you will be able to minimize the risks of changing a system on which your business depends: the risk of <em>breaking features</em> that used to work, the risk of <em>spending too much effort on the wrong tasks</em>, the risk of <em>failing to integrate needed new functionality</em> into the system, and the risk of <em>further increasing maintenance costs</em>.</p>
</div>
<div class="paragraph">
<p>The patterns presented in this cluster present effective ways of using tests in a reengineering context to reduce the risks posed by reengineering changes.</p>
</div>
<div class="paragraph">
<p><em>Caveat.</em> Testing is a rich and important subject that can scarcely be covered in any depth in the few pages we devote to it in this chapter. We have done no more than identify a few of the more significant testing patterns that are especially relevant to reengineering projects, and briefly sketch out some of the key issues. Binder, for example, devotes an entire book to testing object-oriented systems [Bin99].</p>
</div>
<div class="sect2">
<h3 id="forces-4"><a class="anchor" href="#forces-4"></a>Forces</h3>
<div class="paragraph">
<p>These patterns share common forces that concern various elements of risk for the evolution of the legacy system. Each pattern addresses some of these forces in order to achieve a certain balance between effort and risk.</p>
</div>
<div class="sect3">
<h4 id="reengineering-forces"><a class="anchor" href="#reengineering-forces"></a>Reengineering Forces</h4>
<div class="ulist">
<ul>
<li>
<p>Legacy systems often do not have test procedures defined.</p>
</li>
<li>
<p>Changing parts of a system without introducing new bugs is a challenging task.</p>
</li>
</ul>
</div>
</div>
<div class="sect3">
<h4 id="system-development-forces"><a class="anchor" href="#system-development-forces"></a>System Development Forces</h4>
<div class="ulist">
<ul>
<li>
<p>Not every aspect of a system can be tested.</p>
</li>
<li>
<p>Certain aspects are like concurrency and user interfaces are difficult to test.</p>
</li>
<li>
<p>Under time pressure, writing tests is always the task that is eliminated first.</p>
</li>
<li>
<p>Having all the knowledge of a system concentrated in only a few people poses a high risk for the future of the project.</p>
</li>
</ul>
</div>
</div>
<div class="sect3">
<h4 id="human-forces-customers"><a class="anchor" href="#human-forces-customers"></a>Human Forces (customers)</h4>
<div class="ulist">
<ul>
<li>
<p>Customers ultimately do not pay for tests but for new features in the system.</p>
</li>
<li>
<p>An unstable or buggy system is not acceptable for customers.</p>
</li>
</ul>
</div>
</div>
<div class="sect3">
<h4 id="human-forces-developers"><a class="anchor" href="#human-forces-developers"></a>Human Forces (developers)</h4>
<div class="ulist">
<ul>
<li>
<p>Programmers believe they do not need tests, since they write good code.</p>
</li>
<li>
<p>Programmers are not motivated by long term goals since they may leave the project in a month from now.</p>
</li>
<li>
<p>Programmers are more interested in tools and processes that can reduce the time they are losing in identifying problems.</p>
</li>
<li>
<p>Fixing bugs is not fun.</p>
</li>
<li>
<p>Writing tests is not considered to be a noble task.</p>
</li>
</ul>
</div>
</div>
</div>
<div class="sect2">
<h3 id="overview-4"><a class="anchor" href="#overview-4"></a>Overview</h3>
<div class="paragraph">
<p>As shown in Figure 6.1, Write Tests to Enable Evolution is the root of this cluster. It explains why systematic tests are critical to reengineering projects and what kinds of tests are necessary. It is based on Grow Your Test Base Incrementally which advocates strategies for introducing new tests as you need them.</p>
</div>
<div class="paragraph">
<p>In order to effectively manage incremental introduction of tests, it is important to Use a Testing Framework to structure and organize suites</p>
</div>
<div class="paragraph">
<p><span class="image"><img src="./media/image18.jpg" alt="image" width="432" height="346"></span></p>
</div>
<div class="paragraph">
<p>Figure 6.1: When, why, how and what to test. of tests. The testing framework should support you in designing certain styles of tests. In particular, if you Test the Interface, Not the Implementation of components, by using black-box testing strategies, then your tests will tend to be more useful in the face of system changes. Furthermore, if you can Record Business Rules as Tests, then you will have an effective way to keep the business rules explicitly represented and continuously synchronized with the running system even in the presence of radical changes.</p>
</div>
<div class="paragraph">
<p>Tests may be introduced at various times for various reasons. Write Tests to Understand advocates investing testing effort in those parts of the system that you need to understand in order to implement changes. More specifically, it is a good idea to Test Fuzzy Features, to Test Old Bugs, and especially to Retest Persistent Problems.</p>
</div>
<div class="paragraph">
<p>The patterns in this cluster directly support Migration Strategies [p. 165] for reengineering: Regression Test After Every Change [p. 182] helps you build confidence by ensuring that everything still runs after every incremental change to the system. In effect, tests are a necessary precondition to Always Have a Running Version [p. 180], and they enable you to Migrate Systems Incrementally [p. 174].</p>
</div>
</div>
<div class="sect2">
<h3 id="write-tests-to-enable-evolution"><a class="anchor" href="#write-tests-to-enable-evolution"></a>6.1 Write Tests to Enable Evolution</h3>
<div class="paragraph">
<p><strong>Intent</strong> <em>Protect your investment in the legacy code by imposing a systematic testing program.</em></p>
</div>
<div class="sect3">
<h4 id="problem-13"><a class="anchor" href="#problem-13"></a>Problem</h4>
<div class="paragraph">
<p>How do you minimize the risks of a reengineering project, specifically, the risks of:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>failing to simplify the legacy system,</p>
</li>
<li>
<p>introducing yet more complexity to the system,</p>
</li>
<li>
<p>breaking features that used to work,</p>
</li>
<li>
<p>spending too much effort on the wrong tasks,</p>
</li>
<li>
<p>failing to accommodate future change.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p><em>This problem is difficult because:</em></p>
</div>
<div class="ulist">
<ul>
<li>
<p>Impact of changes cannot always be predicted because parts of the system may not be well-understood or may have hidden dependencies.</p>
</li>
<li>
<p>Any change to a legacy system may destabilize it due to undocumented aspects or dependencies.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p><em>Yet, solving this problem is feasible because:</em></p>
</div>
<div class="ulist">
<ul>
<li>
<p>You have a running system, so you can determine what works and what doesnât work.</p>
</li>
<li>
<p>You know which parts of the system are stable, and which are subject to change.</p>
</li>
</ul>
</div>
</div>
<div class="sect3">
<h4 id="solution-13"><a class="anchor" href="#solution-13"></a>Solution</h4>
<div class="paragraph">
<p>Introduce a testing process based on tests that are automated, repeatable and stored.</p>
</div>
<div class="sect4">
<h5 id="hints-11"><a class="anchor" href="#hints-11"></a>Hints</h5>
<div class="paragraph">
<p>Well-designed tests exhibit the following properties:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><em>Automation.</em> Tests should run without human intervention. Only fully automated tests offer an efficient way to check after every change to the system whether it still works as it did before. By minimizing the effort needed to run tests, developers will hesitate less to use them.</p>
</li>
<li>
<p><em>Persistence.</em> Tests must be stored to be automatable. Each test documents its test data, the actions to perform, and the expected results. A test succeed if the expected result is obtained, otherwise it fails. Stored tests document the way the system is expected to work.</p>
</li>
<li>
<p><em>Repeatability.</em> Confidence in the system is increased if tests can be repeated after any change is implemented. Whenever new functionality is added, new tests can be added to the pool of existing tests, thereby increasing the confidence in the system.</p>
</li>
<li>
<p><em>Unit testing.</em> Tests should be associated to individual software components so that they identify clearly which part of the system they test [Dav95].</p>
</li>
<li>
<p><em>Independence.</em> Each test should minimize its dependencies on other tests. Dependent tests typically result in avalanche effects: when one test breaks, many others break as well. It is important that the number of failures represent quantitatively the size of the detected problems. This minimizes distrust in the tests. Programmers should believe in tests.</p>
</li>
</ul>
</div>
</div>
</div>
<div class="sect3">
<h4 id="tradeoffs-13"><a class="anchor" href="#tradeoffs-13"></a>Tradeoffs</h4>
<div class="sect4">
<h5 id="pros-12"><a class="anchor" href="#pros-12"></a>Pros</h5>
<div class="ulist">
<ul>
<li>
<p>Tests increase your confidence in the system, and improve your ability to change the functionality, the design and even the architecture of the system in a behavior-preserving way.</p>
</li>
<li>
<p>Tests document how artifacts of a system are to be used. In contrast to written documentation, running tests are an always up-to-date description of the system.</p>
</li>
<li>
<p>Selling testing to clients who are concerned by security and stability is not usually a problem. Assuring long term life of the system is also a good argument.</p>
</li>
<li>
<p>Tests provide the necessary climate for enabling future system evolution.</p>
</li>
<li>
<p>Simple unit testing frameworks exist for all the main object-oriented languages like Smalltalk, Java, C++ and even Perl.</p>
</li>
</ul>
</div>
</div>
<div class="sect4">
<h5 id="cons-13"><a class="anchor" href="#cons-13"></a>Cons</h5>
<div class="ulist">
<ul>
<li>
<p>Tests do not come for free. Resources must be allocated to write them.</p>
</li>
<li>
<p>Tests can only demonstrate the presence of defects. It is impossible to test all the aspects of a legacy system (or any system, for that matter).</p>
</li>
<li>
<p>Inadequate tests will give you false confidence. You may think your system is working well because all the tests run, but this might not be the case at all.</p>
</li>
</ul>
</div>
</div>
<div class="sect4">
<h5 id="difficulties-12"><a class="anchor" href="#difficulties-12"></a>Difficulties</h5>
<div class="ulist">
<ul>
<li>
<p>A plethora of testing approaches exists. Choose a simple approach that fits your development process.</p>
</li>
<li>
<p>Testing legacy systems is difficult because they tend to be large and undocumented. Sometimes testing a part of a system requires a large and complex set-up procedure, which may seem prohibitive.</p>
</li>
<li>
<p>Management may be reluctant to invest in testing. Here are some arguments in favor of testing:</p>
<div class="ulist">
<ul>
<li>
<p>Testing helps to improve the safety of the system.</p>
</li>
<li>
<p>Tests represent a tangible form of confidence in the system functionality.</p>
</li>
<li>
<p>Debugging is easier when automated tests exist.</p>
</li>
<li>
<p>Tests are simple documentation that is always in sync with the application.</p>
</li>
</ul>
</div>
</li>
<li>
<p>Developers may be reluctant to adopt testing. Build a business case to show them that tests will not only speed up todayâs development, but they will speed up future maintenance efforts. Once we discussed with a developer who spent one day fixing a bug and then three days more checking if the changes he made were valid. When we showed him that automated tests could help him in his daily work to debug his program more quickly, he was finally convinced.</p>
</li>
<li>
<p>Testing can be boring for developers so at least use the right tools. For unit testing, SUnit and its many variants are simple, free and available for Smalltalk, C++, Java and other languages [BG98].</p>
</li>
</ul>
</div>
</div>
</div>
<div class="sect3">
<h4 id="example-8"><a class="anchor" href="#example-8"></a>Example</h4>
<div class="paragraph">
<p>The following code illustrates a unit test written using JUnit in Java[BG98]. The test checks that the add operation defined on a class Money works as expected, namely that 12 CHF + 14 CHF = 26 CHF.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="directive">public</span> <span class="type">class</span> <span class="class">MoneyTest</span> <span class="directive">extends</span> TestCase { <span class="directive">public</span> <span class="type">void</span> testSimpleAdd() {

   Money m12CHF= <span class="keyword">new</span> Money(<span class="integer">12</span>, <span class="string"><span class="delimiter">&quot;</span><span class="content">CHF</span><span class="delimiter">&quot;</span></span>); <span class="comment">// (1)</span>
   Money m14CHF= <span class="keyword">new</span> Money(<span class="integer">14</span>, <span class="string"><span class="delimiter">&quot;</span><span class="content">CHF</span><span class="delimiter">&quot;</span></span>);
   Money expected= <span class="keyword">new</span> Money(<span class="integer">26</span>, <span class="string"><span class="delimiter">&quot;</span><span class="content">CHF</span><span class="delimiter">&quot;</span></span>);
   Money result= m12CHF.add(m14CHF); <span class="comment">// (2)</span>

   <span class="keyword">assert</span>(result.currency().equals(expected.currency()) &amp;&amp;
          result.amount() == expected.amount()); <span class="comment">// (3)</span>

}

}</code></pre>
</div>
</div>
<div class="paragraph">
<p>This satisfies the properties that a test should have:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>This test is automated: It returns boolean value true if the action is the right one and false otherwise.</p>
</li>
<li>
<p>It is stored: it is a method of a test class. So it can be versioned like any other code.</p>
</li>
<li>
<p>It is repeatable: its initialization part ()1) produces the context in which the test can be run and rerun indefinitely.</p>
</li>
<li>
<p>It is independent of the other tests.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Using tests having these properties helps you to build a test suite for the long term. Every time you write a test, either after a bug fix or adding a new feature, or to test an already existing aspect of the system, you are adding <em>reproducible</em> and <em>verifiable</em> information about your system into your test suite. Especially in the context of reengineering a system this fact is important, because this reproducible and verifiable information can be checked after any change to see if aspects of a system are compromised.</p>
</div>
</div>
<div class="sect3">
<h4 id="rationale-9"><a class="anchor" href="#rationale-9"></a>Rationale</h4>
<div class="paragraph">
<p>Tests represent confidence in a system, because they specify how parts of the system work in a <em>verifiable</em> way, and because they can be run at any time to check if the system is still consistent.</p>
</div>
<div class="paragraph">
<p><em>â&#8230;&#8203; testing simply exposes the presence of flaws in a program; it cannot be used to verify the absence of flaws. It can increase your confidence that a program is correctâ</em></p>
</div>
<div class="paragraph">
<p>Figure 6.2: Automated tests are the <em>foundation</em> for reengineering. They establish your confidence in the system, reduce risks, and improve confidence in your ability to change the system.</p>
</div>
<div class="paragraph">
<p>â Alan Davis, Principle 111 [Dav95]</p>
</div>
<div class="paragraph">
<p>Systematic testing is heavily promoted by Extreme Programming [Bec00] one of the basic techniques necessary to be able to adapt programs quickly to changing requirements. Changing legacy systems is risky business. Will the code still work after a change? How many unexpected sideeffects will appear? Having a set of automated, repeatable tests helps to reduce this risk.</p>
</div>
<div class="ulist">
<ul>
<li>
<p>A set of running tests provides confidence in the system. (âAre you really sure this piece of code works?â âYes, look, here I have the tests that prove it.â)</p>
</li>
<li>
<p>A set of running tests represents <em>reproducible</em> and <em>verifiable</em> information about your system, and is at all times in sync with the application. This in contrast to most of the written documentation, which is typically slightly outdated already the next day.</p>
</li>
<li>
<p>Writing tests increases productivity, because bugs are found much earlier in the development process.</p>
</li>
</ul>
</div>
</div>
<div class="sect3">
<h4 id="related-patterns-4"><a class="anchor" href="#related-patterns-4"></a>Related Patterns</h4>
<div class="paragraph">
<p>Write Tests to Enable Evolution is a prerequisite to Always Have a Running Version [p. 180]. Only with a comprehensive test program in place can you Migrate Systems Incrementally [p. 174].</p>
</div>
<div class="paragraph">
<p>Grow Your Test Base Incrementally and Test the Interface, Not the Implementation introduce a way to incrementally build a test suite while a system is evolving.</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="grow-your-test-base-incrementally"><a class="anchor" href="#grow-your-test-base-incrementally"></a>6.2 Grow Your Test Base Incrementally</h3>
<div class="paragraph">
<p><strong>Intent</strong> <em>Balance the costs and the benefits of tests by incrementally introducing just the tests you need at a given point in time.</em></p>
</div>
<div class="sect3">
<h4 id="problem-14"><a class="anchor" href="#problem-14"></a>Problem</h4>
<div class="paragraph">
<p>When should you start to introduce tests? When can you stop?</p>
</div>
<div class="paragraph">
<p><em>This problem is difficult because:</em></p>
</div>
<div class="ulist">
<ul>
<li>
<p>In a reengineering project, you cannot afford to spend too much time for writing tests.</p>
</li>
<li>
<p>Legacy systems tend to be huge, so testing everything is impossible.</p>
</li>
<li>
<p>Legacy systems tend to be poorly-documented and poorlyunderstood.</p>
</li>
<li>
<p>The original developers may have left and the system maintainers may have only limited knowledge of the systemâs inner workings.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p><em>Yet, solving this problem is feasible because:</em></p>
</div>
<div class="ulist">
<ul>
<li>
<p>We know where the fragile parts or the parts that we would like to change are.</p>
</li>
<li>
<p>We could convince programmers that they can benefit from tests.</p>
</li>
</ul>
</div>
</div>
<div class="sect3">
<h4 id="solution-14"><a class="anchor" href="#solution-14"></a>Solution</h4>
<div class="paragraph">
<p>Introduce tests incrementally for parts of the system you are working on.</p>
</div>
<div class="sect4">
<h5 id="hints-12"><a class="anchor" href="#hints-12"></a>Hints</h5>
<div class="ulist">
<ul>
<li>
<p>Carefully assess your priorities and initially develop tests only for the most critical components. As you reengineer the system, introduce tests for the new features, parts of the legacy that may be affected, and any bugs you identify along the way.</p>
</li>
<li>
<p>Keep a snapshot of the old system handy so you can later introduce tests that should run against both the original system and its new incarnation.</p>
</li>
<li>
<p>Focus on business values. Start to write tests for the parts of your system that have the most important artifacts. Try to Record Business Rules as Tests.</p>
</li>
<li>
<p>If you have the history of bug fixes or problems, apply Test Old Bugs [p. 290] as a starting point.</p>
</li>
<li>
<p>If you have acceptable documentation and some original developers of the system at hand, consider applying Test Fuzzy Features [p. 290].</p>
</li>
<li>
<p>Apply Test the Interface, Not the Implementation, start to test big abstractions and then refine tests if time allows. For example, if you have a pipeline architecture, start to write tests that ensure you that the output of the full pipeline is right given the right input. Then write tests for the individual pipeline components.</p>
</li>
<li>
<p>Black-box test parts (subsystems, classes, methods) that are likely to change their implementation in the future.</p>
</li>
</ul>
</div>
</div>
</div>
<div class="sect3">
<h4 id="tradeoffs-14"><a class="anchor" href="#tradeoffs-14"></a>Tradeoffs</h4>
<div class="sect4">
<h5 id="pros-13"><a class="anchor" href="#pros-13"></a>Pros</h5>
<div class="ulist">
<ul>
<li>
<p>You save time by only developing the tests that you need.</p>
</li>
<li>
<p>You build up a base of the most critical tests as the project progresses.</p>
</li>
<li>
<p>You build confidence as you go along</p>
</li>
<li>
<p>You streamline future development and maintenance activities.</p>
</li>
</ul>
</div>
</div>
<div class="sect4">
<h5 id="cons-14"><a class="anchor" href="#cons-14"></a>Cons</h5>
<div class="ulist">
<ul>
<li>
<p>You may guess wrong which aspects are critical to test.</p>
</li>
<li>
<p>Tests can give you false confidence â untested bugs can still lurk in the system.</p>
</li>
</ul>
</div>
</div>
<div class="sect4">
<h5 id="difficulties-13"><a class="anchor" href="#difficulties-13"></a>Difficulties</h5>
<div class="ulist">
<ul>
<li>
<p>Setting-up the proper context for the tests may require considerable time and effort.</p>
</li>
<li>
<p>Identifying the boundaries of the components to test is just hard. Deciding which parts to test and how fine-grained these tests should be, requires a good understanding of the system and the way you intend to reengineer it.</p>
</li>
</ul>
</div>
</div>
</div>
<div class="sect3">
<h4 id="example-9"><a class="anchor" href="#example-9"></a>Example</h4>
<div class="paragraph">
<p>Figure 6.3: Introduce tests for the parts of the system you intend to change.</p>
</div>
<div class="paragraph">
<p>Initially introduce tests only for the subsystems and component you intend to change. In Figure 6.3 we introduce some tests for subsystem ABC and for its component B. We apply Test the Interface, Not the Implementation to ensure that the tests for B should also pass for newB.</p>
</div>
<div class="paragraph">
<p>Note that if we only introduce tests for component B, then we fail to test its integration with A and C. In any case, it may be that we fail to test all important aspects, so it is important to incrementally add new tests as bugs are detected and repaired.</p>
</div>
</div>
<div class="sect3">
<h4 id="rationale-10"><a class="anchor" href="#rationale-10"></a>Rationale</h4>
<div class="paragraph">
<p>An incremental testing strategy allows you to start reengineering efforts before all the tests are in place. By focussing on just those tests that concern the parts of the system you are currently changing, you enable change with a minimal investment in testing, while help your team build confidence as you grow your tests base.</p>
</div>
</div>
<div class="sect3">
<h4 id="related-patterns-5"><a class="anchor" href="#related-patterns-5"></a>Related Patterns</h4>
<div class="paragraph">
<p>Use a Testing Framework to organize your tests.</p>
</div>
<div class="paragraph">
<p>Test the Interface, Not the Implementation provides a strategy for developing tests at arbitrary granularities. Record Business Rules as Tests provides another strategy for testing components that implement business logic. Write Tests to Understand helps you prime a test base while you are still reverse engineering the system.</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="use-a-testing-framework"><a class="anchor" href="#use-a-testing-framework"></a>6.3 Use a Testing Framework</h3>
<div class="paragraph">
<p><strong>Intent</strong> <em>Encourage developers to write and use regression tests by providing a framework that makes it easy to develop, organize and run tests.</em></p>
</div>
<div class="sect3">
<h4 id="problem-15"><a class="anchor" href="#problem-15"></a>Problem</h4>
<div class="paragraph">
<p>How do you encourage your team to adopt systematic testing?</p>
</div>
<div class="paragraph">
<p><em>This problem is difficult because:</em></p>
</div>
<div class="ulist">
<ul>
<li>
<p>Tests are boring to write.</p>
</li>
<li>
<p>Tests may require a considerable test data to be built up and torn down.</p>
</li>
<li>
<p>It may be hard to distinguish between test failures and unexpected errors.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p><em>Yet, solving this problem is feasible because:</em></p>
</div>
<div class="ulist">
<ul>
<li>
<p>Most tests follow the same basic pattern: create some test data, perform some actions, see if the results match your expectations, clean up the test data.</p>
</li>
<li>
<p>Very little infrastructure is needed to run tests and report failures and errors.</p>
</li>
</ul>
</div>
</div>
<div class="sect3">
<h4 id="solution-15"><a class="anchor" href="#solution-15"></a>Solution</h4>
<div class="paragraph">
<p>Use a testing framework that allows suites of tests to be composed from individual test cases.</p>
</div>
<div class="sect4">
<h5 id="steps-2"><a class="anchor" href="#steps-2"></a>Steps</h5>
<div class="paragraph">
<p>Unit testing frameworks, like JUnit and SUnit [BG98], and various commercial test harness packages are available for most programming languages. If a suitable testing framework is not available for the programming language you are using, you can easily brew your own according to the following principles:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>The user must provide test cases that set up test data, exercise them, and make assertions about the results</p>
</li>
<li>
<p>The testing framework should wrap test cases as tests which can distinguish between assertion failures and unexpected errors.</p>
</li>
<li>
<p>The framework should provide only minimal feedback if tests succeed.</p>
<div class="ulist">
<ul>
<li>
<p>Assertion failures should indicate precisely which test failed.</p>
</li>
<li>
<p>Errors should result in more detailed feedback (such as a full stack trace).</p>
</li>
</ul>
</div>
</li>
<li>
<p>The framework should allow tests to be composed as test suites.</p>
</li>
</ul>
</div>
</div>
</div>
<div class="sect3">
<h4 id="tradeoffs-15"><a class="anchor" href="#tradeoffs-15"></a>Tradeoffs</h4>
<div class="sect4">
<h5 id="pros-14"><a class="anchor" href="#pros-14"></a>Pros</h5>
<div class="ulist">
<ul>
<li>
<p>A testing framework simplifies the formulation of tests and encourages programmers to write tests and use them.</p>
</li>
</ul>
</div>
</div>
<div class="sect4">
<h5 id="cons-15"><a class="anchor" href="#cons-15"></a>Cons</h5>
<div class="ulist">
<ul>
<li>
<p>Testing requires commitment, discipline and support. You must convince your team of the need and benefits of disciplined testing, and you must integrate testing into your daily process. One way of supporting this discipline is to have one testing coach in your team; consider this when you Appoint a Navigator [p. 23].</p>
</li>
</ul>
</div>
</div>
</div>
<div class="sect3">
<h4 id="example-10"><a class="anchor" href="#example-10"></a>Example</h4>
<div class="paragraph">
<p>JUnit is a popular testing framework for Java, which considerable enhances the basic scheme described above. Figure 6.4 shows that the framework requires users to define their tests as subclasses of TestCase. Users must provide the methods setUp(), runTest() and tearDown(). The default implementation of setup() and tearDown() are empty, and the default implementation of runTest() looks for and runs a method which is the name of the test (given in the constructor). These user-supplied hook methods are then called by the runBare() template method.</p>
</div>
<div class="paragraph">
<p>JUnit manages the reporting of failures and errors with the help of an additional TestResult class. In the design of JUnit, it is an instance of TestResult that actually runs the tests and logs errors or failures. In Figure 6.5 we see a scenario in which a TestCase, in its run method, passes</p>
</div>
<div class="paragraph">
<p><span class="image"><img src="./media/image19.jpg" alt="image" width="432" height="280"></span></p>
</div>
<div class="paragraph">
<p>Figure 6.4: JUnit is a popular testing framework for Java that offers much more flexibility than the minimal scheme described above.</p>
</div>
<div class="paragraph">
<p>control to an instance of TestResult, which in turn calls the runBare template method of the TestCase.</p>
</div>
<div class="paragraph">
<p>TestCase additionally provides a set of different kinds of standard assertion methods, such as assertEquals, assertFails, and so on. Each of these methods throws an AssertionFailedError, which can be distinguished from any other kind of exception.</p>
</div>
<div class="paragraph">
<p>In order to use the framework, we will typically define a new class, say TestHashtable, that bundles a set of test suites for a given class, Hashtable, that we would like to test. The test class should extend junit.framework.TestCase:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="keyword">import</span> <span class="include">junit.framework</span>.*; <span class="keyword">import</span> <span class="include">java.util.Hashtable</span>; <span class="directive">public</span> <span class="type">class</span> <span class="class">TestHashtable</span> <span class="directive">extends</span> TestCase {</code></pre>
</div>
</div>
<div class="paragraph">
<p>The instance variables of the test class will hold the fixture - the actual test data:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="directive">private</span> <span class="predefined-type">Hashtable</span> boss; <span class="directive">private</span> <span class="predefined-type">String</span> joe = <span class="string"><span class="delimiter">&quot;</span><span class="content">Joe</span><span class="delimiter">&quot;</span></span>;</code></pre>
</div>
</div>
<div class="paragraph">
<p>Figure 6.5: In JUnit, tests are actually run by an instance of TestResult, which invokes the runBare template method of a TestCase. The user only needs to provide the setUp() and tearDown() methods, and the test method to be invoked by runTest().</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="directive">private</span> <span class="predefined-type">String</span> mary = <span class="string"><span class="delimiter">&quot;</span><span class="content">Mary</span><span class="delimiter">&quot;</span></span>;
<span class="directive">private</span> <span class="predefined-type">String</span> dave = <span class="string"><span class="delimiter">&quot;</span><span class="content">Dave</span><span class="delimiter">&quot;</span></span>;
<span class="directive">private</span> <span class="predefined-type">String</span> boris = <span class="string"><span class="delimiter">&quot;</span><span class="content">Boris</span><span class="delimiter">&quot;</span></span>;</code></pre>
</div>
</div>
<div class="paragraph">
<p>There should be constructor that takes the name of a test case as its parameter. Its behavior is defined by its superclass:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="directive">public</span> TestHashtable(<span class="predefined-type">String</span> name) {

<span class="local-variable">super</span>(name);

}</code></pre>
</div>
</div>
<div class="paragraph">
<p>The setUp() hook method can be overridden to set up the fixture. If there is any cleanup activity to be performed, we should also override tearDown(). Their default implementations are empty.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="directive">protected</span> <span class="type">void</span> setUp() <span class="error">\</span>{ boss = <span class="keyword">new</span> <span class="predefined-type">Hashtable</span>();

}</code></pre>
</div>
</div>
<div class="paragraph">
<p>We can then define any number of test cases that make use of the fixture. Note that each test case is independent, and will have a fresh copy of the fixture. (In principle, we should design tests that not only exercise the entire interface, but the test data should cover both typical and boundary cases. The sample tests shown here are far from complete.)</p>
</div>
<div class="paragraph">
<p>Each test case should start with the characters âtest":</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="directive">public</span> <span class="type">void</span> testEmpty() <span class="error">\</span>{ <span class="keyword">assert</span>(boss.isEmpty()); assertEquals(boss.size(), <span class="integer">0</span>); <span class="keyword">assert</span>(!boss.contains(joe));

<span class="keyword">assert</span>(!boss.containsKey(joe));
}

<span class="directive">public</span> <span class="type">void</span> testBasics() <span class="error">\</span>{ boss.put(joe, mary); boss.put(mary, dave); boss.put(boris, dave); <span class="keyword">assert</span>(!boss.isEmpty()); assertEquals(boss.size(), <span class="integer">3</span>); <span class="keyword">assert</span>(boss.contains(mary)); <span class="keyword">assert</span>(!boss.contains(joe)); <span class="keyword">assert</span>(boss.containsKey(mary)); <span class="keyword">assert</span>(!boss.containsKey(dave)); assertEquals(boss.get(joe), mary); assertEquals(boss.get(mary), dave); assertEquals(boss.get(dave), <span class="predefined-constant">null</span>);

}</code></pre>
</div>
</div>
<div class="paragraph">
<p>You may provide a static method suite() which will build an instance of junit.framework.TestSuite from the test cases defined by this class:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="directive">public</span> <span class="directive">static</span> TestSuite suite() { TestSuite suite = <span class="keyword">new</span> TestSuite(); suite.addTest(<span class="keyword">new</span> TestHashtable(<span class="string"><span class="delimiter">&quot;</span><span class="content">testBasics</span><span class="delimiter">&quot;</span></span>)); suite.addTest(<span class="keyword">new</span> TestHashtable(<span class="string"><span class="delimiter">&quot;</span><span class="content">testEmpty</span><span class="delimiter">&quot;</span></span>)); <span class="keyword">return</span> suite;

}

}</code></pre>
</div>
</div>
<div class="paragraph">
<p>The test case class should be compiled, together with any class it depends on.</p>
</div>
<div class="paragraph">
<p>To run the tests, we can start up any one of a number of <em>test runner</em> classes provided by the JUnit framework, for instance junit.ui.TestRunner (see Figure 6.6).</p>
</div>
<div class="paragraph">
<p>This particular test runner expects you to type in the name of the test class. You may then <em>run</em> the tests defined by this class. The test runner will look for the suite method and use it to build an instance of TestSuite. If you do not provide a static suite method, the test runner will automatically build a test suite assuming that all the methods named test* are test cases. The test runner then runs the resulting test suite.</p>
</div>
<div class="paragraph">
<p><span class="image"><img src="./media/image20.jpg" alt="image" width="345" height="265"></span></p>
</div>
<div class="paragraph">
<p>Figure 6.6: An instance of java.ui.TestRunner.</p>
</div>
<div class="paragraph">
<p><span class="image"><img src="./media/image21.jpg" alt="image" width="345" height="266"></span></p>
</div>
<div class="paragraph">
<p>Figure 6.7: A successful test run.</p>
</div>
<div class="paragraph">
<p>The interface will report how many tests succeeded (see Figure 6.7). A successful test run will show a green display. If any individual test fails, the display will be red, and details of the test case leading to the failure will be given.</p>
</div>
</div>
<div class="sect3">
<h4 id="rationale-11"><a class="anchor" href="#rationale-11"></a>Rationale</h4>
<div class="paragraph">
<p>A testing framework makes it easier to organize and run tests.</p>
</div>
<div class="paragraph">
<p>Hierarchically organizing tests makes it easier to run just the tests that concern the part of the system you are working on.</p>
</div>
</div>
<div class="sect3">
<h4 id="known-uses-12"><a class="anchor" href="#known-uses-12"></a>Known Uses</h4>
<div class="paragraph">
<p>Testing frameworks exist for a vast number of languages, including Ada,</p>
</div>
<div class="paragraph">
<p>ANT, C, C++, Delphi, .Net (all languages), Eiffel, Forte 4GL, GemStone/S,</p>
</div>
<div class="paragraph">
<p>Jade, JUnit Java, JavaScript, k language (ksql, from kbd), Objective C, Open Road (CA), Oracle, PalmUnit, Perl, PhpUnit, PowerBuilder, Python, Rebol, âRuby, Smalltalk, Visual Objects and UVisual Basic.</p>
</div>
<div class="paragraph">
<p>Beck and Gamma give a good overview in the context of JUnit [BG98].</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="test-the-interface-not-the-implementation"><a class="anchor" href="#test-the-interface-not-the-implementation"></a>6.4 Test the Interface, Not the Implementation</h3>
<div class="paragraph">
<p><em>Also Known As:</em> Black-Box Testing [Pre94]</p>
</div>
<div class="paragraph">
<p><strong>Intent</strong> <em>Build up reusable tests that focus on external behavior rather than on implementation details, and thereby will survive changes to the system.</em></p>
</div>
<div class="sect3">
<h4 id="problem-16"><a class="anchor" href="#problem-16"></a>Problem</h4>
<div class="paragraph">
<p>How can you develop tests that not only protect your software legacy, but also will continue to be valuable as the system changes?</p>
</div>
<div class="paragraph">
<p><em>This problem is difficult because:</em></p>
</div>
<div class="ulist">
<ul>
<li>
<p>Legacy systems have many features that should continue to function as the system evolves.</p>
</li>
<li>
<p>You cannot afford to spend too much time writing tests while reengineering the system.</p>
</li>
<li>
<p>You do not want to waste effort in developing tests that will have to be changed as you change the system.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p><em>Yet, solving this problem is feasible because:</em></p>
</div>
<div class="ulist">
<ul>
<li>
<p>The interfaces to the components of the system tell you what should be tested.</p>
</li>
<li>
<p>Interfaces tend to be more stable than implementations</p>
</li>
</ul>
</div>
</div>
<div class="sect3">
<h4 id="solution-16"><a class="anchor" href="#solution-16"></a>Solution</h4>
<div class="paragraph">
<p>Develop black-box tests that exercise the public interface of your components.</p>
</div>
<div class="sect4">
<h5 id="hints-13"><a class="anchor" href="#hints-13"></a>Hints</h5>
<div class="ulist">
<ul>
<li>
<p>Be sure to exercise boundary values (<em>i.e.</em>, minimum and maximum values for method parameters). The most common errors occur here.</p>
</li>
<li>
<p>Use a top-down strategy to develop black-box tests if there are many fine-grained components that you do not initially have time to develop tests for.</p>
</li>
<li>
<p>Use a bottom-up strategy if you are replacing functionality in a very focused part of the legacy system.</p>
</li>
</ul>
</div>
</div>
</div>
<div class="sect3">
<h4 id="tradeoffs-16"><a class="anchor" href="#tradeoffs-16"></a>Tradeoffs</h4>
<div class="sect4">
<h5 id="pros-15"><a class="anchor" href="#pros-15"></a>Pros</h5>
<div class="ulist">
<ul>
<li>
<p>Tests that exercise public interfaces are more likely to be reusable if the implementation changes.</p>
</li>
<li>
<p>Black-box tests can often be used to exercise multiple implementations of the same interface.</p>
</li>
<li>
<p>It is relatively easy to develop tests based on a componentâs interface.</p>
</li>
<li>
<p>Focusing on the external behavior reduces considerably the possible tests to be written while still covering the essential aspects of a system.</p>
</li>
</ul>
</div>
</div>
<div class="sect4">
<h5 id="cons-16"><a class="anchor" href="#cons-16"></a>Cons</h5>
<div class="ulist">
<ul>
<li>
<p>Back-box tests will not necessarily exercise all possible program paths. You may have to use a separate coverage tool to check whether your tests cover all the code.</p>
</li>
<li>
<p>If the interface to a component changes you will still have to adapt the tests.</p>
</li>
</ul>
</div>
</div>
<div class="sect4">
<h5 id="difficulties-14"><a class="anchor" href="#difficulties-14"></a>Difficulties</h5>
<div class="ulist">
<ul>
<li>
<p>Sometimes the class does not provide the right interface to support black-box testing. Adding accessors to sample the state of the object can be a simple solution, but this generally weakens encapsulation and makes the object less of a black box.</p>
</li>
</ul>
</div>
</div>
</div>
<div class="sect3">
<h4 id="example-11"><a class="anchor" href="#example-11"></a>Example</h4>
<div class="paragraph">
<p>Letâs look back at the test presented in Write Tests to Enable Evolution. The code we saw earlier was supposed to check whether the add operation defined on a class Money works as expected. However, we see that the assert in line (3) actually depends on the internal implementation of the Money class, because it checks for equality by accessing the parts of equality.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="directive">public</span> <span class="type">class</span> <span class="class">MoneyTest</span> <span class="directive">extends</span> TestCase <span class="error">\</span>{

<span class="comment">// ...</span>

<span class="directive">public</span> <span class="type">void</span> testSimpleAdd() <span class="error">\</span>{

Money m12CHF= <span class="keyword">new</span> Money(<span class="integer">12</span>, <span class="string"><span class="delimiter">&quot;</span><span class="content">CHF</span><span class="delimiter">&quot;</span></span>);

 |<span class="comment">// (1)</span>
a|
Money m14CHF= <span class="keyword">new</span> Money(<span class="integer">14</span>, <span class="string"><span class="delimiter">&quot;</span><span class="content">CHF</span><span class="delimiter">&quot;</span></span>);

Money expected= <span class="keyword">new</span> Money(<span class="integer">26</span>, <span class="string"><span class="delimiter">&quot;</span><span class="content">CHF</span><span class="delimiter">&quot;</span></span>);

Money result= m12CHF.add(m14CHF); <span class="comment">// (2)</span>

<span class="keyword">assert</span>(result.currency().equals(expected.currency())

&amp;&amp; result.amount() == expected.amount()); <span class="comment">// (3)</span>

}

}</code></pre>
</div>
</div>
<div class="paragraph">
<p>However, if the class Money would override the default equals operation defined on Object (doing so would also require us to override hashCode), the last assert statement could be simplified and would become independent of the internal implementation.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="directive">public</span> <span class="type">class</span> <span class="class">MoneyTest</span> <span class="directive">extends</span> TestCase {

<span class="comment">// ...</span>

<span class="directive">public</span> <span class="type">void</span> testSimpleAdd() {

   Money m12CHF= <span class="keyword">new</span> Money(<span class="integer">12</span>, <span class="string"><span class="delimiter">&quot;</span><span class="content">CHF</span><span class="delimiter">&quot;</span></span>); <span class="comment">// (1)</span>
   Money m14CHF= <span class="keyword">new</span> Money(<span class="integer">14</span>, <span class="string"><span class="delimiter">&quot;</span><span class="content">CHF</span><span class="delimiter">&quot;</span></span>);
   Money expected= <span class="keyword">new</span> Money(<span class="integer">26</span>, <span class="string"><span class="delimiter">&quot;</span><span class="content">CHF</span><span class="delimiter">&quot;</span></span>);
   Money result= m12CHF.add(m14CHF); <span class="comment">// (2)</span>
   <span class="keyword">assert</span>(expected.equals(result)); <span class="comment">// (3)</span>

   }
}</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="rationale-12"><a class="anchor" href="#rationale-12"></a>Rationale</h4>
<div class="paragraph">
<p>The interface of a component is a direct consequence of its collaborations with other components. Black-box tests therefore have a good chance of exercising the most important interactions of a system.</p>
</div>
<div class="paragraph">
<p>Since interfaces tend to be more stable than implementations, blackbox tests have a good chance of surviving major changes to the system, and they thereby protect your investment in developing tests.</p>
</div>
<div class="paragraph">
<p><strong>Known Uses</strong></p>
</div>
<div class="paragraph">
<p>Black-Box testing is a standard testing strategy [Som96].</p>
</div>
</div>
<div class="sect3">
<h4 id="related-patterns-6"><a class="anchor" href="#related-patterns-6"></a>Related Patterns</h4>
<div class="paragraph">
<p>Record Business Rules as Tests adopts a different strategy to developing tests which focuses on exercising business rules. This is fine if the components to be tested are the ones that implement the business logic. For most other components, Test the Interface, Not the Implementation will likely be more appropriate.</p>
</div>
<div class="paragraph">
<p>Components that implement complex algorithms may not be well-suited to black-box testing, since an analysis of the interface alone may not reveal all the cases that the algorithm should handle. White-box testing [Som96] is another standard technique for testing algorithms in which test cases are generated to cover all possible paths through an algorithm.</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="record-business-rules-as-tests"><a class="anchor" href="#record-business-rules-as-tests"></a>6.5 Record Business Rules as Tests</h3>
<div class="paragraph">
<p><strong>Intent</strong> <em>Keep the system in sync with the business rules it implements by encoding the rules explicitly as tests.</em></p>
</div>
<div class="sect3">
<h4 id="problem-17"><a class="anchor" href="#problem-17"></a>Problem</h4>
<div class="paragraph">
<p>How do you keep the <em>actual business rules</em>, the <em>documentation</em> about those business rules and the system <em>implementation</em> in sync, while all three are changing?</p>
</div>
<div class="paragraph">
<p><em>This problem is difficult because:</em></p>
</div>
<div class="ulist">
<ul>
<li>
<p>Written documentation gets out of date quickly and does not ensure you that your system really implements the description of the business rules you have.</p>
</li>
<li>
<p>Business rules tend to be implicit in the code. It may not be obvious which pieces of software are responsible for computing a given business rule.</p>
</li>
<li>
<p>Developer turn-over introduces a high risk for your business by having more and more people knowing less and less about the system.</p>
</li>
<li>
<p>Most of the time only one programmer or user knows specific rules, and that person could be leaving tomorrow.</p>
</li>
<li>
<p>Business rules are likely to change due to external factors, such as the introduction of a new law, so it is important to represent them explicitly.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p><em>Yet, solving this problem is feasible because:</em></p>
</div>
<div class="ulist">
<ul>
<li>
<p>Most business rules are well expressed by sets of canonical examples, each of which requires certain well-defined actions to be taken, and results in some clear, observable results.</p>
</li>
</ul>
</div>
</div>
<div class="sect3">
<h4 id="solution-17"><a class="anchor" href="#solution-17"></a>Solution</h4>
<div class="paragraph">
<p>Write executable tests that record the business rules as test cases, actions, and tests over the results. When tests break, you know that things are out of sync.</p>
</div>
<div class="sect4">
<h5 id="hints-14"><a class="anchor" href="#hints-14"></a>Hints</h5>
<div class="ulist">
<ul>
<li>
<p>Developers and clients can write tests. Developers may write tests associated with specific functionality or piece of code. User may also have to write integration tests in the form of use cases that bind together several unit tests [Dav95] [Bec00].</p>
</li>
<li>
<p>Note that you are not interested in the implementation strategies or optimization aspects, but only the business rules.</p>
</li>
</ul>
</div>
</div>
</div>
<div class="sect3">
<h4 id="tradeoffs-17"><a class="anchor" href="#tradeoffs-17"></a>Tradeoffs</h4>
<div class="sect4">
<h5 id="pros-16"><a class="anchor" href="#pros-16"></a>Pros</h5>
<div class="ulist">
<ul>
<li>
<p>The rules become explicit, thereby reducing dependency on human memory.</p>
</li>
<li>
<p>You need to record the business rules anyway before you can reengineer the legacy system.</p>
</li>
<li>
<p>Recording business rules as tests enables evolution: when new features must be added, you can check that the existing business rules are still correctly implemented by running the regression tests. On the other hand, when the business rules change, you can update the corresponding tests to reflect the changes.</p>
</li>
</ul>
</div>
</div>
<div class="sect4">
<h5 id="cons-17"><a class="anchor" href="#cons-17"></a>Cons</h5>
<div class="ulist">
<ul>
<li>
<p>Tests can only encode concrete scenarios, not actual the logic of the business rules themselves.</p>
</li>
<li>
<p>When the business logic must deal with an extremely large number of cases, it may be impractical to test them all.</p>
</li>
</ul>
</div>
</div>
<div class="sect4">
<h5 id="difficulties-15"><a class="anchor" href="#difficulties-15"></a>Difficulties</h5>
<div class="ulist">
<ul>
<li>
<p>Recording business rules does not mean extracting them. Extracting business rules from code with the current technology is a pipe dream.</p>
</li>
<li>
<p>Recording business rules can be difficult for system whose original developers and users have all left.</p>
</li>
</ul>
</div>
</div>
</div>
<div class="sect3">
<h4 id="examples"><a class="anchor" href="#examples"></a>Examples</h4>
<div class="paragraph">
<p>In this example we compute the amount of additional money an employee receives for a child. The rule states that a person or couple gets an amount of money for every child he, she or they raise. Basically parents get CHF 150,- per month for every child younger than 12 years, and CHF 180,- for every child between 12 and 18 and for every child between 18 and 25 as long as the child is not working and is still in the educational system. A single parent gets the full 100% of this money as long as he or she is working more than 50%. Couples get a percentage of the money that is equal to the summed working percentages of both partners.</p>
</div>
<div class="paragraph">
<p>The following Smalltalk code shows a test that hardcodes the expected outcomes for the different computations. It allows for automatically checking the outcomes instead of having to print the outcomes and check by hand if they are right, and it acts as a regression test. Secondly it documents the expected outcome of the different computations.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="smalltalk">testMoneyGivenForKids

| singlePerson80occupationWithOneKidOf5 couplePerson40occupationWithOneKidOf5 couplePerson100occupationWith2KsidOf5 couplePersonWithOneKidOf14 |

&quot;cases are extracted from a database after the system has performed the computation&quot;

singlePerson80WithOneKidOf5 := extract....

couplePerson40occupationWithOneKidOf5 := extract.... couplePerson100occupationWithOneKidOf5 := extract....

couplePersonWithOneKidOf14 := extract.... &quot;tests&quot;

&quot;We test that the right amount of money is computed correctly&quot;

self assert: singlePerson80occupationWithOneKidOf5 moneyForKid = 150. self assert: couplePerson40occupationWithOneKidOf5 moneyForKid

150*4. self assert: couplePerson100occupationWith2KidsOf5 moneyForKid

150*2.

self assert: couplePersonWithOneKidOf14 moneyForKid = 180.</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="rationale-13"><a class="anchor" href="#rationale-13"></a>Rationale</h4>
<div class="paragraph">
<p>Tests are a good way to document what the system does. By documenting business rules as tests, you guarantee that the description of the business rules will be in sync with the implementation.</p>
</div>
<div class="paragraph">
<p>The beginning of a reengineering project is a good point in time to set up a process to document knowledge about the system as explicit tests.</p>
</div>
</div>
<div class="sect3">
<h4 id="related-patterns-7"><a class="anchor" href="#related-patterns-7"></a>Related Patterns</h4>
<div class="paragraph">
<p>While you are reverse engineering a legacy system, you may Write Tests to Understand. During this process it will be natural to Record Business Rules as Tests. In this way you can prime your test base as you Grow Your Test Base Incrementally.</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="write-tests-to-understand"><a class="anchor" href="#write-tests-to-understand"></a>6.6 Write Tests to Understand</h3>
<div class="paragraph">
<p><strong>Intent</strong> <em>Record your understanding of a piece of code in the form of executable tests, thus setting the stage for future changes.</em></p>
</div>
<div class="sect3">
<h4 id="problem-18"><a class="anchor" href="#problem-18"></a>Problem</h4>
<div class="paragraph">
<p>How do you develop an understanding of a part of a legacy system which contains neither tests nor accurate and precise documentation?</p>
</div>
<div class="paragraph">
<p><em>This problem is difficult because:</em></p>
</div>
<div class="ulist">
<ul>
<li>
<p>Code is always difficult to understand.</p>
</li>
<li>
<p>You would like to make hypotheses about what the code is really doing and validate them.</p>
</li>
<li>
<p>You would like to specify as precisely as possible the behavior of the system.</p>
</li>
<li>
<p>You would like to record your understanding to communicate it but you do not want to waste your time in writing documents that will be obsolete as soon as you start changing the code.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p><em>Yet, solving this problem is feasible because:</em></p>
</div>
<div class="ulist">
<ul>
<li>
<p>The piece of code is relatively small and has clearly defined boundaries.</p>
</li>
<li>
<p>You have the possibility to specify tests and validate them.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p><strong>Solution</strong></p>
</div>
<div class="paragraph">
<p>Encode your hypotheses and conclusions as executable tests.</p>
</div>
</div>
<div class="sect3">
<h4 id="tradeoffs-18"><a class="anchor" href="#tradeoffs-18"></a>Tradeoffs</h4>
<div class="sect4">
<h5 id="pros-17"><a class="anchor" href="#pros-17"></a>Pros</h5>
<div class="ulist">
<ul>
<li>
<p>Tests help you to validate your understanding.</p>
</li>
<li>
<p>Tests can provide a precise specification of certain aspects of the system. Tests cannot be fuzzy.</p>
</li>
<li>
<p>Tests can be applied to gain different levels of understanding. For example, black-box tests can help you to refine your understanding of roles and collaborations, whereas white-box tests can help you to gain understanding of the implementation of complex logic.</p>
</li>
<li>
<p>The tests that you develop will help to enable future reengineering effort.</p>
</li>
<li>
<p>Tests will force you to be precise about the creation and the use of the objects under test.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p><strong>Cons</strong></p>
</div>
<div class="ulist">
<ul>
<li>
<p>Writing tests is time consuming.</p>
</li>
</ul>
</div>
</div>
<div class="sect4">
<h5 id="difficulties-16"><a class="anchor" href="#difficulties-16"></a>Difficulties</h5>
<div class="ulist">
<ul>
<li>
<p>Obtaining a well defined context in which you can test the objects is difficult especially if the objects to be tested do not represent specific abstractions. Looking for the places where objects you want to understand are created can help.</p>
</li>
<li>
<p>Concurrent systems are known to be difficult to test, so tests can miss important aspects (such as handling of race conditions).</p>
</li>
</ul>
</div>
</div>
</div>
<div class="sect3">
<h4 id="rationale-14"><a class="anchor" href="#rationale-14"></a>Rationale</h4>
<div class="paragraph">
<p>By writing automated tests, you exercise parts of the system you want to understand, while recording your understanding and setting the stage for future reengineering effort.</p>
</div>
</div>
<div class="sect3">
<h4 id="related-patterns-8"><a class="anchor" href="#related-patterns-8"></a>Related Patterns</h4>
<div class="paragraph">
<p>Before writing any tests, you might want to Refactor to Understand [p. 115]. As you write your tests, be sure to Tie Code and Questions [p. 109].</p>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="migration-strategies"><a class="anchor" href="#migration-strategies"></a>7. Migration Strategies</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Your reengineering project is well underway. You have developed a good understanding of the legacy system and you have started to Write Tests to Enable Evolution [p. 139]. You have gone through a process of Setting Direction and have decided to tackle the Most Valuable First [p. 25].</p>
</div>
<div class="paragraph">
<p>How can you be sure that the new system will be accepted by users? How do you migrate to the new system while the old system is being used? How can you test and evaluate the new system before it is finished?</p>
</div>
<div class="sect2">
<h3 id="forces-5"><a class="anchor" href="#forces-5"></a>Forces</h3>
<div class="ulist">
<ul>
<li>
<p>Big-bang migration carries a high risk of failure.</p>
</li>
<li>
<p>Introducing too many changes at once may alienate users.</p>
</li>
<li>
<p>Constant feedback helps you stay on track, though it may be difficult and costly to achieve.</p>
</li>
<li>
<p>Users have to get their work done; they donât want to be distracted by incomplete solution.</p>
</li>
<li>
<p>Legacy data must survive while the system is being used.</p>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="overview-5"><a class="anchor" href="#overview-5"></a>Overview</h3>
<div class="paragraph">
<p>It is not enough to reengineer a legacy system and then deploy it. In fact, if you try this, you will surely fail (for the same reasons that big Waterfall projects in new territories often fail). You must be prepared to introduce the new solution gradually, to gain the confidence and collaboration</p>
</div>
<div class="paragraph">
<p><span class="image"><img src="./media/image22.jpg" alt="image" width="432" height="256"></span></p>
</div>
<div class="paragraph">
<p>Figure 7.1: How, why and whither to migrate legacy systems.
of the users, and you must adopt a strategy for migrating gradually and painlessly from the existing system, <em>while it is still being deployed</em>, to the new system.</p>
</div>
<div class="paragraph">
<p>The central message of this cluster is to Migrate Systems Incrementally. This is, however, easier said than done. In figure 25 we can see that in order to Migrate Systems Incrementally, we should consider a large number of other patterns. Since there exists a vast literature on system migration, we do not attempt to cover the topic in great detail. We have selected, however, the patterns that we consider to be most important for reengineering object-oriented legacy systems, and summarized the main points. Where appropriate, we point the reader to further sources of information.</p>
</div>
<div class="paragraph">
<p>Although the central pattern of this cluster is Migrate Systems Incrementally, the key motivation is provided by Involve the Users and Build Confidence. These first three patterns are fundamental patterns for minimizing risk and increasing the chances of success:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Involve the Users increases the chance that users will accept the new system by involving them closely in the entire reengineering process, getting them to use intermediate results, and providing them with strong support. It is easier to achieve if you Migrate Systems Incrementally and Build Confidence step by step.</p>
</li>
<li>
<p>Build Confidence helps you overcome skepticism and doubt by regularly delivering results that are of value to the users.</p>
</li>
<li>
<p>Migrate Systems Incrementally recommends that the old system be gradually and incrementally replaced by the new system. New results can then be integrated as you proceed, thus helping you to Build Confidence and Involve the Users.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>It is very hard to Migrate Systems Incrementally unless you also adhere to the following practices:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Prototype the Target Solution to test the new architecture and new technical risks. It is too easy to be tempted to think you donât need a prototype since you already have a running system, but this is almost always a mistake.</p>
</li>
<li>
<p>Always Have a Running Version helps to keep changes in sync by ensuring that they are integrated frequently.</p>
</li>
<li>
<p>Regression Test After Every Change helps to you Always Have a Running Version by making sure that everything that used to run still runs. It presupposes that you Write Tests to Enable Evolution [p. 139].</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Depending on the circumstances, there are various practices that may help you to Migrate Systems Incrementally:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Make a Bridge to the New Town introduces the metaphor of a (data) âbridgeâ to allow you to gradually migrate data from a legacy component to its replacement, while the two run in tandem. When all the data have been transferred, the legacy component can be retired.</p>
</li>
<li>
<p>Present the Right Interface helps you to develop the target system in increments by wrapping the old functionality to export the abstractions you really want.</p>
</li>
<li>
<p>Distinguish Public from Published Interface distinguishes between stable (public) and unstable (published) interfaces to facilitate parallel development within a reengineering team.</p>
</li>
<li>
<p>Deprecate Obsolete Interfaces lets you gracefully retire obsolete interfaces without immediately invalidating clients.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Finally, the following two practices may help you avoid making radical, but unnecessary changes:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Conserve Familiarity warns you against introducing radical interface changes that may alienate users.</p>
</li>
<li>
<p>Use Profiler Before Optimizing [p. 198] reminds you to delay considering performance issues until you can demonstrate that you have a problem and can pinpoint the source of the problem.</p>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="involve-the-users"><a class="anchor" href="#involve-the-users"></a>7.1 Involve the Users</h3>
<div class="paragraph">
<p><em>Also Known As:</em> Engage Customers [Cop95]</p>
</div>
<div class="paragraph">
<p><strong>Intent</strong> <em>Maximize acceptance of changes by involving the users at every step.</em></p>
</div>
<div class="sect3">
<h4 id="problem-19"><a class="anchor" href="#problem-19"></a>Problem</h4>
<div class="paragraph">
<p>How can you be sure that users will accept the reengineered system?</p>
</div>
<div class="paragraph">
<p><em>This problem is difficult because:</em></p>
</div>
<div class="ulist">
<ul>
<li>
<p>The old systems works. It is clunky, but the users know how it works and know how to get around the problems.</p>
</li>
<li>
<p>People hate to have to learn something new unless it really makes their life simpler.</p>
</li>
<li>
<p>User perceptions of what is needed to improve a system tend to change as the system evolves.</p>
</li>
<li>
<p>Users can have difficulty evaluating a paper design.</p>
</li>
<li>
<p>It is hard to get excited about a new system that is not ready to use.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p><em>Yet, solving this problem is feasible because:</em></p>
</div>
<div class="ulist">
<ul>
<li>
<p>Users will try new solutions if they see that their needs are being seriously addressed.</p>
</li>
<li>
<p>Users will give you feedback if you give them something useful to use.</p>
</li>
</ul>
</div>
</div>
<div class="sect3">
<h4 id="solution-18"><a class="anchor" href="#solution-18"></a>Solution</h4>
<div class="paragraph">
<p>Get the users directly involved in the new development, and support them closely in using the new system.</p>
</div>
<div class="sect4">
<h5 id="steps-3"><a class="anchor" href="#steps-3"></a>Steps</h5>
<div class="paragraph">
<p>Get the users to tell you where their priorities lie. Start with Most Valuable First [p. 25]. Break the priorities down into small steps that can be delivered in regular increments, so you can Build Confidence [p. 172].</p>
</div>
<div class="paragraph">
<p>Create an environment that will encourage contact between users and developers. Physical location is important.</p>
</div>
<div class="paragraph">
<p>Establish simple procedures for delivering intermediate results on a regular basis and obtaining feedback. Early prototypes may help, especially to evaluate risky new technologies or approaches. A good strategy is to Migrate Systems Incrementally [p. 174] so that users can start using the new system as it is being built. You should Conserve Familiarity [p. 196] to avoid alienating users.</p>
</div>
</div>
</div>
<div class="sect3">
<h4 id="tradeoffs-19"><a class="anchor" href="#tradeoffs-19"></a>Tradeoffs</h4>
<div class="sect4">
<h5 id="pros-18"><a class="anchor" href="#pros-18"></a>Pros</h5>
<div class="ulist">
<ul>
<li>
<p>Requirements will continuously be validated and updated, increasing your chances that you will move in the right direction.</p>
</li>
<li>
<p>If the users feel they are getting useful results and they are being supported, they will put extra effort into giving useful feedback.</p>
</li>
<li>
<p>Users will be involved throughout the effort, eliminating the need for a special training session late in the project.</p>
</li>
</ul>
</div>
</div>
<div class="sect4">
<h5 id="cons-18"><a class="anchor" href="#cons-18"></a>Cons</h5>
<div class="ulist">
<ul>
<li>
<p>Developers may feel that supporting users is distracting them from the job of reengineering the system.</p>
</li>
<li>
<p>If you succeed in involving the users, this will raise expectations and put extra pressure on your team. For instance, Yourdon mentions that prototypes can really raise expectations too much and that you should always make clear which parts are not yet working [You97].</p>
</li>
</ul>
</div>
</div>
<div class="sect4">
<h5 id="difficulties-17"><a class="anchor" href="#difficulties-17"></a>Difficulties</h5>
<div class="ulist">
<ul>
<li>
<p>It can be hard to involve the users initially, before you have shown any results.</p>
</li>
<li>
<p>You canât involve everybody, and the users who are left out might feel neglected.</p>
</li>
</ul>
</div>
</div>
</div>
<div class="sect3">
<h4 id="rationale-15"><a class="anchor" href="#rationale-15"></a>Rationale</h4>
<div class="paragraph">
<p>You need a feedback loop to ensure that you are addressing the real customer needs. By involving and supporting the users, you encourage this feedback loop.</p>
</div>
<div class="paragraph">
<p>Coplien points out: <em>âNote that âmaintaining product qualityâ is not the problem being solved here. Product quality is only one component of customer satisfaction.â</em> [Cop95]</p>
</div>
</div>
<div class="sect3">
<h4 id="related-patterns-9"><a class="anchor" href="#related-patterns-9"></a>Related Patterns</h4>
<div class="paragraph">
<p>Virtually all of the patterns in this cluster support Involve the Users. Migrate Systems Incrementally to get the users working with the system as it is being reengineered and thereby Build Confidence.</p>
</div>
<div class="paragraph">
<p>The Planning Game [BF01] is an effective technique to Involve the Users by iteratively identifying stories, estimating costs, and committing to the stories to be released.</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="build-confidence"><a class="anchor" href="#build-confidence"></a>7.2 Build Confidence</h3>
<div class="paragraph">
<p><strong>Intent</strong> <em>Improve your chances of overall success by demonstrating results in regular increments.</em></p>
</div>
<div class="sect3">
<h4 id="problem-20"><a class="anchor" href="#problem-20"></a>Problem</h4>
<div class="paragraph">
<p>How can you overcome the high degree of skepticism that customers and team members often have for any kind of software project?</p>
</div>
<div class="paragraph">
<p><em>This problem is difficult because:</em></p>
</div>
<div class="ulist">
<ul>
<li>
<p>Few software projects meet requirements, come in on time, and stay within budget. The skepticism that accompanies most projects can easily lead to defeatism, and projects can fail as a self-fulfilling prophecy.</p>
</li>
<li>
<p>Users rarely get what they really want or need.</p>
</li>
<li>
<p>It can be hard to convince either the users or even your own team that the legacy system can really be salvaged.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p><em>Yet, solving this problem is feasible because:</em></p>
</div>
<div class="ulist">
<ul>
<li>
<p>You donât need to solve all the problems at once.</p>
</li>
</ul>
</div>
</div>
<div class="sect3">
<h4 id="solution-19"><a class="anchor" href="#solution-19"></a>Solution</h4>
<div class="paragraph">
<p>Create a positive atmosphere by demonstrating some positive results as early as you can, and continue to do so on a regular basis.</p>
</div>
<div class="sect4">
<h5 id="steps-4"><a class="anchor" href="#steps-4"></a>Steps</h5>
<div class="paragraph">
<p>Pick short intervals for delivering new results. At each step, try to agree together with the users what are the smallest results that can demonstrate real value.</p>
</div>
</div>
</div>
<div class="sect3">
<h4 id="tradeoffs-20"><a class="anchor" href="#tradeoffs-20"></a>Tradeoffs</h4>
<div class="sect4">
<h5 id="pros-19"><a class="anchor" href="#pros-19"></a>Pros</h5>
<div class="ulist">
<ul>
<li>
<p>Both users and developers can measure real progress.</p>
</li>
<li>
<p>It is easier to estimate the cost of smaller steps.</p>
</li>
</ul>
</div>
</div>
<div class="sect4">
<h5 id="cons-19"><a class="anchor" href="#cons-19"></a>Cons</h5>
<div class="ulist">
<ul>
<li>
<p>It takes time to frequently synchronize with the users.</p>
</li>
<li>
<p>Users may resent the extra work it takes to use the new system in tandem with the old one.</p>
</li>
<li>
<p>If you succeed to demonstrate good results early in the project, you may raise expectations too high.</p>
</li>
</ul>
</div>
</div>
<div class="sect4">
<h5 id="difficulties-18"><a class="anchor" href="#difficulties-18"></a>Difficulties</h5>
<div class="ulist">
<ul>
<li>
<p>Some requirements can be hard to break down into small steps, particularly if they entail architectural changes to the system.</p>
</li>
<li>
<p>Reengineering teams must be careful not to alienate the developers of the original system, since they are one of the most valuable sources of information.</p>
</li>
<li>
<p>It is not enough to convince users â you must also take care to get commitment from management. It is hard to convince management in small steps. Plan big demos at regular intervals.</p>
</li>
</ul>
</div>
</div>
</div>
<div class="sect3">
<h4 id="rationale-16"><a class="anchor" href="#rationale-16"></a>Rationale</h4>
<div class="paragraph">
<p>By taking smaller steps, you reduce the risk that an individual step will fail. Frequent, positive results help to build confidence. By the same token, Extreme Programming advocates Small Releases [Bec00]. Even negative results help you to monitor progress and understand better the situation, and so help to build up confidence.</p>
</div>
</div>
<div class="sect3">
<h4 id="related-patterns-10"><a class="anchor" href="#related-patterns-10"></a>Related Patterns</h4>
<div class="paragraph">
<p>Prototype the Target Solution and Make a Bridge to the New Town can make it easier to demonstrate results in small steps.</p>
</div>
<div class="paragraph">
<p>It is easier to Build Confidence if you Involve the Users.</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="migrate-systems-incrementally"><a class="anchor" href="#migrate-systems-incrementally"></a>7.3 Migrate Systems Incrementally</h3>
<div class="paragraph">
<p><em>Also Known As:</em> Chicken Little [BS95]</p>
</div>
<div class="paragraph">
<p><strong>Intent</strong> <em>Avoid complexity and risk of big-bang reengineering by deploying functionality in frequent increments.</em></p>
</div>
<div class="sect3">
<h4 id="problem-21"><a class="anchor" href="#problem-21"></a>Problem</h4>
<div class="paragraph">
<p>When should you plan to deploy the new system?</p>
</div>
<div class="paragraph">
<p><em>This problem is difficult because:</em></p>
</div>
<div class="ulist">
<ul>
<li>
<p>Projects are often planned and funded on large time scales, with âbig bangâ requirements specification done up front.</p>
</li>
<li>
<p>The real requirements are often only clear in hindsight. Users will resist adopting a new system that is radically different from what they are used to, especially if it does not work flawlessly from the beginning.</p>
</li>
<li>
<p>The longer you wait to deploy the new system, the longer you must wait to get user feedback.</p>
</li>
<li>
<p>You cannot deploy an incomplete system. Users do not have time to waste on incomplete solutions.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p><em>Yet, solving this problem is feasible because:</em></p>
</div>
<div class="ulist">
<ul>
<li>
<p>You have a running system that can be extended and modified.</p>
</li>
</ul>
</div>
</div>
<div class="sect3">
<h4 id="solution-20"><a class="anchor" href="#solution-20"></a>Solution</h4>
<div class="paragraph">
<p>Deploy a first <em>update</em> of the legacy system as soon as you can, and migrate incrementally to the target system.</p>
</div>
<div class="sect4">
<h5 id="steps-5"><a class="anchor" href="#steps-5"></a>Steps</h5>
<div class="ulist">
<ul>
<li>
<p>Decompose the legacy system into parts.</p>
</li>
<li>
<p>Choose one part to tackle at a time.</p>
</li>
<li>
<p>Put tests in place for that part and the parts that depend on it.</p>
</li>
<li>
<p>Take appropriate steps to wrap, reengineer or replace the legacy component.</p>
</li>
<li>
<p>Deploy the updated component and obtain feedback.</p>
</li>
<li>
<p>Iterate.</p>
</li>
</ul>
</div>
</div>
</div>
<div class="sect3">
<h4 id="tradeoffs-21"><a class="anchor" href="#tradeoffs-21"></a>Tradeoffs</h4>
<div class="sect4">
<h5 id="pros-20"><a class="anchor" href="#pros-20"></a>Pros</h5>
<div class="ulist">
<ul>
<li>
<p>You get user feedback early and Build Confidence.</p>
</li>
<li>
<p>You see immediately when things break.</p>
</li>
<li>
<p>Users learn the new system as itâs being built.</p>
</li>
<li>
<p>The system is always deployed.</p>
</li>
<li>
<p>The system is always being tested, so you canât skip testing.</p>
</li>
</ul>
</div>
</div>
<div class="sect4">
<h5 id="cons-20"><a class="anchor" href="#cons-20"></a>Cons</h5>
<div class="ulist">
<ul>
<li>
<p>You will have to work harder to keep the system running while you are changing it.</p>
</li>
</ul>
</div>
</div>
<div class="sect4">
<h5 id="difficulties-19"><a class="anchor" href="#difficulties-19"></a>Difficulties</h5>
<div class="ulist">
<ul>
<li>
<p>It can be difficult to migrate to a new architecture. You may want to Prototype the Target Solution to get the new architecture in place, and Present the Right Interface to the old system to hide the legacy interfaces while you migrate the underlying components.</p>
</li>
<li>
<p>It is risky to change a running system. Be sure to Regression Test After Every Change.</p>
</li>
</ul>
</div>
</div>
</div>
<div class="sect3">
<h4 id="rationale-17"><a class="anchor" href="#rationale-17"></a>Rationale</h4>
<div class="paragraph">
<p>You get the best user feedback from a running system. Users are more motivated and involved with a system they use daily.</p>
</div>
</div>
<div class="sect3">
<h4 id="known-uses-13"><a class="anchor" href="#known-uses-13"></a>Known Uses</h4>
<div class="paragraph">
<p><em>Migrating Legacy Systems</em> [BS95] introduces this pattern under the name âChicken Littleâ (to migrate incrementally means to âtake Chicken Little stepsâ). This book discusses in great detail strategies and techniques for incremental migration.</p>
</div>
</div>
<div class="sect3">
<h4 id="related-patterns-11"><a class="anchor" href="#related-patterns-11"></a>Related Patterns</h4>
<div class="paragraph">
<p>Apply Most Valuable First [p. 25] to select the legacy components to work on first. Appoint a Navigator [p. 23] to maintain architectural integrity.</p>
</div>
<div class="paragraph">
<p>Write Tests to Enable Evolution [p. 139], and Grow Your Test Base Incrementally [p. 144] as you migrate. Be sure to Test the Interface, Not the Implementation [p. 155] so you do not always have to rewrite your tests as you reengineer or replace legacy components. Regression Test After Every Change [p. 182] so you can Always Have a Running Version [p. 180].</p>
</div>
<div class="paragraph">
<p>Consider applying Present the Right Interface for legacy components that you do not intend to reengineer or replace.</p>
</div>
<div class="paragraph">
<p>You might consider to Make a Bridge to the New Town [p. 184] if you need to migrate data from legacy components that you are replacing.</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="prototype-the-target-solution"><a class="anchor" href="#prototype-the-target-solution"></a>7.4 Prototype the Target Solution</h3>
<div class="paragraph">
<p><strong>Intent</strong> <em>Evaluate the risk of migrating to a new target solution by building a prototype.</em></p>
</div>
<div class="sect3">
<h4 id="problem-22"><a class="anchor" href="#problem-22"></a>Problem</h4>
<div class="paragraph">
<p>How do you know if your ideas for the new target system will work?</p>
</div>
<div class="paragraph">
<p><em>This problem is difficult because:</em></p>
</div>
<div class="ulist">
<ul>
<li>
<p>It is risky to make radical changes to a working system.</p>
</li>
<li>
<p>It can be hard to anticipate how design changes will impact existing functionality.</p>
</li>
<li>
<p>A solution that works is more believable than one that one that has not been tested.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p><em>Yet, solving this problem is feasible because:</em></p>
</div>
<div class="ulist">
<ul>
<li>
<p>You donât need to reengineer the whole legacy system to test the new ideas.</p>
</li>
</ul>
</div>
</div>
<div class="sect3">
<h4 id="solution-21"><a class="anchor" href="#solution-21"></a>Solution</h4>
<div class="paragraph">
<p>Develop a prototype of the new concept and evaluate it with respect to the new, emerging requirements.</p>
</div>
<div class="sect4">
<h5 id="steps-6"><a class="anchor" href="#steps-6"></a>Steps</h5>
<div class="ulist">
<ul>
<li>
<p>Identify the biggest technical risks for your reengineering project. Typically they will concern things like:</p>
<div class="ulist">
<ul>
<li>
<p>choice of a new system architecture</p>
</li>
<li>
<p>migration of legacy data to new system</p>
</li>
<li>
<p>adequate performance â or performance gains â with new technology or platform (for example, demonstrating that a certain transaction throughput can be achieved)</p>
</li>
</ul>
</div>
</li>
<li>
<p>Decide whether to implement an exploratory (<em>i.e.</em>, throwaway) prototype that will service purely to evaluate the feasibility of a technical option, or rather an evolutionary prototype that will eventually evolve into the new target system.</p>
<div class="ulist">
<ul>
<li>
<p>An exploratory prototype must be designed to answer very precise questions. These may be purely technical questions, such as whether the new platform can meet performance constraints set by the legacy system, or they may be usability questions which require participation of and evaluation by the users. The exploratory prototype does not need to be designed to address any other issues or questions, and will not be part of the migrated system (although the answers it provides will influence the new system).</p>
</li>
<li>
<p>An evolutionary prototype, on the other hand, is intended to eventually replace a legacy component, and must therefore reflect the target architecture. The new architecture most not only adequately support the legacy services, but also overcome the obstacles that limit the legacy solutionâs usefulness. The prototype must be design to answer these risks first.
==== Tradeoffs</p>
</li>
</ul>
</div>
</li>
</ul>
</div>
</div>
<div class="sect4">
<h5 id="pros-21"><a class="anchor" href="#pros-21"></a>Pros</h5>
<div class="ulist">
<ul>
<li>
<p>A prototype can be built quickly, since it does not have to implement all the functionality of the legacy system.</p>
</li>
<li>
<p>You can hack parts of the legacy system to get your prototype running.</p>
</li>
<li>
<p>You can learn quickly if your ideas for the target system are sound.</p>
</li>
</ul>
</div>
</div>
<div class="sect4">
<h5 id="cons-21"><a class="anchor" href="#cons-21"></a>Cons</h5>
<div class="ulist">
<ul>
<li>
<p>Users may not be highly motivated to spend a lot of time evaluating a throwaway prototype.</p>
</li>
<li>
<p>You may be tempted to continue to develop the throwaway prototype.</p>
</li>
</ul>
</div>
</div>
<div class="sect4">
<h5 id="difficulties-20"><a class="anchor" href="#difficulties-20"></a>Difficulties</h5>
<div class="ulist">
<ul>
<li>
<p>It may be hard to convince yourself or your customer of the need for a prototype â after all, you already have a running system.</p>
</li>
<li>
<p>It can take too much time to get an evolutionary prototype up to speed. Consider applying Present the Right Interface to legacy components to provide a good interface for legacy services to the prototype.</p>
</li>
</ul>
</div>
</div>
</div>
<div class="sect3">
<h4 id="rationale-18"><a class="anchor" href="#rationale-18"></a>Rationale</h4>
<div class="paragraph">
<p>A prototype can tell you quickly whether a certain technical approach is sound or not. Brooks in <em>The Mythical Man-Month</em> [Bro75] advises us to âwrite one to throw awayâ since it is hard to get it right the first time.</p>
</div>
<div class="paragraph">
<p>Love [Lov93] takes this one step further and warns us that, for objectoriented systems we should âwrite two to throw away"! Foote and Yoder [FY00] argue that, among other things, Throwaway Code is often the best way to clarify domain requirements, but they also warn that a prototype risks evolving into a âBig Ball of Mudâ.</p>
</div>
</div>
<div class="sect3">
<h4 id="related-patterns-12"><a class="anchor" href="#related-patterns-12"></a>Related Patterns</h4>
<div class="paragraph">
<p>You might consider applying Make a Bridge to the New Town to migrate legacy data to an evolutionary prototype.</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="always-have-a-running-version"><a class="anchor" href="#always-have-a-running-version"></a>7.5 Always Have a Running Version</h3>
<div class="paragraph">
<p><strong>Intent</strong> <em>Increase confidence in changes by regularly rebuilding the system.</em></p>
</div>
<div class="sect3">
<h4 id="problem-23"><a class="anchor" href="#problem-23"></a>Problem</h4>
<div class="paragraph">
<p>How do you convince your customer that you are on the right path?</p>
</div>
<div class="paragraph">
<p><em>This problem is difficult because:</em></p>
</div>
<div class="ulist">
<ul>
<li>
<p>It can be hard to demo a software system under development, or to discuss problems with users since there is often no stable, running version of the system available.</p>
</li>
<li>
<p>Integrating changes from multiple versions of a system can be slow and painful.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p><em>Yet, solving this problem is feasible because:</em></p>
</div>
<div class="ulist">
<ul>
<li>
<p>You donât have to wait until a component is âfinishedâ before integrating it.</p>
</li>
</ul>
</div>
</div>
<div class="sect3">
<h4 id="solution-22"><a class="anchor" href="#solution-22"></a>Solution</h4>
<div class="paragraph">
<p>Institute a discipline of integrating new changes and developments on a daily basis.</p>
</div>
<div class="sect4">
<h5 id="steps-7"><a class="anchor" href="#steps-7"></a>Steps</h5>
<div class="ulist">
<ul>
<li>
<p>Have version management and configuration management systems in place.</p>
</li>
<li>
<p>Make sure you have regression tests in place for the parts you are working on.</p>
</li>
<li>
<p>Institute a discipline of short transactions for checking out system components and checking them back in again. Plan iterations to be as short as possible to allow changes to be integrated into a running system.</p>
</li>
</ul>
</div>
</div>
</div>
<div class="sect3">
<h4 id="tradeoffs-23"><a class="anchor" href="#tradeoffs-23"></a>Tradeoffs</h4>
<div class="sect4">
<h5 id="pros-22"><a class="anchor" href="#pros-22"></a>Pros</h5>
<div class="ulist">
<ul>
<li>
<p>You always have a working version to demo.</p>
</li>
<li>
<p>You can always have a working version to run your regression tests.</p>
</li>
<li>
<p>You can quickly validate your changes, thereby helping you to Build Confidence.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p><strong>Cons</strong></p>
</div>
<div class="ulist">
<ul>
<li>
<p>You must continuously integrate changes.</p>
</li>
</ul>
</div>
</div>
<div class="sect4">
<h5 id="difficulties-21"><a class="anchor" href="#difficulties-21"></a>Difficulties</h5>
<div class="ulist">
<ul>
<li>
<p>Large systems may have very long build times. You may need to rearchitect the system first to enable shorter build times.</p>
</li>
<li>
<p>It can be hard to break some kinds of large modifications into meaningful updates that can be individually integrated.</p>
</li>
</ul>
</div>
</div>
</div>
<div class="sect3">
<h4 id="rationale-19"><a class="anchor" href="#rationale-19"></a>Rationale</h4>
<div class="paragraph">
<p>Many practitioners advocate a process of continuous integration as a way to avoid a risky and painful big-bang integration [Boo94].</p>
</div>
</div>
<div class="sect3">
<h4 id="related-patterns-13"><a class="anchor" href="#related-patterns-13"></a>Related Patterns</h4>
<div class="paragraph">
<p>Regression Test After Every Change minimizes the risk of defects creeping in during integration.</p>
</div>
<div class="paragraph">
<p>Continuous Integration [Boo94] [Bec00] is a proven way to Always Have a Running Version.</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="regression-test-after-every-change"><a class="anchor" href="#regression-test-after-every-change"></a>7.6 Regression Test After Every Change</h3>
<div class="paragraph">
<p><strong>Intent</strong> <em>Build confidence by making sure that whatever worked before still works.</em></p>
</div>
<div class="sect3">
<h4 id="problem-24"><a class="anchor" href="#problem-24"></a>Problem</h4>
<div class="paragraph">
<p>How can you be sure that the last change you made wonât break the system?</p>
</div>
<div class="paragraph">
<p><em>This problem is difficult because:</em></p>
</div>
<div class="ulist">
<ul>
<li>
<p>In a complex system, small changes can have unexpected side effects. A seemingly innocuous change may break something without this being immediately discovered.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p><em>Yet, solving this problem is feasible because:</em></p>
</div>
<div class="ulist">
<ul>
<li>
<p>You have written test suites that express how the system should behave.</p>
</li>
</ul>
</div>
</div>
<div class="sect3">
<h4 id="solution-23"><a class="anchor" href="#solution-23"></a>Solution</h4>
<div class="paragraph">
<p>Run your regression test suite every time you think you have reached a stable state.</p>
</div>
</div>
<div class="sect3">
<h4 id="tradeoffs-24"><a class="anchor" href="#tradeoffs-24"></a>Tradeoffs</h4>
<div class="sect4">
<h5 id="pros-23"><a class="anchor" href="#pros-23"></a>Pros</h5>
<div class="ulist">
<ul>
<li>
<p>It is easier to Always Have a Running Version.</p>
</li>
<li>
<p>It is easier to Build Confidence as you proceed.</p>
</li>
</ul>
</div>
</div>
<div class="sect4">
<h5 id="cons-22"><a class="anchor" href="#cons-22"></a>Cons</h5>
<div class="ulist">
<ul>
<li>
<p>You must relentlessly write the tests.</p>
</li>
</ul>
</div>
</div>
<div class="sect4">
<h5 id="difficulties-22"><a class="anchor" href="#difficulties-22"></a>Difficulties</h5>
<div class="ulist">
<ul>
<li>
<p>The legacy system may not have adequate regression tests defined. To enable evolution, you will have to Grow Your Test Base Incrementally [p. 144]</p>
</li>
<li>
<p>Tests can only show that defects are present, not that they are absent. You may have failed to test precisely the aspect that you have broken.</p>
</li>
<li>
<p>Run the tests may be very time-consuming, so you might want to run only those tests that you think might be affected by your change. Categorize your tests to avoid âad hocâ testing of changes, but run all the tests at least once a day.</p>
</li>
</ul>
</div>
</div>
</div>
<div class="sect3">
<h4 id="rationale-20"><a class="anchor" href="#rationale-20"></a>Rationale</h4>
<div class="paragraph">
<p>Regression tests tell you that whatever ran before still runs. If you consistently build up tests for defects you discover and new features, you will end up with a reusable test base that gives you confidence that your changes are sound, and helps you detect problems earlier.</p>
</div>
<div class="paragraph">
<p>Davis advocates âRegression Test After Every Changeâ [Dav95] as standard Software Development practice.</p>
</div>
</div>
<div class="sect3">
<h4 id="related-patterns-14"><a class="anchor" href="#related-patterns-14"></a>Related Patterns</h4>
<div class="paragraph">
<p>You should have already started to Write Tests to Enable Evolution [p. 139].</p>
</div>
<div class="paragraph">
<p>A common practice in Extreme Programming is to write tests <em>before</em> you implement new functionality [JAH01]. In the context of reengineering, you should consider writing tests that will fail before you make a change, and will pass if the change is correctly implemented. (Unfortunately it is not generally possible to design tests that will <em>only</em> pass if the change is correct!)</p>
</div>
<div class="paragraph">
<p>Regression tests should help you to Retest Persistent Problems [p. 290].</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="make-a-bridge-to-the-new-town"><a class="anchor" href="#make-a-bridge-to-the-new-town"></a>7.7 Make a Bridge to the New Town</h3>
<div class="paragraph">
<p><em>Also Known As:</em> The Bridge to the New Town [Kel00], Keep the Data â Toss the Code [BS95]</p>
</div>
<div class="paragraph">
<p><strong>Intent</strong> <em>Migrate data from a legacy system by running the new system in parallel, with a bridge in between.</em></p>
</div>
<div class="sect3">
<h4 id="problem-25"><a class="anchor" href="#problem-25"></a>Problem</h4>
<div class="paragraph">
<p>How do you incrementally migrate data from a legacy system to its replacement while the two systems are running in tandem?</p>
</div>
<div class="paragraph">
<p><em>This problem is difficult because:</em></p>
</div>
<div class="ulist">
<ul>
<li>
<p>Some components of the legacy system are beyond repair and should be replaced.</p>
</li>
<li>
<p>Big-bang replacement of critical components is highly risky.</p>
</li>
<li>
<p>The <em>data</em> manipulated by the legacy components must be kept available and alive during the migration.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p><em>Yet, solving this problem is feasible because:</em></p>
</div>
<div class="ulist">
<ul>
<li>
<p>You have a running legacy system.</p>
</li>
</ul>
</div>
</div>
<div class="sect3">
<h4 id="solution-24"><a class="anchor" href="#solution-24"></a>Solution</h4>
<div class="paragraph">
<p>Make a (data) bridge that will incrementally transfer data from the legacy system to the replacement system as new components are ready to take the data over from their legacy counterparts.</p>
</div>
<div class="sect4">
<h5 id="steps-8"><a class="anchor" href="#steps-8"></a>Steps</h5>
<div class="ulist">
<ul>
<li>
<p>Identify legacy and replacement components that deal with the same logical data entities.</p>
</li>
<li>
<p>Implement a âdata bridgeâ which is responsible for redirecting <em>read</em> requests from the new component to the legacy data source, if the data have not already been migrated. The bridge is responsible for any necessary data conversion. The new component should not be aware of the bridge.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Figure 7.2: A Bridge helps you to transparently transfer data to the new system.</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Adapt the legacy component to redirect <em>write</em> requests to the new component, so that the new data stay up-to-date.</p>
</li>
<li>
<p>When all the data have been transferred, remove the bridge and the legacy component.</p>
</li>
</ul>
</div>
</div>
</div>
<div class="sect3">
<h4 id="tradeoffs-25"><a class="anchor" href="#tradeoffs-25"></a>Tradeoffs</h4>
<div class="sect4">
<h5 id="pros-24"><a class="anchor" href="#pros-24"></a>Pros</h5>
<div class="ulist">
<ul>
<li>
<p>You can start using the new system without migrating all the legacy data.</p>
</li>
</ul>
</div>
</div>
<div class="sect4">
<h5 id="cons-22"><a class="anchor" href="#cons-22"></a>Cons</h5>
<div class="ulist">
<ul>
<li>
<p>A data bridge can be tricky to implement correctly if there is not a simple mapping between the legacy data and the new data.</p>
</li>
<li>
<p>Once some of the data has been transferred, it can be hard to go back.</p>
</li>
<li>
<p>The data bridge will add a performance overhead which may or may not be acceptable.</p>
</li>
</ul>
</div>
</div>
<div class="sect4">
<h5 id="difficulties-23"><a class="anchor" href="#difficulties-23"></a>Difficulties</h5>
<div class="ulist">
<ul>
<li>
<p><em>âStepwise migration schemes have proven very effective in large, layered business systems. They are not common in letâs say CAD applications that have check in /check out persistence and a tightly coupled and very woven object net.â</em> [Kel00]</p>
</li>
</ul>
</div>
</div>
</div>
<div class="sect3">
<h4 id="known-uses-14"><a class="anchor" href="#known-uses-14"></a>Known Uses</h4>
<div class="paragraph">
<p>Brodie &amp; Stonebraker discuss much more thoroughly the use of data bridges and gateways in <em>Migrating Legacy Systems</em> [BS95].</p>
</div>
<div class="paragraph">
<p>Keller in âThe Bridge to the New Townâ [Kel00] focusses more on the technical issue of migrating legacy data, and he points out numerous examples of the pattern successfully being applied.</p>
</div>
<div class="paragraph">
<p>There are many possible variants of this pattern, depending on whether the entire legacy system is to be replaced, or only a component, and whether users should be able to have access to both systems at the same time or not.</p>
</div>
</div>
<div class="sect3">
<h4 id="rationale-21"><a class="anchor" href="#rationale-21"></a>Rationale</h4>
<div class="paragraph">
<p>A bridge between the old and new systems allows you to let users start using features of the new system before it is complete. The bridge isolates the two systems from each other so that the new system can be developed according to a new architectural vision without influence from the legacy system.</p>
</div>
</div>
<div class="sect3">
<h4 id="related-patterns-15"><a class="anchor" href="#related-patterns-15"></a>Related Patterns</h4>
<div class="paragraph">
<p>A bridge helps you Migrate Systems Incrementally and thereby Build Confidence.</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="present-the-right-interface"><a class="anchor" href="#present-the-right-interface"></a>7.8 Present the Right Interface</h3>
<div class="paragraph">
<p><em>Also Known As:</em> Semantic Wrapper [OâC00], Sweeping it Under the Rug [FY00]</p>
</div>
<div class="paragraph">
<p><strong>Intent</strong> <em>Wrap a legacy system to export the right abstractions, even if they are not reflected in the existing implementation.</em></p>
</div>
<div class="sect3">
<h4 id="problem-26"><a class="anchor" href="#problem-26"></a>Problem</h4>
<div class="paragraph">
<p>How should the new target system access legacy services during the migration process?</p>
</div>
<div class="paragraph">
<p><em>This problem is difficult because:</em></p>
</div>
<div class="ulist">
<ul>
<li>
<p>The target system is not yet complete so you must rely on legacy services during the migration.</p>
</li>
<li>
<p>The legacy system does not present the interfaces you need for the target system.</p>
</li>
<li>
<p>Implementing new components directly in terms of legacy components will bias the target towards the legacy architecture and design.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p><em>Yet, solving this problem is feasible because:</em></p>
</div>
<div class="ulist">
<ul>
<li>
<p>You donât have to access the legacy services directly.</p>
</li>
</ul>
</div>
</div>
<div class="sect3">
<h4 id="solution-25"><a class="anchor" href="#solution-25"></a>Solution</h4>
<div class="paragraph">
<p>Identify the abstractions that you want to have in the new system, and wrap up the old software to emulate the new abstractions.</p>
</div>
<div class="sect4">
<h5 id="hints-15"><a class="anchor" href="#hints-15"></a>Hints</h5>
<div class="paragraph">
<p>Consider, for example, a procedural graphics library that will be used within an object-oriented system. It will be too costly and time-consuming to reimplement the library in an object-oriented way. It would be easier to wrap it as a utility class (<em>i.e.</em>, as a class with static methods but no instances), but it would be wiser to write a slightly thicker wrapper that presents a truly object-oriented interface, but is implemented using the underlying procedural abstractions. In this way the new system will not be polluted by legacy abstractions.</p>
</div>
</div>
</div>
<div class="sect3">
<h4 id="tradeoffs-26"><a class="anchor" href="#tradeoffs-26"></a>Tradeoffs</h4>
<div class="sect4">
<h5 id="pros-25"><a class="anchor" href="#pros-25"></a>Pros</h5>
<div class="ulist">
<ul>
<li>
<p>It is easier to wean the target system from legacy services if they can use appropriate abstractions from the start.</p>
</li>
<li>
<p>You reduce the risk that the legacy design will adversely influence the new target.</p>
</li>
</ul>
</div>
</div>
<div class="sect4">
<h5 id="cons-23"><a class="anchor" href="#cons-23"></a>Cons</h5>
<div class="ulist">
<ul>
<li>
<p>The new interface may not be stable, so developers may be reluctant to use it.</p>
</li>
</ul>
</div>
</div>
<div class="sect4">
<h5 id="difficulties-24"><a class="anchor" href="#difficulties-24"></a>Difficulties</h5>
<div class="ulist">
<ul>
<li>
<p>It can be hard to resist the temptation to simply wrap the procedural abstractions as utility classes.</p>
</li>
</ul>
</div>
</div>
</div>
<div class="sect3">
<h4 id="known-uses-15"><a class="anchor" href="#known-uses-15"></a>Known Uses</h4>
<div class="paragraph">
<p>Alan OâCallaghan [OâC00] presents this pattern as âSemantic Wrapperâ briefly in the context of the ADAPTOR pattern language, which addresses migration of large-scale business-critical legacy systems to object-oriented and component-based technology.</p>
</div>
</div>
<div class="sect3">
<h4 id="rationale-22"><a class="anchor" href="#rationale-22"></a>Rationale</h4>
<div class="paragraph">
<p>Present the Right Interface frees you from thinking in terms of the legacy design and makes it easier to consider alternative approaches.</p>
</div>
</div>
<div class="sect3">
<h4 id="related-patterns-16"><a class="anchor" href="#related-patterns-16"></a>Related Patterns</h4>
<div class="paragraph">
<p>Present the Right Interface superficially resembles an Adapter [p. 293], since both use wrappers as their implementation technique. An Adapter, however, adapts an incompatible interfaces to another interface expected by its clients. Present the Right Interface, on the other hand, introduces a new, more suitable interface to a legacy component.</p>
</div>
<div class="paragraph">
<p>Be sure to Deprecate Obsolete Interfaces.</p>
</div>
<div class="paragraph">
<p>If the new interface implemented by the Present the Right Interface is not stable, you should Distinguish Public from Published Interface.</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="distinguish-public-from-published-interface"><a class="anchor" href="#distinguish-public-from-published-interface"></a>7.9 Distinguish Public from Published Interface</h3>
<div class="paragraph">
<p><em>Also Known As:</em> Published Interface [OâC00]</p>
</div>
<div class="paragraph">
<p><strong>Intent</strong> <em>Facilitate parallel development by distinguishing unstable âpublished interfacesâ from stable âpublic interfacesâ.</em></p>
</div>
<div class="sect3">
<h4 id="problem-27"><a class="anchor" href="#problem-27"></a>Problem</h4>
<div class="paragraph">
<p>How do you enable migration from legacy interfaces to new target interfaces while the new interfaces are still under development?</p>
</div>
<div class="paragraph">
<p><em>This problem is difficult because:</em></p>
</div>
<div class="ulist">
<ul>
<li>
<p>You want to enable migration to the new target system as early as possible.</p>
</li>
<li>
<p>You do not want to freeze the interfaces of new target components too early.</p>
</li>
<li>
<p>Changing the interface to a component that is widely used will slow down development.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p><em>Yet, solving this problem is feasible because:</em></p>
</div>
<div class="ulist">
<ul>
<li>
<p>You can control the status of the interfaces you provide.</p>
</li>
</ul>
</div>
</div>
<div class="sect3">
<h4 id="solution-26"><a class="anchor" href="#solution-26"></a>Solution</h4>
<div class="paragraph">
<p>Distinguish between public interfaces of components that are available to the rest of the system, and unstable âpublishedâ interfaces of components that are available within a subsystem, but are not yet ready for prime time.</p>
</div>
<div class="sect4">
<h5 id="hints-16"><a class="anchor" href="#hints-16"></a>Hints</h5>
<div class="paragraph">
<p>Since âpublishedâ interfaces are not supported by any programming language, you may have to use naming conventions, or abuse other features to achieve the desired effect.</p>
</div>
<div class="ulist">
<ul>
<li>
<p>In Java, consider declaring such interfaces as protected, or giving them package scope (undeclared). When the interfaces stabilize, you may redeclare them as being public.</p>
</li>
<li>
<p>In C++, consider declaring components with published interfaces private or protected, and declare as friends the clients that are permitted to use them. When the interfaces stabilize, redeclare the components as public, and delete the declarations of friends.</p>
</li>
<li>
<p>In Smalltalk, consider declaring categories of published components. Also consider declaring published message categories to distinguish stable and unstable messages.</p>
</li>
<li>
<p>Consider decorating the names of unstable components or interfaces to indicate their âpublishedâ status. When the component becomes public, rename it and patch all its clients or deprecate the version with the old name (Deprecate Obsolete Interfaces).</p>
</li>
</ul>
</div>
</div>
</div>
<div class="sect3">
<h4 id="tradeoffs-27"><a class="anchor" href="#tradeoffs-27"></a>Tradeoffs</h4>
<div class="sect4">
<h5 id="pros-26"><a class="anchor" href="#pros-26"></a>Pros</h5>
<div class="ulist">
<ul>
<li>
<p>Clients of published interfaces are aware that they are likely to change.</p>
</li>
</ul>
</div>
</div>
<div class="sect4">
<h5 id="cons-24"><a class="anchor" href="#cons-24"></a>Cons</h5>
<div class="ulist">
<ul>
<li>
<p>Identifying an interface as âpublishedâ is purely a matter of convention and discipline.</p>
</li>
<li>
<p>Promoting an interface from published to public entails a certain overhead for clients who should upgrade to the new interface.</p>
</li>
</ul>
</div>
</div>
<div class="sect4">
<h5 id="difficulties-25"><a class="anchor" href="#difficulties-25"></a>Difficulties</h5>
<div class="ulist">
<ul>
<li>
<p>Clients can be put in a bind: should they use an unstable published interface, or continue to use the legacy service?</p>
</li>
</ul>
</div>
</div>
</div>
<div class="sect3">
<h4 id="known-uses-16"><a class="anchor" href="#known-uses-16"></a>Known Uses</h4>
<div class="paragraph">
<p>Published Interface is another pattern of the ADAPTOR pattern language [OâC00].</p>
</div>
</div>
<div class="sect3">
<h4 id="rationale-23"><a class="anchor" href="#rationale-23"></a>Rationale</h4>
<div class="paragraph">
<p>Clients are in a better position to evaluate the risk of using a component if they know its interface is declared to be âpublishedâ but not yet public.</p>
</div>
</div>
<div class="sect3">
<h4 id="related-patterns-17"><a class="anchor" href="#related-patterns-17"></a>Related Patterns</h4>
<div class="paragraph">
<p>When you Present the Right Interface to a legacy component, the new interface may not be stable, so be careful to Distinguish Public from Published Interface. When the new interface stabilizes, or is substituted by a stable replacement component, the interface may become public.</p>
</div>
<div class="paragraph">
<p>Upgrading an interface to public may entail a change to the way it is accessed. Be sure to Deprecate Obsolete Interfaces.</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="deprecate-obsolete-interfaces"><a class="anchor" href="#deprecate-obsolete-interfaces"></a>7.10 Deprecate Obsolete Interfaces</h3>
<div class="paragraph">
<p><em>Also Known As:</em> Deprecation [SP98]</p>
</div>
<div class="paragraph">
<p><strong>Intent</strong> <em>Give clients time to react to changes to public interfaces by flagging obsolete interfaces as âdeprecatedâ.</em></p>
</div>
<div class="sect3">
<h4 id="problem-28"><a class="anchor" href="#problem-28"></a>Problem</h4>
<div class="paragraph">
<p>How do you modify an interface without invalidating all the clients?</p>
</div>
<div class="paragraph">
<p><em>This problem is difficult because:</em></p>
</div>
<div class="ulist">
<ul>
<li>
<p>Changing a public interface can break many clients.</p>
</li>
<li>
<p>Leaving an obsolete interface in place will make future maintenance more difficult.</p>
</li>
<li>
<p>Not all changes are for the better.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p><em>Yet, solving this problem is feasible because:</em></p>
</div>
<div class="ulist">
<ul>
<li>
<p>The old and the new interfaces can coexist for a period of time.</p>
</li>
</ul>
</div>
</div>
<div class="sect3">
<h4 id="solution-27"><a class="anchor" href="#solution-27"></a>Solution</h4>
<div class="paragraph">
<p>Flag the old interface as being âdeprecatedâ, thereby notifying clients that it will almost certainly be removed in the next upcoming release.</p>
</div>
<div class="sect4">
<h5 id="steps-9"><a class="anchor" href="#steps-9"></a>Steps</h5>
<div class="ulist">
<ul>
<li>
<p>You have determined that a public interface should be changed, but you do not want to break all clients. Implement the new interface, but âdeprecateâ the old one. The deprecation mechanism should inform clients that the interface has changed, and that a newer interface is recommended instead.</p>
</li>
<li>
<p>Evaluate to what extent the deprecated interface continues to be used, and whether it can be permanently retired. Consider removing it in a future release.</p>
</li>
<li>
<p>Java supports deprecation as a language feature:</p>
<div class="ulist">
<ul>
<li>
<p>Deprecate a feature by adding the tag @deprecated to its javadoc documentation. The tag is not only recognized by the javadoc documentation generator, but the compiler will also generate compile-time warnings if code using deprecated features is compiled with the -deprecated option.</p>
</li>
</ul>
</div>
</li>
<li>
<p>Other approaches are:</p>
<div class="ulist">
<ul>
<li>
<p>Simply inform users in the documentation which interfaces are deprecated.</p>
</li>
<li>
<p>Move or rename the deprecated interface or component. Clients can continue to use them, but must adapt and recompile to continue to use the deprecated form.</p>
</li>
<li>
<p>Replace deprecated components by equivalent ones that generate run-time warnings or output warnings to a log file.</p>
</li>
<li>
<p>Alternatively, consider configuring the programming environment or the deprecated components themselves to generate compile-time or link-time warnings.</p>
</li>
</ul>
</div>
</li>
</ul>
</div>
</div>
</div>
<div class="sect3">
<h4 id="tradeoffs-28"><a class="anchor" href="#tradeoffs-28"></a>Tradeoffs</h4>
<div class="sect4">
<h5 id="pros-27"><a class="anchor" href="#pros-27"></a>Pros</h5>
<div class="ulist">
<ul>
<li>
<p>Clients do not have to immediately adapt to changes.</p>
</li>
<li>
<p>There is time to change your mind.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p><strong>Cons</strong></p>
</div>
<div class="ulist">
<ul>
<li>
<p>Clients are free to ignore deprecation.</p>
</li>
</ul>
</div>
</div>
<div class="sect4">
<h5 id="difficulties-26"><a class="anchor" href="#difficulties-26"></a>Difficulties</h5>
<div class="ulist">
<ul>
<li>
<p>It may be hard to track down all the clients of a deprecated component.</p>
</li>
<li>
<p>It can be hard to decide when to really retire a deprecated component.</p>
</li>
<li>
<p>If you want to keep the interface but change the semantics, you may need to introduce a new component and deprecate the old one. This can be the case if certain methods should now return default values instead of throwing exceptions (or vice versa).</p>
</li>
</ul>
</div>
</div>
</div>
<div class="sect3">
<h4 id="known-uses-17"><a class="anchor" href="#known-uses-17"></a>Known Uses</h4>
<div class="paragraph">
<p>Perdita Stevens and Rob Pooley identify Deprecation as a common practice for managing evolving APIs in complex systems [SP98].</p>
</div>
</div>
<div class="sect3">
<h4 id="rationale-24"><a class="anchor" href="#rationale-24"></a>Rationale</h4>
<div class="paragraph">
<p>Deprecation gives you a window of time to evaluate the impact of a change.</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="conserve-familiarity"><a class="anchor" href="#conserve-familiarity"></a>7.11 Conserve Familiarity</h3>
<div class="paragraph">
<p><strong>Intent</strong> <em>Avoid radical changes that may alienate users.</em></p>
</div>
<div class="sect3">
<h4 id="problem-29"><a class="anchor" href="#problem-29"></a>Problem</h4>
<div class="paragraph">
<p>How do you accomplish a major overhaul of a legacy system without disrupting the way users are used to getting their job done?</p>
</div>
<div class="paragraph">
<p><em>This problem is difficult because:</em></p>
</div>
<div class="ulist">
<ul>
<li>
<p>The legacy system requires significant changes.</p>
</li>
<li>
<p>The users are not happy with the legacy system, but they understand it well.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p><em>Yet, solving this problem is feasible because:</em></p>
</div>
<div class="ulist">
<ul>
<li>
<p>You can migrate incrementally to a new solution.</p>
</li>
</ul>
</div>
</div>
<div class="sect3">
<h4 id="solution-28"><a class="anchor" href="#solution-28"></a>Solution</h4>
<div class="paragraph">
<p>Introduce only a constant, relatively low number of changes between each new release.</p>
</div>
</div>
<div class="sect3">
<h4 id="tradeoffs-29"><a class="anchor" href="#tradeoffs-29"></a>Tradeoffs</h4>
<div class="sect4">
<h5 id="pros-28"><a class="anchor" href="#pros-28"></a>Pros</h5>
<div class="ulist">
<ul>
<li>
<p>Users do not have to change their work habits too much between releases.</p>
</li>
</ul>
</div>
</div>
<div class="sect4">
<h5 id="difficulties-27"><a class="anchor" href="#difficulties-27"></a>Difficulties</h5>
<div class="ulist">
<ul>
<li>
<p>Sometimes radical change is necessary. It can be hard to migrate from a command-line interface to a GUI while conserving familiarity.</p>
</li>
</ul>
</div>
</div>
</div>
<div class="sect3">
<h4 id="rationale-25"><a class="anchor" href="#rationale-25"></a>Rationale</h4>
<div class="paragraph">
<p>Too much change between releases increases the risk of hidden defects, and decreases the chance of user acceptance.</p>
</div>
<div class="paragraph">
<p>Lehman and Beladyâs âLaw of Conservation of Familiarityâ suggests that the incremental change between releases of a system stays roughly constant over time [LB85]. This is a relatively natural phenomenon because to do anything else introduces unnecessary risks.</p>
</div>
</div>
<div class="sect3">
<h4 id="related-patterns-18"><a class="anchor" href="#related-patterns-18"></a>Related Patterns</h4>
<div class="paragraph">
<p>To Conserve Familiarity you must Migrate Systems Incrementally. Involve the Users to understand what changes will be acceptable. Prototype the Target Solution to evaluate the potential impact of changes.</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="use-profiler-before-optimizing"><a class="anchor" href="#use-profiler-before-optimizing"></a>7.12 Use Profiler Before Optimizing</h3>
<div class="paragraph">
<p><strong>Intent</strong> <em>Avoid squandering reengineering effort on needless âoptimizationsâ by verifying where the bottlenecks are.</em></p>
</div>
<div class="sect3">
<h4 id="problem-30"><a class="anchor" href="#problem-30"></a>Problem</h4>
<div class="paragraph">
<p>When should you rewrite a clearly inefficient piece of code?</p>
</div>
<div class="paragraph">
<p><em>This problem is difficult because:</em></p>
</div>
<div class="ulist">
<ul>
<li>
<p>When you are reengineering software, you are likely to encounter many naive algorithms in the legacy code.</p>
</li>
<li>
<p>It can be hard to predict what will impact performance, and you can lose a lot of time on pure supposition.</p>
</li>
<li>
<p>Optimized code is often more complex than simple, naive code.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p><em>Yet, solving this problem is feasible because:</em></p>
</div>
<div class="ulist">
<ul>
<li>
<p>There are tools to tell you where you may have a performance problem.</p>
</li>
</ul>
</div>
</div>
<div class="sect3">
<h4 id="solution-29"><a class="anchor" href="#solution-29"></a>Solution</h4>
<div class="paragraph">
<p>Whenever you are tempted to optimize a âclearly inefficientâ part of the system, first use a profiler to determine whether it is actually a bottleneck.</p>
</div>
<div class="paragraph">
<p>Donât optimize anything unless your profiler tells you it will make a difference.</p>
</div>
<div class="paragraph">
<p>If you decide to go ahead, prepare benchmarks that will demonstrate the performance gains.</p>
</div>
</div>
<div class="sect3">
<h4 id="tradeoffs-30"><a class="anchor" href="#tradeoffs-30"></a>Tradeoffs</h4>
<div class="sect4">
<h5 id="pros-29"><a class="anchor" href="#pros-29"></a>Pros</h5>
<div class="ulist">
<ul>
<li>
<p>You do not waste time optimizing something that will not make a difference to overall performance.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p><strong>Cons</strong></p>
</div>
<div class="ulist">
<ul>
<li>
<p>Naive algorithms will survive longer in the system.</p>
</li>
</ul>
</div>
</div>
</div>
<div class="sect3">
<h4 id="rationale-26"><a class="anchor" href="#rationale-26"></a>Rationale</h4>
<div class="paragraph">
<p>The performance improvement that you can gain by optimizing a bit of code depends on how much time the program, spends in that code in a typical run. A profiler will tell you how much time that is.</p>
</div>
<div class="paragraph">
<p>âDo it, then do it right, then do it fastâ is a well-known aphorism that has been credited to many different sources. Very likely its origin is outside of the field of computer science. The rationale behind it is that you risk making a system complex and hard to maintain if you become preoccupied with performance issues too early. Instead, it is better to first find a solution that works, then clean it up once you understand it. Finally, if you can identify any important performance bottlenecks, that is the time to optimize just those parts that will make a difference.</p>
</div>
<div class="paragraph">
<p>As a corollary, it may even be a good idea to replace a bit of complex, âoptimizedâ code by a simpler, ânaiveâ solution, if that wonât severely impact performance, but will make it easier to make other changes.</p>
</div>
<div class="paragraph">
<p>See also Davisâ discussion of âUse Profiler Before Optimizingâ [Dav95].</p>
</div>
</div>
<div class="sect3">
<h4 id="related-patterns-19"><a class="anchor" href="#related-patterns-19"></a>Related Patterns</h4>
<div class="paragraph">
<p>If you Refactor to Understand [p. 115], you will have started the second step to âdo it right."</p>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="detecting-duplicated-code"><a class="anchor" href="#detecting-duplicated-code"></a>8. Detecting Duplicated Code</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Fowler and Beck have ranked duplicated code as the first of the top ten code smells indicating the need to refactor a piece of software [FBB<sup>+</sup>99]. As they like to explain it, whenever you duplicate a piece of code, you are taking out a loan, in the sense that you are getting something now (an almost ready-made piece of software) that you will have to pay for later. There is nothing wrong with taking out a loan, but you have a choice between paying back a small amount now (by taking out the time to refactor your code to eliminate the duplication) or paying back a lot later (in terms of increased complexity and maintenance costs).</p>
</div>
<div class="paragraph">
<p>Data from empirical studies show that typically between 8% and 12% of industrial software consists of duplicated code [DRD99]. Although this may not seem like much, in fact it is difficult to achieve very high rates of duplication. (Imagine what it would take to have a duplication rate of even 50%!) Duplication rates of 15 to 20% are therefore considered to be severe.</p>
</div>
<div class="paragraph">
<p>It is important to identify duplicated code for the following reasons:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Duplicated code hampers the introduction of changes, since every implemented variant of a piece of functionality will have to be changed. Since it is easy to miss some variants, bugs are likely to pop up in other places.</p>
</li>
<li>
<p>Duplicated code replicates and scatters the logic of a system instead of grouping it into identifiable artifacts (classes, methods, packages). It leads to systems that are more difficult to understand and to change. Instead of just having to understand relationship between logical parts you will have first to identify them and then understand their relationships.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>201</p>
</div>
<div class="paragraph">
<p>Duplicated code arises for a variety of reasons:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Whenever a programmer is implementing a piece of functionality that is remotely similar to something that has been done before, it is natural to use the existing code as a model for the new task. If it is a matter of recombining existing procedures, the task will be simple. But if the behavior is more complex, the easiest thing to do is to copy, paste and modify the old code to achieve the functionality. If both the old and new pieces of code belong to different applications, the harm is minimal. But if they are part of the same system, duplicated code has now been introduced.</p>
</li>
<li>
<p>Sometimes code is copied, pasted and modified between different applications, or different versions of the same application. When multiple versions must be maintained simultaneously, or when different applications or versions must be merged, you immediately have a duplicated code problem.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>From a reengineering perspective, usually people know whether or not a system suffers from duplication. First, the development team, or the manager will tell you. Second, there are normally some clear signs that duplication has been practiced in a project: for example, two developers cannot develop four millions of line of code in less than eight months without copying and pasting existing code. While analyzing the system you will also identify duplicated code by accident. There is a major difference, however, between knowing that a system contains duplicated code, and knowing exactly which parts have been duplicated.</p>
</div>
<div class="paragraph">
<p><span class="image"><img src="./media/image23.jpg" alt="image" width="345" height="183"></span></p>
</div>
<div class="paragraph">
<p>Figure 8.1: Two patterns to support Detecting Duplicated Code.</p>
</div>
<div class="sect2">
<h3 id="overview-6"><a class="anchor" href="#overview-6"></a>Overview</h3>
<div class="paragraph">
<p>Detecting Duplicated Code consists of two patterns: Compare Code Mechanically, which describes how we can detect duplicated code, and Visualize Code as Dotplots, which shows how duplicated code can be better understood by simple matrix visualization.</p>
</div>
<div class="paragraph">
<p>Once you have detected and understood duplication in the system, you may decide on a variety of tactics. Various refactoring patterns, such as Extract Method [p. 291] may help you to eliminate the duplication. Duplication may be a sign of misplaced responsibilities, in which you should may decide to Move Behavior Close to Data [p. 221].</p>
</div>
<div class="paragraph">
<p>Complex conditional statements are also a form of duplication, and may indicate that multiple clients have to duplicate actions that should belong to the target class. The pattern cluster Transform Conditionals to Polymorphism can help you to resolve these problems.</p>
</div>
</div>
<div class="sect2">
<h3 id="compare-code-mechanically"><a class="anchor" href="#compare-code-mechanically"></a>8.1 Compare Code Mechanically</h3>
<div class="paragraph">
<p><strong>Intent</strong> <em>Discover duplicated code by comparing all the source code files line-byline.</em></p>
</div>
<div class="sect3">
<h4 id="problem-31"><a class="anchor" href="#problem-31"></a>Problem</h4>
<div class="paragraph">
<p>How do you discover which parts of an application code have been duplicated?</p>
</div>
<div class="paragraph">
<p><em>This problem is difficult because:</em></p>
</div>
<div class="ulist">
<ul>
<li>
<p>You may suspect that code has been duplicated but you do not have any a priori evidence where the duplication occurs. For example, you know that two programmers cannot have developed 4 million lines of Cobol in one year without having duplicated some code.</p>
</li>
<li>
<p>Browsing the code is not an effective way of discovering duplication; you will only find duplicated code by accident.</p>
</li>
<li>
<p>Programmers may have not only copied and pasted code but also modified variables or changed the shape of the programs.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p><em>Yet, solving this problem is feasible because:</em></p>
</div>
<div class="ulist">
<ul>
<li>
<p>Most duplicated code can be detected by mechanical procedures.</p>
</li>
</ul>
</div>
</div>
<div class="sect3">
<h4 id="solution-30"><a class="anchor" href="#solution-30"></a>Solution</h4>
<div class="paragraph">
<p>Textually compare each line of the software source code with all the other lines of code.</p>
</div>
<div class="sect4">
<h5 id="steps-10"><a class="anchor" href="#steps-10"></a>Steps</h5>
<div class="ulist">
<ul>
<li>
<p>Normalize the lines of code by removing comments, tabs and blanks.</p>
</li>
<li>
<p>Remove lines that contain uninteresting code elements (<em>e.g.</em>, just else or })</p>
</li>
<li>
<p>Compare each line with all the other lines. Reduce search complexity by hashing:</p>
<div class="ulist">
<ul>
<li>
<p>Preprocessing: Compute the hash value for each line</p>
</li>
<li>
<p>Actual Comparison: Compare all lines in the same hash bucket <strong>Variants</strong></p>
</li>
</ul>
</div>
</li>
</ul>
</div>
<div class="paragraph">
<p>This approach may fail to identify some instances of duplicated code due to renaming of variables. By deleting all variable identifiers, or by mapping them to a common symbol, you can detect similar code patterns, while abstracting from the details of the specific identifiers. This variant, however, requires some syntactic processing of the code.</p>
</div>
</div>
</div>
<div class="sect3">
<h4 id="tradeoffs-31"><a class="anchor" href="#tradeoffs-31"></a>Tradeoffs</h4>
<div class="sect4">
<h5 id="pros-30"><a class="anchor" href="#pros-30"></a>Pros</h5>
<div class="ulist">
<ul>
<li>
<p>The approach is simple and gives good results while only requiring modest resources.</p>
</li>
<li>
<p>It is nearly language-independent in the sense that you only have to build a lexical analyzer and not a full parser. Thatâs why a simple perl script can be sufficient depending on the level of sophistication that you want.</p>
</li>
<li>
<p>Simple statistics and percentage rates are easily computed and may help you to gain credibility or more strength in discussions on resource allocation or hiring new people.</p>
</li>
</ul>
</div>
</div>
<div class="sect4">
<h5 id="cons-25"><a class="anchor" href="#cons-25"></a>Cons</h5>
<div class="ulist">
<ul>
<li>
<p>Code that has been heavily edited after copying may be hard to identify as duplicated code.</p>
</li>
<li>
<p>Systems containing a lot of duplicated code will generate a lot of data that can be difficult to analyze effectively.</p>
</li>
</ul>
</div>
</div>
</div>
<div class="sect3">
<h4 id="example-12"><a class="anchor" href="#example-12"></a>Example</h4>
<div class="paragraph">
<p>Consider the case of a system written in C++ where you suspect duplicated code. However, you didnât write to code yourself so you donât know where the actual duplication occurs. How can you detect where the duplicated code fragments are? Consistent with Keep It Simple [p. 31] you do the simplest thing that may possibly work: you write a little script that first normalizes the code to remove all white space from the code and afterwards compares each line of code against itself.</p>
</div>
<div class="paragraph">
<p>The normalization would change the following code</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code>|
a|
...


// assign same fastid as container fastid = NULL;

const char* fidptr = getFastid(); if(fidptr != NULL) \{ int l = strlen(fidptr); fastid = new char[l+1]; char *tmp = (char*) fastid;

for (int i =0;i&lt;l;i++) tmp[i] = fidptr[i];

tmp[l] = '\0';

}

...

|

into

[cols="",]
|
a|
...

fastid=NULL;

constchar*fidptr=getFastid(); if(fidptr!=NULL)

intl=strlen(fidptr); fastid=newchar[l+1]; char*tmp=(char*)fastid;

for(inti=0;i&lt;l;i++) tmp[i]=fidptr[i]; tmp[l]='\0';

...

|

Afterwards, the line-by-line comparison of the code against itself produces a report telling which sequences of lines are duplicated.

Lines:fastid=NULL;;constchar*fidptr=getFastid();;if(fidptr!=NULL); intl=strlen(fidptr);;fastid=newchar[l+1];; Locations:

&lt;/typesystem/Parser.C&gt;6178/6179/6180/6181/6182

&lt;/typesystem/Parser.C&gt;6198/6199/6200/6201/6202

Below is a sample of a perl script that will do the trick.
#! /usr/bin/env perl --w

# duplocForCPP.pl -- detect duplicated lines of code (algorithm only)
# Synopsis: duplocForCPP.pl filename ...

# Takes code (or other) files and collects all line numbers of lines equal to each other within these files. The algorithm is linear (in space and time) to the number of lines in input.

# Output: Lists of numbers of equal lines.

[cols="",]
|
a|
# Author: Matthias Rieger

$equivalenceClassMinimalSize = 1;

$slidingWindowSize = 5; $removeKeywords = 0;

@keywords = qw(if then else for \{

}

);

$keywordsRegExp = join '|', @keywords;

@unwantedLines = qw( else

return return; return result;

}else\{

#else

#endif

\{

}

;

};

);

push @unwantedLines, @keywords;

@unwantedLines\{@unwantedLines} = (1) x @unwantedLines;

$totalLines = 0;

$emptyLines = 0;

$codeLines = 0;

@currentLines = ();

@currentLineNos = ();

%eqLines = ();

$inComment = 0;

$start = (times)[0];

while (&lt;&gt;) \{ chomp;

$totalLines++;

# remove comments of type / /

|

*

[cols="",options="header",]
|
a|
my $codeOnly = ";

while(($inComment &amp;&amp; m|\*/|) || (!$inComment &amp;&amp; m|/\*|)) \{ unless($inComment) \{ $codeOnly .= $` }

$inComment = !$inComment;

$_ = $';

}

$codeOnly .= $_ unless $inComment;

$_ = $codeOnly;

s|//.*$||; # remove comments of type // s/\s+//g; #remove white space

s/$keywordsRegExp//og if $removeKeywords; #remove keywords

# remove empty and unwanted lines

if((!$_ &amp;&amp; $emptyLines++)

|| (defined $unwantedLines\{$_} &amp;&amp; $codeLines++)) \{ next }

$codeLines++; push @currentLines, $_; push @currentLineNos, $.;

if($slidingWindowSize &lt; @currentLines) \{ shift @currentLines;

shift @currentLineNos;

}

# print STDERR "Line $totalLines &gt;$_&lt;\n";

my $lineToBeCompared = join ", @currentLines;

my $lineNumbersCompared = "&lt;$ARGV&gt;"; # append the name of the file

$lineNumbersCompared .= join '/', @currentLineNos; # print STDERR "$lineNumbersCompared\n"; if($bucketRef = $eqLines\{$lineToBeCompared}) \{ push @$bucketRef, $lineNumbersCompared;

} else \{

$eqLines\{$lineToBeCompared} = [ $lineNumbersCompared ];

}

if(eof) \{ close ARGV } # Reset linenumber--count for next file

}

$end = (times)[0];

$processingTime = $end -- $start; # print the equivalence classes

$numOfMarkedEquivClasses = 0;

a|
$numOfMarkedElements = 0;

foreach $line (sort \{ length $a &lt;=&gt; length $b } keys %eqLines) \{ if(scalar @\{$eqLines\{$line}} &gt; $equivalenceClassMinimalSize) \{

$numOfMarkedEquivClasses++;

$numOfMarkedElements += scalar @\{$eqLines\{$line}}; print "Lines: $line\n";

print "Locations: @\{$eqLines\{$line}}\n\n";

}

}

print "\n\n\n";

print "Number of Lines processed: $totalLines\n"; print "Number of Empty Lines: $emptyLines\n"; print "Number of Code Lines: $codeLines\n"; print "Scanning time in seconds: $processingTime\n";

print "Lines per second: @\{[$totalLines/$processingTime]}\n";

print "----------------------------------------------------------------------------\n";

print "Total Number of equivalence classes: @\{[scalar keys %eqLines]}\n

";

print "Size of Sliding window: $slidingWindowSize\n"; print "Lower bound of eqiv--class Size: $equivalenceClassMinimalSize\n"; print "Number of marked equivalence classes:

$numOfMarkedEquivClasses\n"; print "Number of marked elements: $numOfMarkedElements\n";</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="known-uses-18"><a class="anchor" href="#known-uses-18"></a>Known Uses</h4>
<div class="paragraph">
<p>In the context of software reengineering, the pattern has been applied to detect duplicated code in FAMOOS case studies containing up to one million lines of C+. It also has been applied to detect duplicated code in a COBOL system of 4 million lines of code. DATRIX has investigated multiple versions of a large telecommunications system, wading through 89 million lines of code all in all [LPM^^97].</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="visualize-code-as-dotplots"><a class="anchor" href="#visualize-code-as-dotplots"></a>8.2 Visualize Code as Dotplots</h3>
<div class="paragraph">
<p><strong>Intent</strong> _Gain insight into the nature of the duplication by studying the patterns in the dotplots.</p>
</div>
<div class="sect3">
<h4 id="problem-32"><a class="anchor" href="#problem-32"></a>Problem</h4>
<div class="paragraph">
<p>How can you gain insight into the scope and nature of code duplication in a software system?</p>
</div>
<div class="paragraph">
<p><em>This problem is difficult because:</em></p>
</div>
<div class="ulist">
<ul>
<li>
<p>Just knowing where in the system duplicated code exists does not necessarily help you to understand its nature, or what should be done about it.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p><em>Yet, solving this problem is feasible because:</em></p>
</div>
<div class="ulist">
<ul>
<li>
<p>A picture is worth a thousand words.</p>
</li>
</ul>
</div>
</div>
<div class="sect3">
<h4 id="solution-31"><a class="anchor" href="#solution-31"></a>Solution</h4>
<div class="paragraph">
<p>Visualize the code as a matrix in which the two axes represent two source code files (possibly the same file), and dots in the matrix occur where source code lines are duplicated.</p>
</div>
<div class="sect4">
<h5 id="steps-11"><a class="anchor" href="#steps-11"></a>Steps</h5>
<div class="paragraph">
<p>If you want to analyze two files A and B:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Normalize the contents of the two files to eliminate noise (white space <em>etc.</em>).</p>
</li>
<li>
<p>Let each axis of the matrix represent elements (<em>e.g.</em>, the lines of code) of the normalized files.</p>
</li>
<li>
<p>Represent a match between two elements as a dot in the matrix.</p>
</li>
<li>
<p>Interpret the obtained pictures: a diagonal represents duplicated code between the two files.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>To analyze the duplication inside a single file, plot the elements of that file on both axes.</p>
</div>
<div class="paragraph">
<p><span class="image"><img src="./media/image24.png" alt="image" width="425" height="135"></span></p>
</div>
<div class="paragraph">
<p>Figure 8.2: Possible sequences of dot and their associated interpretations.</p>
</div>
</div>
<div class="sect4">
<h5 id="interpretations"><a class="anchor" href="#interpretations"></a>Interpretations</h5>
<div class="paragraph">
<p>The interpretation of the obtained matrices are illustrated in Figure 8.2:</p>
</div>
<div class="paragraph">
<p>Some interesting configurations formed by the dots in the matrices are the following:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><em>Exact Copies:</em> diagonals of dots indicate copied sequences of source code.</p>
</li>
<li>
<p><em>Copies With Variations:</em> sequences that have holes in them indicate that a portion of a copied sequences has been changed.</p>
</li>
<li>
<p><em>Inserts/Deletes:</em> broken sequences with parts shifted to the right or left indicate that a portion of code has been inserted or deleted.</p>
</li>
<li>
<p><em>Repetitive Code Elements:</em> rectangular configurations indicate periodic occurrences of the same code. An example is the break at the end of the individual cases of a C or C ++ switch statement, or recurring preprocessor commands like #ifdef SOME CONDITION.</p>
</li>
</ul>
</div>
</div>
</div>
<div class="sect3">
<h4 id="tradeoffs-32"><a class="anchor" href="#tradeoffs-32"></a>Tradeoffs</h4>
<div class="sect4">
<h5 id="pros-31"><a class="anchor" href="#pros-31"></a>Pros</h5>
<div class="ulist">
<ul>
<li>
<p>The approach is largely language-independent, since only the code normalization depends on the language syntax.</p>
</li>
<li>
<p>The approach works well when reverse engineering large amounts of unknown code, because the dotplots attract your eye to certain parts of the code to be studied more closely.</p>
</li>
<li>
<p>The idea is simple yet works surprisingly well.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Before After</p>
</div>
<div class="paragraph">
<p>_<span class="image"><img src="./media/image25.png" alt="image" width="282" height="282"></span>Before</p>
</div>
<div class="paragraph">
<p>After</p>
</div>
<div class="paragraph">
<p>Figure 8.3: Code duplication before and after refactoring.</p>
</div>
<div class="paragraph">
<p>A simple version of the approach can be implemented by a good programmer using a appropriate tools in a couple of days. (One of our better students made a small dotplot browser in Delphi in two days.)</p>
</div>
</div>
<div class="sect4">
<h5 id="cons-26"><a class="anchor" href="#cons-26"></a>Cons</h5>
<div class="ulist">
<ul>
<li>
<p>Dotplots only present pairwise comparisons. They do not necessarily help you identify all instances of duplicated elements in the entire software system. Although the approach can easily be extended to present multiple files across each axis, the comparisons are still only pairwise.
===== Difficulties</p>
<div class="ulist">
<ul>
<li>
<p>A naive implementation of a dotplot visualizer may not scale well to large systems. Tuning and optimizing the approach for large data sets can compromise the simplicity of the approach.</p>
</li>
<li>
<p>The interpretation of the data may be more subtle than it appears at first glance. Indeed, while comparing multiple files the diagonals represent more duplication than is really in the system because we are comparing duplicated fragments with themselves over different files, as shown by Figure 8.3 and Figure 8.4.</p>
</li>
<li>
<p>The screen size limits the amount of information that can be visualized. Some success has been achieved with so-called âmuralâ visualization approaches [JS96]. However, these techniques are significantly more difficult to implement than simple dotplots and are not worth the extra effort.</p>
</li>
</ul>
</div>
</li>
</ul>
</div>
</div>
</div>
<div class="sect3">
<h4 id="example-13"><a class="anchor" href="#example-13"></a>Example</h4>
<div class="paragraph">
<p>In Figure 8.3 we see a dotplot of two versions of a piece of software, before and after the duplication has been removed. The first version is compared to itself in the top left square. The line down the diagonal simply shows us that every line of code is being compared to itself. What is more interesting is that several other diagonal lines occur in the dotplot, which means that code has been duplicated within this file. A second version of the same file is compared to itself in the lower right square. Here we see no significant duplication aside from the main diagonal, which reflects the fact that all the duplicated code has been successfully refactored.</p>
</div>
<div class="paragraph">
<p>A B</p>
</div>
<div class="paragraph">
<p>A <span class="image"><img src="./media/image26.jpg" alt="image" width="407" height="171"></span>
Figure 8.4: A Python file A being compared to itself and to a second file B.</p>
</div>
<div class="paragraph">
<p>The bottom left and top right squares are mirror images of each other. They tell us how the before and after files have been reorganized. Since there is no strong diagonal, this tells us that significant reorganization has taken place. The diagonal stripes show us which parts of the old version have survived and where they appear in the new version. From the dot-</p>
</div>
<div class="paragraph">
<p><span class="image"><img src="./media/image27.jpg" alt="image" width="317" height="317"></span></p>
</div>
<div class="paragraph">
<p>Figure 8.5: Dotplots produced by four switch statements.
plot alone, we can guess that about half of the code has survived, and another half of the code has been significantly rewritten.</p>
</div>
<div class="paragraph">
<p>Dotplots are also useful to detect duplication across multiple files. Figure 8.4 shows a dotplot comparing two Python files. The comparison of A vs. A shows that there is essentially no internal duplication. Very likely there are some switch statements in the bottom have of the file, indicated by the matrix pattern.</p>
</div>
<div class="paragraph">
<p>When we compare file A to file B, however, we detect a staggering amount of duplication. It looks very much like file B is just a copy of file A that has been extended in various ways. Closer investigation showed this to be the case. In fact, file A was just an older version of file B that had inadvertently been left in the release.</p>
</div>
<div class="paragraph">
<p>Dotplots can also be useful to detect other problems. Figure 8.5 presents four clones that represent a switch statement over a type variable that is used to call individual construction code. The duplicated code could perhaps be eliminated by applying Transform Conditionals to Polymorphism.</p>
</div>
</div>
<div class="sect3">
<h4 id="known-uses-19"><a class="anchor" href="#known-uses-19"></a>Known Uses</h4>
<div class="paragraph">
<p>The pattern has been applied in biological research to detect DNA sequences [PK82]. The Dotplot tool [Hel95] has been used to detect similarities in manual pages, literary texts and names from file systems. In the FAMOOS project, the pattern has been applied to build Duploc, a tool for identifying duplication in software source code [DRD99]. The Dup tool [Bak92] has been used to investigated the source code of the X-Window system and uses a dotplot matrix graphical representation.</p>
</div>
</div>
<div class="sect3">
<h4 id="related-patterns-20"><a class="anchor" href="#related-patterns-20"></a>Related Patterns</h4>
<div class="paragraph">
<p>Once you have detected duplicated code, numerous refactoring patterns may apply, in particular Extract Method [p. 291].</p>
</div>
<div class="paragraph">
<p>Very often duplicated code arises because clients assume too many responsibilities. In that case, Move Behavior Close to Data [p. 221] will help you to eliminate the duplication.</p>
</div>
<div class="paragraph">
<p>Dotplots also help to detect large conditional constructs. You should probably Transform Conditionals to Polymorphism to eliminate these conditionals and thereby achieve a more flexible design.</p>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="redistribute-responsibilities"><a class="anchor" href="#redistribute-responsibilities"></a>9. Redistribute Responsibilities</h2>
<div class="sectionbody">
<div class="paragraph">
<p>You are responsible for reengineering the information system that manages all employee records for a large public administration. Due to recent political upheavals, you know that there will be many changes required in the system to cope with privatization, new laws, and new regulations, but you do not know exactly what they will be. The existing system consists of a nominally object-oriented reimplementation of an older procedural system. The code contains many pseudo-objects: data containers masquerading as objects, and big, procedural âgod classesâ that implement most of a the logic of individual subsystems. One class, called TaxRevision2000, has a single method consisting essentially of a case statement that is 3000 lines long.</p>
</div>
<div class="paragraph">
<p>As long as the system was relatively stable, this design posed no particular problems, but now you see that even relatively modest changes to system require months of planning, testing and debugging due to weak encapsulation of data. You are convinced that migrating to a more objectoriented design will make the system more robust and easier to adapt to future requirements. But how do you know where the problems lie? Which responsibilities should be redistributed? Which data containers should you redesign, which ones should you wrap, and which ones are better left alone?</p>
</div>
<div class="sect2">
<h3 id="forces-6"><a class="anchor" href="#forces-6"></a>Forces</h3>
<div class="ulist">
<ul>
<li>
<p>Data containers (objects that just provide access to data, but no own behavior) are a simple and convenient way to share information between many subsystems. Among others, data containers are the easiest way to provide access to database entities.</p>
</li>
<li>
<p>However, data containers expose the data representation, hence are difficult to change when many application components depend on them. <em>Consequently, a proliferation of data containers leads to fragile navigation code in the implementation of business logic.</em></p>
</li>
<li>
<p>It is hard to teach an old dog new tricks. Many designers received a training in functional decomposition and will use the same habits when doing an object design.</p>
</li>
<li>
<p>However, functional decomposition tends to generate god classes, <em>i.e.</em>, big classes that do all of the work and have a myriad of tiny provider classes around of it. God classes are hard to extend, modify or subclass because such changes affect large numbers of other methods or instance variables.</p>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="overview-7"><a class="anchor" href="#overview-7"></a>Overview</h3>
<div class="paragraph">
<p>This cluster deals with problems of misplaced responsibilities. The two extreme cases are <em>data containers</em>, classes that are nothing but glorified data structures and have almost no identifiable responsibilities, and <em>god classes</em>, procedural monsters that assume too many responsibilities.</p>
</div>
<div class="paragraph">
<p>Although there are sometimes borderlines cases where data containers and god classes may be tolerated, particularly if they are buried in a stable part of the system which will not change, generally they are a sign of a fragile design.</p>
</div>
<div class="paragraph">
<p>Data containers lead to violations of the <em>Law of Demeter</em> (LOD) [LHR88]. In a nutshell, the Law of Demeter provides a number of design guidelines to reduce coupling between distantly-related classes. Although the Law of Demeter has various forms, depending on whether one focusses on objects or classes, and depending on which programming language is being used, the law essentially states that methods should only send messages to instance variables, method arguments, self, super, and the receiver class.</p>
</div>
<div class="paragraph">
<p>Violations of the Law of Demeter typically take the form of <em>navigation code</em> in which an <em>indirect client</em> accesses an <em>indirect provider</em> by accessing either an instance variable or an acquaintance of an <em>intermediate provider</em>. The indirect client and provider are thereby unnecessarily coupled, making future enhancements more difficult to realize (Figure 9.2). The intermediate provider may take the form of a data container or opens its encapsulation by providing accessor methods. Designs with many data containers present often suffer from complex navigation code in which indirect clients may have to navigate through a chain of intermediates to reach the indirect provider.</p>
</div>
<div class="paragraph">
<p><span class="image"><img src="./media/image28.jpg" alt="image" width="432" height="107"></span></p>
</div>
<div class="paragraph">
<p>Figure 9.1: An indirect client violates the Law of Demeter by navigating through an intermediate provider to an indirect provider, unnecessarily coupling the two.</p>
</div>
<div class="paragraph">
<p>Whereas data containers have too few responsibilities, god classes assume too many. A god class can be a single class that implements an entire subsystem, consisting of thousands of lines of code and hundreds of methods and instance variables. Particularly vicious god classes consist of only static instance variables and methods, <em>i.e.</em>, all data and behavior have class scope, and the god class is never instantiated. Such god classes are purely procedural beasts, and are object-oriented in name only.</p>
</div>
<div class="paragraph">
<p>Occasionally some procedural classes known as <em>utility classes</em> are convenient. The best known examples are object-oriented interfaces to math libraries, or collections of algorithms. Real god classes, however, are not libraries, but complete applications or subsystems that controls the entire application execution.</p>
</div>
<div class="paragraph">
<p>God classes and data containers often occur together, with the god class assuming all the control of the application, and treating other classes as glorified data structures. Since they assume too many responsibilities, god classes are hard to understand and maintain. Incremental modification and extension of a god class through inheritance is next to impossible due to the complexity of its interface and the absence of clear subclassing contract.</p>
</div>
<div class="paragraph">
<p>This cluster provides a number of patterns to eliminate data containers and god classes by redistributing responsibilities and thereby improving encapsulation.</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Move Behavior Close to Data [p. 221] moves behavior defined in</p>
</li>
</ul>
</div>
<div class="paragraph">
<p><span class="image"><img src="./media/image29.jpg" alt="image" width="432" height="145"></span></p>
</div>
<div class="paragraph">
<p>Figure 9.2: Data containers are the clearest sign of misplaced responsibilities. These three patterns redistribute responsibilities by moving behavior close to data.</p>
</div>
<div class="paragraph">
<p>indirect clients to an intermediate data container to make it more âobject-likeâ. This pattern not only decouples indirect clients from the contents of the data container, but also typically eliminates duplicated code occurring in multiple clients of the data container.</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Eliminate Navigation Code [p. 230] is technically very similar to Move Behavior Close to Data in terms of the reengineering steps, but is rather different in its intent. This pattern focusses on redistributing responsibilities down chains of data containers to eliminate navigation code.</p>
</li>
<li>
<p>Split Up God Class [p. 239] refactors a procedural god class into a number of simple, more cohesive classes by moving all data to external data containers, applying Move Behavior Close to Data to promote the data containers to objects, and finally removing or deprecating the facade that remains.</p>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="move-behavior-close-to-data"><a class="anchor" href="#move-behavior-close-to-data"></a>9.1 Move Behavior Close to Data</h3>
<div class="paragraph">
<p><strong>Intent</strong> <em>Strengthen encapsulation by moving behavior from indirect clients to the class containing the data it operates on.</em></p>
</div>
<div class="sect3">
<h4 id="problem-33"><a class="anchor" href="#problem-33"></a>Problem</h4>
<div class="paragraph">
<p>How do you transform a class from being a mere data container into a real service provider?</p>
</div>
<div class="paragraph">
<p><em>This problem is difficult because:</em></p>
</div>
<div class="ulist">
<ul>
<li>
<p>Data containers offer only accessor methods or public instance variables, and not real behavior, forcing clients to define the behavior themselves instead of just using it. New clients typically have to reimplement this behavior.</p>
</li>
<li>
<p>If the internal representation of a data container changes, many clients have to be updated.</p>
</li>
<li>
<p>Data containers cannot be used polymorphically since they define no behavior and their interfaces consist mainly of accessor methods. As a consequence, clients will be responsible for deciding which behavior is called for in any given context.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p><em>Yet, solving this problem is feasible because:</em></p>
</div>
<div class="ulist">
<ul>
<li>
<p>You know what operations clients perform with the data.</p>
</li>
</ul>
</div>
</div>
<div class="sect3">
<h4 id="solution-32"><a class="anchor" href="#solution-32"></a>Solution</h4>
<div class="paragraph">
<p>Move behavior defined by indirect clients to the container of the data on which it operates.</p>
</div>
<div class="paragraph">
<p><strong>Detection</strong></p>
</div>
<div class="paragraph">
<p>Look for:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Data containers, <em>i.e.</em>, classes defining mostly public accessor methods and few behavior methods (<em>i.e.</em>, the number of methods is approximately 2 times larger than the number of attributes.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p><span class="image"><img src="./media/image30.jpg" alt="image" width="432" height="250"></span></p>
</div>
<div class="paragraph">
<p>Figure 9.3: Classes that were mere data containers are transformed into real service providers.</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Duplicated client code that manipulates data of separate provider classes. If multiple clients implement <em>different</em> behavior, consider instead applying Transform Client Type Checks [p. 257].</p>
</li>
<li>
<p>Methods in client classes that invoke a sequence of accessor methods (see Eliminate Navigation Code).</p>
</li>
</ul>
</div>
<div class="sect4">
<h5 id="steps-12"><a class="anchor" href="#steps-12"></a>Steps</h5>
<div class="paragraph">
<p>Move Behavior Close to Data makes use of the refactorings Extract Method [p. 291] and Move Method [p. 291], since the behavior in question will have to be extracted from a client method and then moved to a provider class.</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p><em>Identify the client behavior that you want to move</em>, <em>i.e.</em>, the complete method or a part of a method that accesses provider data.</p>
<div class="ulist">
<ul>
<li>
<p>Look for the invocations of the accessor methods of the data container.</p>
</li>
<li>
<p>Look for duplicated code in multiple clients that access the same provider data.</p>
</li>
</ul>
</div>
</li>
<li>
<p><em>Create the corresponding method in the provider class</em>, if it does not already exist. Be sure to check that moving the code will not introduce any naming conflicts. Tools like the Refactoring Browser [RBJ97] automate these steps:</p>
<div class="ulist">
<ul>
<li>
<p>If the extracted functionality is a complete method with arguments, check that the arguments do not conflict with attributes of the provider class. If so, rename the arguments.</p>
</li>
<li>
<p>If the extracted functionality uses temporary variables, check that the local variables do not conflict with attributes or variables in the target scope. If so, rename the temporary variables.</p>
</li>
<li>
<p>Check if the extracted functionality accesses local variables of the client classes (attributes, temporary variables,&#8230;&#8203;), if so, add arguments to the method to represent these client variables.</p>
</li>
</ul>
</div>
</li>
<li>
<p><em>Give an intention-revealing name to the new method.</em> Among others, intention revealing names do not contain references to the class they belong to, because this makes the method less reusable. For instance, instead of defining a method addToSet() on a class Set, it is better to name it simply add(). Similarly, it is not such a good idea to define a method binarySearch() on a class Array, because the method name implies a sorted random access collection, while the name search() does not have such implications.</p>
</li>
<li>
<p>In the client <em>invoke the new provider method</em> with the correct parameters.</p>
</li>
<li>
<p><em>Clean up the client code.</em> In the case the moved functionality was a complete method of the client class:</p>
<div class="ulist">
<ul>
<li>
<p>check all the methods that invoke the old, moved method and ensure that they now call the new provider method instead, and</p>
</li>
<li>
<p>remove the old method from the client or deprecate it. (Deprecate Obsolete Interfaces [p. 193]).</p>
</li>
</ul>
</div>
</li>
</ol>
</div>
<div class="paragraph">
<p>It may be the case that the calling methods defined on the same object have to be also moved to the provider. In such a case repeat the steps for the methods.
1.  <em>Repeat</em> for multiple clients. Note that duplicated code in multiple clients will be removed in step 2, since there is no need to move code that has already been transferred to the provider. In case many similar, but not identical methods are introduced to the provider, consider factoring out the duplicated fragments as protected helper methods.</p>
</div>
</div>
</div>
<div class="sect3">
<h4 id="tradeoffs-33"><a class="anchor" href="#tradeoffs-33"></a>Tradeoffs</h4>
<div class="sect4">
<h5 id="pros-32"><a class="anchor" href="#pros-32"></a>Pros</h5>
<div class="ulist">
<ul>
<li>
<p>Data containers are converted to service providers with clear responsibilities.</p>
</li>
<li>
<p>The service providers become more useful to other clients.</p>
</li>
<li>
<p>Clients are no longer responsible for implementing provider behavior.</p>
</li>
<li>
<p>Clients are less sensitive to internal changes of the provider.</p>
</li>
<li>
<p>Code duplication in the system decreases.</p>
</li>
</ul>
</div>
</div>
<div class="sect4">
<h5 id="cons-27"><a class="anchor" href="#cons-27"></a>Cons</h5>
<div class="ulist">
<ul>
<li>
<p>If the moved behavior also accesses client data, turning these accesses into parameters will make the interface of the provider more complex and introduce explicit dependencies from the provider to the client.</p>
</li>
</ul>
</div>
</div>
<div class="sect4">
<h5 id="difficulties-29"><a class="anchor" href="#difficulties-29"></a>Difficulties</h5>
<div class="ulist">
<ul>
<li>
<p>It may not be clear whether client code really should be moved to the data provider. Some classes like Stream or Set are really designed as data providers. Consider moving the code to the provider if:</p>
</li>
</ul>
</div>
<div class="paragraph">
<p><strong>â</strong> the functionality represents a <em>responsibility</em> of the provider. For example, a class Set should provide mathematical operations like union and intersection. On the other hand, a generic Set should not be responsible for operations on sets of Employees. <strong>â</strong> the functionality accesses the attributes of the provider, <strong>â</strong> the functionality is defined by multiple clients.</p>
</div>
<div class="ulist">
<ul>
<li>
<p>If the provider is really designed as a data container, consider defining a new provider class that wraps an instance of the data provider and holds the associated behavior. For example, an EmployeeSet might wrap a Set instance and provide a more suitable interface.</p>
</li>
</ul>
</div>
</div>
<div class="sect4">
<h5 id="when-the-legacy-solution-is-the-solution"><a class="anchor" href="#when-the-legacy-solution-is-the-solution"></a>When the legacy solution is the solution</h5>
<div class="paragraph">
<p>Data containers may have been automatically generated from a database schema to provide an object interface to an existing database. It is almost always a bad idea to modify generated classes, since you will lose your changes if the code ever needs to be regenerated. In this case, you may decide to implement wrapper classes to hold the behavior that should be associated with the generated classes. Such a wrapper would function as an Adapter [p. 293] that converts the generated data container to a real service provider.</p>
</div>
<div class="paragraph">
<p>Sometimes you know that a class defined in a library is missing crucial functionality. For example, an operation convertToCapitals that is missing for class String. In such a case it is typically impossible to add code to the library, so you may have to define it in client class. In C++ for example, it may be the only way to avoid recompilation or to extend a class when the code is not available [ABW98] (p. 378). In Smalltalk you have the possibility to extend or modify the library, however you should pay particular attention to separate the additional code so you can easily merge it with future releases of the library, and quickly detect any conflicts.</p>
</div>
<div class="paragraph">
<p>The intent of the Visitor [p. 296] design pattern states: <em>âRepresent an operation to be performed on the elements of an object structure in a class separate from the elements themselves. Visitor lets you define a new operation without changing the classes of the elements on which it operatesâ</em> [GHJV95]. The Visitor pattern is one of the few cases where you want to have classes access the data of a separate provider class. Visitor allows one to dynamically add new operations to a set of stable classes without having to change them.</p>
</div>
<div class="paragraph">
<p><em>Configuration classes</em> are classes that represent the configuration of a system (<em>e.g.</em>, global parameters, language dependent representation, policies in place). For example, in a graphic tool the default size of the boxes, edges, width of the lines can be stored in a such class and other classes refer to it when needed.</p>
</div>
<div class="paragraph">
<p><em>Mapping classes</em> are classes used to represent mappings between objects and their user interface or database representation. For example, a software metric tool should graphically represent the available metrics in a widget-list so that the user can select the metrics to be computed. In such a case the graphical representation of the different metrics will certainly differ from their internal representation. A mapping class keeps track of the association.</p>
</div>
</div>
</div>
<div class="sect3">
<h4 id="example-14"><a class="anchor" href="#example-14"></a>Example</h4>
<div class="paragraph">
<p>One of the recurring complaints of the customers is that it takes too much time to change the reports generated by the information system. By talking to the maintainers you learn that they find generating the reports quite boring. âItsâs always the same code you have to write,â says Chris, one</p>
</div>
<div class="paragraph">
<p><span class="image"><img src="./media/image31.jpg" alt="image" width="432" height="133"></span></p>
</div>
<div class="paragraph">
<p>Figure 9.4: The Payroll and Telephone classes access the internal representation of the class Employee to print a representation.</p>
</div>
<div class="paragraph">
<p>of the maintainers. âYou fetch a record out of the database, print its fields and then proceed to the next record.â</p>
</div>
<div class="paragraph">
<p>You strongly suspect a case of data-containers and a closer examination of the code confirms your suspicion. Almost all of the classes interfacing with the database contain accessor methods only, and the programs generating reports are forced to use these accessors. One striking example is the case of the Payroll application, which has lots in common with the TelephoneGuide application and you decide to try to move the common functionality to the Employee class.</p>
</div>
<div class="sect4">
<h5 id="before"><a class="anchor" href="#before"></a>Before</h5>
<div class="paragraph">
<p>As shown in Figure 9.4, both the Payroll and TelephoneGuide classes print labels, treating Employee instances as data containers. Thus, Payroll and TelephoneGuide are indirect clients of the attributes of Employee, and define printing code that should have been provided by the Employee class.</p>
</div>
<div class="paragraph">
<p>The following code show how this would look like in Java.</p>
</div>
<div class="paragraph">
<p>|
a|
public class Employee \{ public String[] telephoneNumbers = \{};</p>
</div>
<div class="paragraph">
<p>&#8230;&#8203;</p>
</div>
<div class="paragraph">
<p>public String name() \{ return name;}</p>
</div>
<div class="paragraph">
<p>public String address() \{ return address;}</p>
</div>
<div class="paragraph">
<p>}</p>
</div>
<div class="paragraph">
<p>public class Payroll \{</p>
</div>
<div class="paragraph">
<p>a|
public static Employee currentEmployee;</p>
</div>
<div class="paragraph">
<p>public static void printEmployeeLabel () \{</p>
</div>
<div class="paragraph">
<p>System.out.println(currentEmployee.name()); System.out.println(currentEmployee.address());</p>
</div>
<div class="paragraph">
<p>for (int i=0; i &lt; currentEmployee.telephoneNumbers.length; i++) \{ System.out.print(currentEmployee.telephoneNumbers[i]); System.out.print(" ");}</p>
</div>
<div class="paragraph">
<p>System.out.println("");}</p>
</div>
<div class="paragraph">
<p>&#8230;&#8203;</p>
</div>
<div class="paragraph">
<p>}</p>
</div>
<div class="paragraph">
<p>public class TelephoneGuide \{</p>
</div>
<div class="paragraph">
<p>public static void printEmployeeTelephones (Employee emp) \{</p>
</div>
<div class="paragraph">
<p>System.out.println(emp.name()); System.out.println(emp.address());</p>
</div>
<div class="paragraph">
<p>for (int i=0; i &lt; emp.telephoneNumbers.length&#8201;&#8212;&#8201;1; i++) \{</p>
</div>
<div class="paragraph">
<p>System.out.print(emp.telephoneNumbers[i]); System.out.print(" ---- ");}</p>
</div>
<div class="paragraph">
<p>System.out.print(emp.telephoneNumbers[ emp.telephoneNumbers.length&#8201;&#8212;&#8201;1]); System.out.println("");}</p>
</div>
<div class="olist lowerroman">
<ol class="lowerroman" type="i">
<li>
<p>}</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>|</p>
</div>
<div class="paragraph">
<p>Note that although both print methods implement essentially the same functionality, there are some slight differences. Among others, TelephoneGuide.printEmployeeTelephones uses a different separator while printing out the telephone numbers.</p>
</div>
</div>
<div class="sect4">
<h5 id="steps-13"><a class="anchor" href="#steps-13"></a>Steps</h5>
<div class="paragraph">
<p>The different separators can easily be dealt with by defining a special parameter representing the separator to be used. Thus TelephoneGuide.printEmployeeTelephones gets rewritten as follows.</p>
</div>
<div class="paragraph">
<p>|
a|
public static void printEmployeeTelephones (Employee emp, String separator) \{</p>
</div>
<div class="olist lowerroman">
<ol class="lowerroman" type="i">
<li>
<p>for (int i=0; &#8230;&#8203;</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>System.out.print(separator);}</p>
</div>
<div class="paragraph">
<p>&#8230;&#8203;} &#8230;&#8203;</p>
</div>
<div class="paragraph">
<p>|</p>
</div>
<div class="paragraph">
<p>Next, move the printEmployeeTelephones method from TelephoneGuide to Employee. Thus, copy the code and replace all references to the emp parameter with a direct reference to the attributes and methods. Also, ensure that the new method has an intention revealing name, thus omit the Employee part from the method name, resulting in a method printLabel.</p>
</div>
<div class="paragraph">
<p>|
a|
public class Employee \{</p>
</div>
<div class="paragraph">
<p>&#8230;&#8203;</p>
</div>
<div class="paragraph">
<p>public void printLabel (String separator) \{</p>
</div>
<div class="paragraph">
<p>System.out.println(name);</p>
</div>
<div class="paragraph">
<p>System.out.println(address);</p>
</div>
<div class="paragraph">
<p>for (int i=0; i &lt; telephoneNumbers.length&#8201;&#8212;&#8201;1; i++) \{</p>
</div>
<div class="paragraph">
<p>System.out.print(telephoneNumbers[i]);</p>
</div>
<div class="paragraph">
<p>System.out.print(separator);</p>
</div>
<div class="paragraph">
<p>}</p>
</div>
<div class="paragraph">
<p>System.out.print(telephoneNumbers[telephoneNumbers.length&#8201;&#8212;&#8201;1]); System.out.println("");</p>
</div>
<div class="paragraph">
<p>}
|</p>
</div>
<div class="paragraph">
<p>Then replace the method bodies of Payroll.printEmployeeLabel and TelephoneGuide.printEmployeeTelephones with a simple invocation of the Employee.printLabel method.</p>
</div>
<div class="paragraph">
<p>|
a|
public class Payroll \{</p>
</div>
<div class="paragraph">
<p>&#8230;&#8203;</p>
</div>
<div class="paragraph">
<p>public static void printEmployeeLabel () \{ currentEmployee.printLabel(" ");</p>
</div>
<div class="paragraph">
<p>&#8230;&#8203;}</p>
</div>
<div class="paragraph">
<p>public class TelephoneGuide \{</p>
</div>
<div class="paragraph">
<p>&#8230;&#8203;</p>
</div>
<div class="paragraph">
<p>public static void printEmployeeTelephones (Employee emp) \{ emp.printLabel(" ---- ");}</p>
</div>
<div class="paragraph">
<p>&#8230;&#8203;}
|</p>
</div>
<div class="paragraph">
<p>Finally, verify which other methods refer to the name(), address() and telephoneNumbers. If no such methods exist, consider to declare those methods and attributes as private.</p>
</div>
</div>
<div class="sect4">
<h5 id="after"><a class="anchor" href="#after"></a>After</h5>
<div class="paragraph">
<p>After applying Move Behavior Close to Data the class Employee now provides a printLabel method which takes one argument to represent the different separators (see Figure 9.5). This is a better situation because now</p>
</div>
<div class="paragraph">
<p><span class="image"><img src="./media/image32.jpg" alt="image" width="432" height="150"></span></p>
</div>
<div class="paragraph">
<p>Figure 9.5: The Payroll class uses the public interface of the class Employee to print a representation of Employee; data accessors became private.</p>
</div>
<div class="paragraph">
<p>clients do not rely on the internal representation of Employee. Moreover, by moving the behavior near the data it operates, the class represents a conceptual entity with an emphasis on the services it provides instead of structure it implements.</p>
</div>
</div>
</div>
<div class="sect3">
<h4 id="rationale-27"><a class="anchor" href="#rationale-27"></a>Rationale</h4>
<div class="paragraph">
<p><em>Keep related data and behavior in one place.
â Arthur Riel, Heuristic 2.9 [Rie96]</em></p>
</div>
<div class="paragraph">
<p>Data containers impede evolution because they expose structure and force clients to define their behavior rather than sharing it. By promoting data containers to service providers, you reduce coupling between classes and improve cohesion of data and behavior.</p>
</div>
</div>
<div class="sect3">
<h4 id="related-patterns-21"><a class="anchor" href="#related-patterns-21"></a>Related Patterns</h4>
<div class="paragraph">
<p>Encapsulate Field [p. 291] offers heuristics that help determine where methods should be defined during a design phase. The text offers rationale for applying Move Behavior Close to Data.</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="eliminate-navigation-code"><a class="anchor" href="#eliminate-navigation-code"></a>9.2 Eliminate Navigation Code</h3>
<div class="paragraph">
<p><em>Also Known As:</em> Law of Demeter [LHR88]</p>
</div>
<div class="paragraph">
<p><strong>Intent</strong> <em>Reduce the impact of changes by shifting responsibility down a chain of connected classes.</em></p>
</div>
<div class="sect3">
<h4 id="problem-34"><a class="anchor" href="#problem-34"></a>Problem</h4>
<div class="paragraph">
<p>How do you reduce coupling due to classes that navigate through the object graph?</p>
</div>
<div class="paragraph">
<p><em>This problem is difficult because:</em></p>
</div>
<div class="ulist">
<ul>
<li>
<p>Changes in the interfaces of a class will affect not only direct clients, but also all the indirect clients that navigate to reach it.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p><em>Yet, solving this problem is feasible because:</em></p>
</div>
<div class="ulist">
<ul>
<li>
<p>Navigation code is typically a sign of misplaced responsibilities and violation of encapsulation.</p>
</li>
</ul>
</div>
</div>
<div class="sect3">
<h4 id="solution-33"><a class="anchor" href="#solution-33"></a>Solution</h4>
<div class="paragraph">
<p>Iteratively move behavior defined by an indirect client to the container of the data on which it operates.</p>
</div>
<div class="paragraph">
<p>Note that actual reengineering steps are basically the same as those of Move Behavior Close to Data, but the manifestation of the problem is rather different, so different detection steps apply.</p>
</div>
<div class="sect4">
<h5 id="detection"><a class="anchor" href="#detection"></a>Detection</h5>
<div class="paragraph">
<p>Look for <em>indirect providers</em>:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Each time a class changes, <em>e.g.</em>, by modifying its internal representation or collaborators, not only its direct but also <em>indirect</em> client classes have to be changed.</p>
</li>
<li>
<p>Look for classes that contain a lot public attributes, accessor methods or methods returning as value attributes of the class.</p>
</li>
<li>
<p>Big aggregation hierarchies containing mostly data classes often play the role of indirect provider.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Look for <em>indirect clients</em> that contain a lot of <em>navigation code</em>. Navigation code is of two kinds:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>a <em>sequence of attribute accesses</em>, <em>e.g.</em>,a.b.c.d where b is an attribute of a, c is an attribute of b and d an attribute of c. The result of such a sequence can be assigned to variable or a method of the last object can be invoked, <em>e.g.</em>,a.b.c.d.op(). Such a sequence navigation does not occur in Smalltalk where all the attributes are protected.</p>
</li>
<li>
<p>a <em>sequence of accessor method calls</em>. In Java and C++ such a sequence has the form object.m1().m2().m3() where object is an expression returning an object, m1 is a method of object, m2 a method of the object returned by the invocation of m1, m3 a method of the object returned by the invocation of m2 and so on. In Smalltalk navigation code has the following form receiver m1 m2 &#8230;&#8203; mn The same navigation code sequence is repeated in different methods on the same or different clients.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Navigation code can be detected by simple pattern matching. However, to really detect a method call navigation sequence leading to coupled classes, you should filter out sequences of calls converting one object to another one. For example, the following two Java expressions are not problematic because they deal with object conversion.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java">leftSide().toString()
i.getValue().isShort()</code></pre>
</div>
</div>
<div class="paragraph">
<p>To deal with this case you can:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>look for more than two calls, or</p>
</li>
<li>
<p>eliminate from consideration known object conversion calls, including standard method invocations for converting to and from primitive types.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>The use of additional variables, can sometimes disguise navigation code, so reading the code is often necessary. For instance, the following Java code does not contain a chain of invocations.</p>
</div>
<div class="paragraph">
<p>|
a|
Token token; token = parseTree.token(); if (token.identifier() != null) \{</p>
</div>
<div class="paragraph">
<p>&#8230;&#8203;</p>
</div>
<div class="paragraph">
<p>|</p>
</div>
<div class="paragraph">
<p>However, it is equivalent to the following code, which does contain a chain of invocations</p>
</div>
<div class="paragraph">
<p>|
a|
if (parseTree.token().identifier() != null) \{</p>
</div>
<div class="paragraph">
<p>&#8230;&#8203;</p>
</div>
<div class="paragraph">
<p>|</p>
</div>
<div class="paragraph">
<p><em>Smalltalk.</em> Simply searching for sequences of calls in Smalltalk code can create a lot of noise because Smalltalk does not have predefined control structures but uses messages even for implementing control structures. The above example with the disguised navigation code would read as follows in Smalltalk. (Note the messages isNil and ifFalse:[&#8230;&#8203;])</p>
</div>
<div class="paragraph">
<p>|
a|
| token | token := parseTree token.</p>
</div>
<div class="paragraph">
<p>token identifier isNil ifFalse:[&#8230;&#8203;]</p>
</div>
<div class="paragraph">
<p>|</p>
</div>
<div class="paragraph">
<p>The equivalent version with navigation code becomes.</p>
</div>
<div class="paragraph">
<p>parseTree token identifier isNil ifFalse: [&#8230;&#8203;]</p>
</div>
<div class="paragraph">
<p>The following code segments contain a sequence of invocations but do not pose any problems because the first deals with boolean testing and the second with conversion (abuse of conversion, in fact).</p>
</div>
<div class="paragraph">
<p>(a isNode) &amp; (a isAbstract) ifTrue: [&#8230;&#8203;] aCol asSet asSortedCollection asOrderedCollection</p>
</div>
<div class="paragraph">
<p><em>Java.</em> For Java or C++, primitives data types and control structures are not implemented using objects, so simple pattern matching produces less noise. For example, a simple Unix command like:</p>
</div>
<div class="paragraph">
<p>egrep '.<strong>\(\).</strong>\(\).<strong>\(\).' *.java egrep '.</strong>\..<strong>\..</strong>\..' *.java</p>
</div>
<div class="paragraph">
<p>identifies lines of code like the following ones, which are examples of navigation code coupling between classes, and filters out the conversions mentioned above.</p>
</div>
<div class="paragraph">
<p>a.getAbstraction().getIdentifier().traverse(this)</p>
</div>
<div class="paragraph">
<p>a.abstraction.identifier.traverse(this)</p>
</div>
<div class="paragraph">
<p>More sophisticated matching expressions can reduce the noise produced by the parentheses of casts or other combinations.</p>
</div>
<div class="paragraph">
<p><em>AST Matching.</em> If you have a way to express tree matching, you can detect navigation code. For example, the Rewrite Rule Editor that comes with the Refactoring Browser [RBJ97] can detect navigation code using the pattern</p>
</div>
<div class="paragraph">
<p><span class="image"><img src="./media/image33.png" alt="image" width="342" height="273"></span></p>
</div>
<div class="paragraph">
<p>Figure 9.6: Chains of data containers can be converted into service providers, thereby eliminating navigation code and reducing coupling between classes.</p>
</div>
<div class="paragraph">
<p>â@object âmess1 âmess2 âmess3. To narrow the analysis of the results you should only consider messages that belong to the domain objects and eliminate all the method selectors of libraries objects like (isNil, not, class, ...).</p>
</div>
</div>
<div class="sect4">
<h5 id="steps-14"><a class="anchor" href="#steps-14"></a>Steps</h5>
<div class="paragraph">
<p>The recipe for eliminating navigation code is to recursively Move Behavior Close to Data. Figure 9.6 illustrates the transformation.</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p><em>Identify</em> the navigation code to move.</p>
</li>
<li>
<p><em>Apply</em> Move Behavior Close to Data to remove one level of navigation. (At this point your regression tests should run.)</p>
</li>
<li>
<p><em>Repeat</em>, if necessary.</p>
</li>
</ol>
</div>
<div class="paragraph">
<p><em>Caution.</em> It is important to note that the refactoring process relies on pushing code <em>from the clients to the providers</em>. In the example, from Car to Engine and from Engine to Carburetor. A common mistake is to try to eliminate navigation code by defining accessors at the client class level that access the attributes of the provider attribute values, <em>e.g.</em>, defining an accessor getCarburetor in the class Car. Instead of reducing coupling between the classes, it just increases the number of public accessors and makes the system more complex.</p>
</div>
</div>
</div>
<div class="sect3">
<h4 id="tradeoffs-34"><a class="anchor" href="#tradeoffs-34"></a>Tradeoffs</h4>
<div class="sect4">
<h5 id="pros-33"><a class="anchor" href="#pros-33"></a>Pros</h5>
<div class="ulist">
<ul>
<li>
<p>Chains of dependencies between classes are eliminated, so changes in classes at the lowest level will impact fewer clients.</p>
</li>
<li>
<p>Functionality that was implicit in the system is now named and explicitly available to new clients.</p>
</li>
</ul>
</div>
</div>
<div class="sect4">
<h5 id="cons-28"><a class="anchor" href="#cons-28"></a>Cons</h5>
<div class="ulist">
<ul>
<li>
<p>The systematic application of Eliminate Navigation Code may lead to large interfaces. In particular, if a class defines many instance variables that are collections, then Eliminate Navigation Code would force you to define a large number of additional methods to shield the underlying collections.</p>
</li>
</ul>
</div>
</div>
<div class="sect4">
<h5 id="difficulties-30"><a class="anchor" href="#difficulties-30"></a>Difficulties</h5>
<div class="ulist">
<ul>
<li>
<p>Deciding when to apply Eliminate Navigation Code can be difficult. Defining methods that merely delegate requests to class collaborators may not always be the solution. It may happen that giving away internal information can reduce the interface of a class. For example, if a class implements some well-defined behaviors but also serves as a Facade [p. 293] to other collaborators, it may be simpler to give access to the collaborator directly to reduce the interface of the class.
===== When the legacy solution is the solution</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Navigation code may be the best solution when objects are graphically presented or mapped to a database. In such cases the goal is to really expose and mimic the structural relationships between classes. Eliminating navigation code will be a futile exercise.</p>
</div>
<div class="paragraph">
<p>Figure 9.7: How to remove the unnecessary dependencies between the Reports class and the File and Employee Classes.</p>
</div>
<div class="paragraph">
<p>It is sometimes necessary for a client to talk with its indirect providers. This is true when direct providers play the role of an object server that returns certain objects given certain properties (OOID, keys&#8230;&#8203;). In this situation the client calls the object <em>server</em> (a direct provider) that returns objects (indirect providers) to which the client sends messages.</p>
</div>
</div>
</div>
<div class="sect3">
<h4 id="example-15"><a class="anchor" href="#example-15"></a>Example</h4>
<div class="paragraph">
<p>After having modified the Employee, Payroll and TelephoneGuide classes, you noticed that it took 1/2 an hour to rebuild the whole project. Next time you see Chris (one of the maintainers) you ask him why this build took so long. âYou probably changed the Employee classâ he answers, âwe donât dare to touch that class anymore since so many classes depend on itâ.</p>
</div>
<div class="paragraph">
<p>You decide to examine this Employee class in further detail and find many unnecessary dependencies. For instance (as shown in Figure 9.7) there is a class Reports, implementing one method countHandledFiles, which counts for each Department the number of files that are handled by all of its employees. Unfortunately, there is no direct relationship between Department and File and consequently the ReportHandledFiles must navigate over a departmentâs employees to enumerate all the files and access the handled() status.</p>
</div>
<div class="paragraph">
<p>The Java code below shows the situation before and after applying Eliminate Navigation Code. The bold textual elements highlight problems and the solutions in the before and after situation.</p>
</div>
<div class="sect4">
<h5 id="before-1"><a class="anchor" href="#before-1"></a>Before</h5>
<div class="paragraph">
<p>|
a|
public class Reports \{</p>
</div>
<div class="paragraph">
<p>&#8230;&#8203;</p>
</div>
<div class="paragraph">
<p>public static void countHandledFiles(Department department) \{ int nrHandled = 0, nrUnhandled = 0;</p>
</div>
<div class="paragraph">
<p>for (int i=0; i &lt; department.employees.length; i) \{ for (int j=0; j &lt; department.employees[i].files.length; j) \{ if (department.employees[i].files[j].handled()) \{ nrHandled++;}</p>
</div>
<div class="paragraph">
<p>else \{ nrUnhandled++;}}}</p>
</div>
<div class="paragraph">
<p>&#8230;&#8203;}</p>
</div>
<div class="paragraph">
<p>|</p>
</div>
<div class="paragraph">
<p>The method countHandledFiles counts the number of handled files, by asking the current department its employees and for each of these files. The classes Department and Employee have to declare those attributes public. With this implementation, two problems occur:</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>The Reports class must know how to enumerate the associations between Department, Employee and File, and this information must be accessible in the public interface of each of the classes. If one of these public interfaces change, then this change will affect all associated classes.</p>
</li>
<li>
<p>The method countHandledFiles is implemented by directly accessing the variables employees and files. This unnecessarily couples the class Reports and the classes Department and Employee. If the class Department or Employee change the data-structure used to gold the associated objects, then all the methods in class Reports will have to be adapted.</p>
</li>
</ol>
</div>
</div>
<div class="sect4">
<h5 id="steps-15"><a class="anchor" href="#steps-15"></a>Steps</h5>
<div class="paragraph">
<p>The solution is to extract the nested for loops as separate methods and move them on the appropriate classes. This is actually a two step process.</p>
</div>
<div class="paragraph">
<p>First extract the outer for loop from Reports.countHandledFiles as a separate method (name it countHandledFiles as well) and move it to the class Department.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="directive">public</span> <span class="type">class</span> <span class="class">Department</span> {

...

public <span class="type">void</span> countHandledFiles

(Counter nrHandled, Counter nrUnhandled) { <span class="keyword">for</span> (<span class="type">int</span> i=<span class="integer">0</span>; i &lt; <span class="local-variable">this</span>.employees.length; i++) <span class="error">\</span>{ <span class="keyword">for</span> (<span class="type">int</span> j=<span class="integer">0</span>; j &lt; <span class="local-variable">this</span>.employees[i].files.length; j++) { <span class="keyword">if</span> (<span class="local-variable">this</span>.employees[i].files[j].handled()) { nrHandled.increment();}

<span class="keyword">else</span> { nrUnhandled.increment();}}}}
...}

<span class="directive">public</span> <span class="type">class</span> <span class="class">Reports</span> <span class="error">\</span>{

...

private <span class="directive">static</span> <span class="type">void</span> countHandledFiles(Department department) {

Counter nrHandled = <span class="keyword">new</span> Counter (<span class="integer">0</span>), nrUnhandled = <span class="keyword">new</span> Counter

(<span class="integer">0</span>);

department.countHandledFiles(nrHandled, nrUnhandled);
...}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Next, extract the inner for loop from Department.countHandledFiles (also named countHandledFiles) and move it to the class Employee.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="directive">public</span> <span class="type">class</span> <span class="class">Employee</span> <span class="error">\</span>{

...

public <span class="type">void</span> countHandledFiles

(Counter nrHandled, Counter nrUnhandled) <span class="error">\</span>{ <span class="keyword">for</span> (<span class="type">int</span> j=<span class="integer">0</span>; j &lt; <span class="local-variable">this</span>.files.length; j++) <span class="error">\</span>{ <span class="keyword">if</span> (<span class="local-variable">this</span>.files[j].handled()) <span class="error">\</span>{ nrHandled.increment();}

<span class="keyword">else</span> <span class="error">\</span>{ nrUnhandled.increment();}}}

...}

<span class="directive">public</span> <span class="type">class</span> <span class="class">Department</span> <span class="error">\</span>{

...

public <span class="type">void</span> countHandledFiles

(Counter nrHandled, Counter nrUnhandled) <span class="error">\</span>{ <span class="keyword">for</span> (<span class="type">int</span> i=<span class="integer">0</span>; i &lt; <span class="local-variable">this</span>.employees.length; i++) <span class="error">\</span>{
a|
<span class="local-variable">this</span>.employees[i].countHandledFiles(nrHandled, nrUnhandled);}}

...}</code></pre>
</div>
</div>
<div class="paragraph">
<p>If all direct accesses to the employees and files variables are removed, these attributes can be declared private.</p>
</div>
</div>
</div>
<div class="sect3">
<h4 id="rationale-28"><a class="anchor" href="#rationale-28"></a>Rationale</h4>
<div class="paragraph">
<p><em>A method âMâ of an object âOâ should invoke only the methods of the following kinds of objects.
1.  itself
2.  its parameters
3.  any object it creates/instantiates
4.  its direct component objects
â Law of Demeter</em></p>
</div>
<div class="paragraph">
<p>Navigation code is a well-known symptom of misplaced behavior [LK94] [Sha97] [Rie96] that violates the Law of Demeter [LHR88]. It leads to unnecessary dependencies between classes and as a consequence changing the representation of a class requires <em>all</em> clients to be adapted.</p>
</div>
</div>
<div class="sect3">
<h4 id="related-patterns-22"><a class="anchor" href="#related-patterns-22"></a>Related Patterns</h4>
<div class="paragraph">
<p>Eliminate Navigation Code and Compare Code Mechanically [p. 204] reinforce each other: Navigation code that is spread across different clients spreads duplicated code over the system. Compare Code Mechanically helps to detect this phenomenon. Eliminate Navigation Code brings the duplicated code together, where it is easier to refactor and eliminate.</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="split-up-god-class"><a class="anchor" href="#split-up-god-class"></a>9.3 Split Up God Class</h3>
<div class="paragraph">
<p><em>Also Known As:</em> The Blob [BMMM98], God Class [Rie96]</p>
</div>
<div class="paragraph">
<p><strong>Intent</strong> _Split up a class with too many responsibilities into a number of smaller, cohesive classes._A</p>
</div>
<div class="sect3">
<h4 id="problem-35"><a class="anchor" href="#problem-35"></a>Problem</h4>
<div class="paragraph">
<p>How do you maintain a class that assumes too many responsibilities?</p>
</div>
<div class="paragraph">
<p><em>This problem is difficult because:</em></p>
</div>
<div class="ulist">
<ul>
<li>
<p>By assuming too many responsibilities, a god class monopolizes control of an application. Evolution of the application is difficult because nearly every change touches this class, and affects multiple responsibilities.</p>
</li>
<li>
<p>It is difficult to understand the different abstractions that are intermixed in a god class. Most of the data of the multiple abstractions are accessed from different places.</p>
</li>
<li>
<p>Identifying where to change a feature without impacting the other functionality or other objects in the system is difficult. Moreover, changes in other objects are likely to impact the god class, thus hampering the evolution of the system.</p>
</li>
<li>
<p>It is nearly impossible to change a part of the behavior of a god class in a black-box way.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p><em>Yet, solving this problem is feasible because:</em></p>
</div>
<div class="ulist">
<ul>
<li>
<p>You donât have to fix the problem in one shot.</p>
</li>
<li>
<p>You can use Semantic Wrapper to wrap it and present interfaces.</p>
</li>
</ul>
</div>
</div>
<div class="sect3">
<h4 id="solution-34"><a class="anchor" href="#solution-34"></a>Solution</h4>
<div class="paragraph">
<p>Incrementally redistribute the responsibilities of the god class either to its collaborating classes or to new classes that are pulled out the god class. When there is nothing left of the god class but a facade, remove or deprecate the facade.</p>
</div>
<div class="sect4">
<h5 id="detection-1"><a class="anchor" href="#detection-1"></a>Detection</h5>
<div class="paragraph">
<p>A god class may be recognized in various ways:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>a single huge class treats many other classes as data structures.</p>
</li>
<li>
<p>a ârootâ class or other huge class has a name containing words like âSystemâ, âSubsystemâ, âManagerâ, âDriverâ, or âControllerâ.</p>
</li>
<li>
<p>changes to the system always result in changes to the same class.</p>
</li>
<li>
<p>changes to the class are extremely difficult because you cannot identify which parts of the class they affect.</p>
</li>
<li>
<p>reusing the class is nearly impossible because it covers too many design concerns.</p>
</li>
<li>
<p>the class is a domain class holding the majority of attributes and methods of a system or subsystem. (Note that the threshold is not absolute because some UI frameworks produce big classes with lots of methods, and some database interface classes may need a lot of attributes).</p>
</li>
<li>
<p>the class has an unrelated set of methods working on separated instance variables. The cohesiveness of the class is usually low.</p>
</li>
<li>
<p>the class requires long compile times, even for small modifications.</p>
</li>
<li>
<p>the class is difficult to test due to the many responsibilities it assumes.</p>
</li>
<li>
<p>the class uses a lot of memory.</p>
</li>
<li>
<p>people tell you: âThis is the heart of the systemâ.</p>
</li>
<li>
<p>when you ask for the responsibility of a god class you get various, long and unclear answers.</p>
</li>
<li>
<p>god classes are the nightmare of maintainers, so ask what classes are huge and difficult to maintain. Ask what is the class they would not like to work on. (Variant: Ask people to choose which class they want to work on. The one that everybody avoids may be a god class.)</p>
</li>
</ul>
</div>
</div>
<div class="sect4">
<h5 id="steps-16"><a class="anchor" href="#steps-16"></a>Steps</h5>
<div class="paragraph">
<p>The solution relies on incrementally moving behavior away from the god class. During this process, data containers will become more object-like by acquiring the functionality that the god class was performing on their data. Some new classes will also be extracted from the god class.</p>
</div>
<div class="paragraph">
<p>_<span class="image"><img src="./media/image34.png" alt="image" width="340" height="347"></span></p>
</div>
<div class="paragraph">
<p>Figure 9.8: A god class is refactored in two stages, first by redistributing responsibilities to data containers, or by spawning off new classes, until there is nothing left but a facade, and second by removing the facade.</p>
</div>
<div class="paragraph">
<p>The following steps describe how this process ideally works. Note, however, that god classes can vary greatly in terms of their internal structure, so different techniques may be used to implement the transformation steps. Furthermore, it should be clear that a god class cannot be cured in one shot, so a safe way to proceed is to first transform a god class into a lightweight god class, then into a Facade [p. 293] that delegates behavior to its acquaintances. Finally, clients are redirected to the refactored data containers and the other new objects, and the Facade can be removed. The process is illustrated in figure 39.</p>
</div>
<div class="paragraph">
<p>The following steps are applied iteratively. Be sure to apply Regression Test After Every Change [p. 182]:</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>Identify cohesive subsets of instance variables of the god class, and convert them to external data containers. Change the initialization methods of the god class to refer to instances of the new data containers.</p>
</li>
<li>
<p>Identify all classes used as data containers by the god class (including those created in step 1) and apply Move Behavior Close to Data to promote the data containers into service providers. The original methods of the god class will simply delegate behavior to the moved methods.</p>
</li>
<li>
<p>After iteratively applying steps 1 and 2, there will be nothing left of the god class except a facade with a big initialization method. Shift the responsibility for initialization to a separate class, so only a pure facade is left. Iteratively redirect clients to the objects for which the former god class is now a facade, and either deprecate the facade (see Deprecate Obsolete Interfaces [p. 193]), or simply remove it.</p>
</li>
</ol>
</div>
</div>
</div>
<div class="sect3">
<h4 id="tradeoffs-35"><a class="anchor" href="#tradeoffs-35"></a>Tradeoffs</h4>
<div class="sect4">
<h5 id="pros-34"><a class="anchor" href="#pros-34"></a>Pros</h5>
<div class="ulist">
<ul>
<li>
<p>Application control is no longer centralized in a single monolithic entity but distributed amongst entities that each assume a welldefined set of responsibilities. The design evolves from a procedural design towards an object-oriented design based on autonomous interacting objects.</p>
</li>
<li>
<p>Parts of the original god class are easier to understand and to maintain.</p>
</li>
<li>
<p>Parts of the original god class are more stable because they deal with less issues.</p>
</li>
<li>
<p>Overall compilation time may be reduced due to the simplification of system dependencies.</p>
</li>
</ul>
</div>
</div>
<div class="sect4">
<h5 id="cons-29"><a class="anchor" href="#cons-29"></a>Cons</h5>
<div class="ulist">
<ul>
<li>
<p>Splitting up a god class is a long, slow and tedious process.</p>
</li>
<li>
<p>Maintainers will no longer be able to go to a single god class to locate behavior to fix.</p>
</li>
<li>
<p>The number of classes will increase.</p>
</li>
</ul>
</div>
</div>
<div class="sect4">
<h5 id="difficulties-31"><a class="anchor" href="#difficulties-31"></a>Difficulties</h5>
<div class="ulist">
<ul>
<li>
<p>God class methods may themselves be large, procedural abstractions with too many responsibilities. Such methods may need to be decomposed before cohesive sets of instance variables and methods can be teased out as classes.
===== When the legacy solution is the solution</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>What is riskier? To Split Up God Class or to leave it alone? A real god class is a large, unwieldy beast. Splitting it up into more robust abstractions may introduce considerable cost.</p>
</div>
<div class="paragraph">
<p>The key issue is whether the god class needs to be <em>maintained</em>. If the god class consists of stable, legacy code that rarely needs to be extended or modified, then refactoring it is a questionable investment of effort.</p>
</div>
<div class="paragraph">
<p>Suppose, on the other hand, that it is the <em>clients</em> of the god class that are unstable, and need to be frequently adapted to changing requirements. Then the clients should be shielded from the god class since it is not presenting a clean interface. Consider instead applying Present the Right Interface [p. 187], which will introduce a layer of clean, object-oriented abstractions between the clients and the god class, and may make it easier to evolve the clients.</p>
</div>
</div>
</div>
<div class="sect3">
<h4 id="rationale-29"><a class="anchor" href="#rationale-29"></a>Rationale</h4>
<div class="paragraph">
<p><em>Do not create god classes/objects in your system.
â Arthur Riel, Heuristic 3.2 [Rie96]</em></p>
</div>
<div class="paragraph">
<p>God classes impede evolution because they achieve only a low level of procedural abstraction, so changes may affect many parts of the god class, its data containers and its clients. By splitting a god class up into objectoriented abstractions, changes will tend to be more localized, therefore easier to implement.</p>
</div>
</div>
<div class="sect3">
<h4 id="related-patterns-23"><a class="anchor" href="#related-patterns-23"></a>Related Patterns</h4>
<div class="paragraph">
<p>Foote and Yoder in âBig Ball of Mudâ [FY00] note that god classes (and worse) arise naturally in software development.</p>
</div>
<div class="paragraph">
<p><em>âPeople build BIG BALLS OF MUD because they work. In many domains, they are the only things that have been shown to work. Indeed, they work where loftier approaches have yet to demonstrate that they can compete.
It is not our purpose to condemn BIG BALLS OF MUD. Casual architecture is natural during the early stages of a systemâs evolution. The reader must surely suspect, however, that our hope is that we can aspire to do better. By recognizing the forces and pressures that lead to architectural malaise, and how and when they might be confronted, we hope to set the stage for the emergence of truly durable artifacts that can put architects in dominant positions for years to come. The key is to ensure that the system, its programmers, and, indeed the entire organization, learn about the domain, and the architectural opportunities looming within it, as the system grows and matures.ââ Foote &amp; Yoder [FY00]</em></p>
</div>
<div class="paragraph">
<p>Present the Right Interface [p. 187] is a competing pattern that should be applied when the god class itself rarely needs to be modified or extended.</p>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="transform-conditionals-to-polymorphism"><a class="anchor" href="#transform-conditionals-to-polymorphism"></a>10. Transform Conditionals to Polymorphism</h2>
<div class="sectionbody">
<div class="paragraph">
<p>After duplicated code, data containers and god classes, one of the most striking signs of misplaced responsibilities in object-oriented software is the occurrence of large methods consisting almost entirely of case statements that test the type of some argument.</p>
</div>
<div class="paragraph">
<p>Although case statements are not inherently bad, in object-oriented code they are frequently a sign that the object doing the testing is assuming responsibilities that would better be distributed to the objects being tested. Big conditionals arise naturally over time, just as duplicated code does. As the software is adapted to handle new cases, these cases pop up as conditionals in the code. The problem with these big conditionals is that they can make the code much more fragile in the long term.</p>
</div>
<div class="sect2">
<h3 id="forces-7"><a class="anchor" href="#forces-7"></a>Forces</h3>
<div class="paragraph">
<p>The following forces are at play:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>As requirements change over time, classes in a software system will have to be adapted to handle new, special cases.</p>
</li>
<li>
<p>Adding new classes or subclasses to a system clutters the namespace.</p>
</li>
<li>
<p>The quickest way to adapt a working piece of software to handle a new requirement, is often to add a conditional test for the special case at some point in the code.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>245</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Over time, a simple design tends to get cluttered with many conditional tests for special cases.</p>
</li>
<li>
<p>Case statements group all the variants into a single place instead of spreading the different cases across different classes. However, they lead to design that is less flexible if the case statement appears in more than one place.</p>
</li>
<li>
<p>In some programming languages, case statements are a more conventional idiom to implement varying behavior than polymorphism.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Large conditionals are often a sign that behavior implemented by clients should probably be be shifted to the provider classes. Typically a new method will be introduced to the provider hierarchy, and the individual cases of the conditional statement will each move to one of the provider classes.</p>
</div>
<div class="paragraph">
<p>Although the symptom is readily recognizable, the technical details and the preferred solution may differ considerably. In particular, when the provider hierarchy already exists, and the conditions explicitly check the class of the provider instance, the refactoring is relatively straightforward. But often the provider hierarchy does not exist, and the conditions test attributes that only implicitly model type information. Furthermore, the conditionals may occur not only in external clients, but even in the provider hierarchy itself.</p>
</div>
</div>
<div class="sect2">
<h3 id="overview-8"><a class="anchor" href="#overview-8"></a>Overview</h3>
<div class="paragraph">
<p>Transform Conditionals to Polymorphism is a pattern language that describes how to redistribute responsibilities to eliminate these large conditionals, thereby reducing coupling between classes, and improving flexibility in the face of future changes.</p>
</div>
<div class="paragraph">
<p>This pattern language consists of six patterns which address the most common problems that occur when conditionals are used to simulate polymorphism. Transform Self Type Checks and Transform Client Type Checks address the most typical cases that arise when explicit type checks are performed. Transform Conditionals into Registration occurs less frequently. We also include Factor out State, Factor out Strategy and Introduce Null Object, not in order to copy three established design patterns (State [p. 295], Strategy [p. 295] and Null Object [p. 294]) but rather to show how these design patterns may apply in a reengineering context to eliminate type-checking conditionals.</p>
</div>
<div class="paragraph">
<p>Figure 10.1 summarizes the relationships and the differences between the patterns.</p>
</div>
<div class="paragraph">
<p><span class="image"><img src="./media/image35.jpg" alt="image" width="432" height="202"></span></p>
</div>
<div class="paragraph">
<p>Figure 10.1: Relationships between the patterns constituting Transform Conditionals to Polymorphism.</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Transform Self Type Checks eliminates conditionals over type information in a provider class by <em>introducing subclasses</em> for each type case. The conditional code is replaced by a single polymorphic method call to an instance of one of the new subclasses.</p>
</li>
<li>
<p>Transform Client Type Checks transforms conditionals over type information in a client class by <em>introducing a new method</em> to each of the provider classes. The conditional is replaced by a single polymorphic call to the new method.</p>
</li>
<li>
<p>Factor out State handles a special case of Transform Self Type Checks in which the type information that is being tested may change dynamically. <em>A State [p. 295] object is introduced</em> in the provider class to model the changing state, and the conditional is replaced by a call to a method of the new State object.</p>
</li>
<li>
<p>Factor out Strategy is another special case of Transform Self Type Checks in which the algorithms to handle the various provider cases is factored out by <em>introducing a new Strategy [p. 295] object</em>. The key difference with Factor out State is that the algorithm rather than the state may vary dynamically.</p>
</li>
<li>
<p>Introduce Null Object addresses the special case of Transform Client Type Checks in which the test performed checks whether or not the provider is defined. The conditional is eliminated by <em>introducing a Null Object [p. 294]</em> which implements the appropriate default behavior.</p>
</li>
<li>
<p>Transform Conditionals into Registration addresses the situation in which the conditional is responsible for starting up an external tool based on some attribute of an object to be handled. The solution is to <em>introduce a lookup service</em> where tools are registered as plug-ins. The conditional is then replaced by a simple lookup for the registered plug-in. The solution is then fully dynamic because new plug-ins can be added or removed without any changes to the tool users.</p>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="transform-self-type-checks"><a class="anchor" href="#transform-self-type-checks"></a>10.1 Transform Self Type Checks</h3>
<div class="paragraph">
<p><strong>Intent</strong>
<em>Improve the extensibility of a class by replacing a complex conditional statement with a call to a hook method implemented by subclasses.</em></p>
</div>
<div class="sect3">
<h4 id="problem-36"><a class="anchor" href="#problem-36"></a>Problem</h4>
<div class="paragraph">
<p>A class is hard to modify or extend because it bundles multiple possible behaviors in complex conditional statements that test some attribute representing the current âtypeâ of the object.</p>
</div>
<div class="paragraph">
<p><em>This problem is difficult because:</em></p>
</div>
<div class="ulist">
<ul>
<li>
<p>Conceptually simple extensions require many changes to the conditional code.</p>
</li>
<li>
<p>Subclassing is next to impossible without duplicating and adapting the methods containing the conditional code.</p>
</li>
<li>
<p>Adding a new behavior always results in changes to the same set of methods and always results in adding a new case to the conditional code.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p><em>Yet, solving this problem is feasible because:</em></p>
</div>
<div class="ulist">
<ul>
<li>
<p>Self type checks simulate polymorphism. The conditional code tells you what subclasses you should have instead.</p>
</li>
</ul>
</div>
</div>
<div class="sect3">
<h4 id="solution-35"><a class="anchor" href="#solution-35"></a>Solution</h4>
<div class="paragraph">
<p>Identify the methods with complex conditional branches. In each case, replace the conditional code with a call to a new hook method. Identify or introduce subclasses corresponding to the cases of the conditional. In each of these subclasses, implement the hook method with the code corresponding to that case in the original case statement.</p>
</div>
<div class="sect4">
<h5 id="detection-2"><a class="anchor" href="#detection-2"></a>Detection</h5>
<div class="paragraph">
<p>Most of the time, the type discrimination will jump in your face while you are working on the code, so this means that you will not really need to detect where the checks are made. However, it can be interesting to have simple techniques to quickly assess if unknown parts of a system suffer from similar practices. This can be a valuable source of information to evaluate the state of a system.</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Look for long methods with complex decision structures on some immutable attribute of the object that models type information. In particular look for attributes that are set in the constructor and never changed.</p>
</li>
<li>
<p>Attributes that are used to model type information typically take on values from some enumerated type, or from some finite set of constant values. Look for constant definitions whose names represent entities or concepts that one would usually expect to be associated to classes (like RetiredEmployee or PendingOrder). The conditionals will normally just compare the value of a fixed attribute to one of these constant values.</p>
</li>
<li>
<p>Especially look for classes where <em>multiple</em> methods switch on the same attribute. This is another common sign that the attribute is being used to simulate a type.</p>
</li>
<li>
<p>Since methods containing case statements tend to be long, it may help to use a tool that sorts methods by lines of code or visualizes classes and methods according to their size. Alternatively, search for classes or methods with a large number of conditional statements.</p>
</li>
<li>
<p>For languages like C++ or Java where it is common to store the implementation of a class in a separate file, it is straightforward to search for and count the incidence of conditional keywords (if, else, case, <em>etc.</em>). On a UNIX system, for example,</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>grep 'switch' <code>find . --name "*.cxx" --print</code></p>
</div>
<div class="paragraph">
<p>enumerates all the files in a directory tree with extension .cxx that contain a switch. Other text processing tools like agrep offer possibilities to pose finer granularity queries. Text processing languages like Perl may be better suited for evaluating some kinds of queries, especially those that span multiple lines.</p>
</div>
<div class="ulist">
<ul>
<li>
<p><em>C/C++:</em> Legacy C code may simulate classes by means of union types. Typically the union type will have one data member that encodes the actual type. Look for conditional statements that switch on such data members to decide which type to cast a union to and which behavior to employ.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>In C++ it is fairly common to find classes with data members that are declared as void pointers. Look for conditional statements that cast such pointers to a given type based on the value of some other data member. The type information may be encoded as an enum or (more commonly) as a constant integer value.</p>
</div>
<div class="ulist">
<ul>
<li>
<p><em>Ada:</em> Because Ada 83 did not support polymorphism (or subprogram access types), discriminated record types are often used to simulate</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Figure 10.2: Transformation of explicit type check into self polymorphic method calls.</p>
</div>
<div class="paragraph">
<p>polymorphism. Typically an enumeration type provides the set of variants and the conversion to polymorphism is straightforward in Ada95.</p>
</div>
<div class="ulist">
<ul>
<li>
<p><em>Smalltalk:</em> Smalltalk provides only a few ways to manipulate types. Look for applications of the methods isMemberOf: and isKindOf:, which signal explicit type-checking. Type checks might also be made with tests like self class = anotherClass, or with property tests throughout the hierarchy using methods like isSymbol, isString, isSequenceable, isInteger.</p>
</li>
</ul>
</div>
</div>
<div class="sect4">
<h5 id="steps-17"><a class="anchor" href="#steps-17"></a>Steps</h5>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>Identify the class to transform and the different conceptual classes that it implements. An enumeration type or set of constants will probably document this well.</p>
</li>
<li>
<p>Introduce a new subclass for each behavior that is implemented (see Figure 10.2). Modify clients to instantiate the new subclasses rather than the original class. Run the tests.</p>
</li>
<li>
<p>Identify all methods of the original class that implement varying behavior by means of conditional statements. If the conditionals are surrounded by other statements, move them to separate, protected hook methods. When each conditional occupies a method of its own, run the tests.</p>
</li>
<li>
<p>Iteratively move the cases of the conditionals down to the corresponding subclasses, periodically running the tests.</p>
</li>
<li>
<p>The methods that contain conditional code should now all be empty. Replace these by abstract methods and run the tests.</p>
</li>
<li>
<p>Alternatively, if there are suitable default behaviors, implement these at the root of the new hierarchy.</p>
</li>
<li>
<p>If the logic required to decide which subclass to instantiate is nontrivial, consider encapsulating this logic as a factory method of the new hierarchy root. Update clients to use the new factory method and run the tests.</p>
</li>
</ol>
</div>
</div>
</div>
<div class="sect3">
<h4 id="tradeoffs-36"><a class="anchor" href="#tradeoffs-36"></a>Tradeoffs</h4>
<div class="sect4">
<h5 id="pros-35"><a class="anchor" href="#pros-35"></a>Pros</h5>
<div class="ulist">
<ul>
<li>
<p>New behaviors can now be added in a incremental manner, without having to change a set of methods of a single class containing all the behavior. A specific behavior can now be understood independently from the other variations.</p>
</li>
<li>
<p>A new behavior represents its data independently from the others, thereby minimizing the possible interference and increasing the understandability of the separated behaviors.</p>
</li>
<li>
<p>All behaviors now share a common interface, thereby improving their readability.</p>
</li>
</ul>
</div>
</div>
<div class="sect4">
<h5 id="cons-30"><a class="anchor" href="#cons-30"></a>Cons</h5>
<div class="ulist">
<ul>
<li>
<p>All the behaviors are now dispersed into multiple but related abstractions, so getting an overview of the behavior may be more difficult. However, the concepts are related and share the interface represented by the abstract class reducing then the problem.</p>
</li>
<li>
<p>The larger number of classes makes the design more complex, and potentially harder to understand. If the original conditional statements are simple, it may not be worthwhile to perform this transformation.</p>
</li>
<li>
<p>Explicit type checks are not always a problem and we can sometimes tolerate them. Creating new classes increases the number of abstractions in the applications and can clutter namespaces. Hence, explicit type checks may be an alternative to the creation of new classes when:</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Figure 10.3: Combining simple delegation and Transform Self Type Checks when the class cannot be subclassed.</p>
</div>
<div class="ulist">
<ul>
<li>
<p>the set over which the method selection is fixed and will not evolve in the future, and</p>
</li>
<li>
<p>the type check is only made in a few places.</p>
</li>
</ul>
</div>
</div>
<div class="sect4">
<h5 id="difficulties-32"><a class="anchor" href="#difficulties-32"></a>Difficulties</h5>
<div class="ulist">
<ul>
<li>
<p>Since the requisite subclasses do not yet exist, it can be hard to tell when conditionals are being used to simulate multiple types.</p>
</li>
<li>
<p>Wherever instances of the transformed class were originally created, now instances of different subclasses must be created. If the instantiation occurred in client code, that code must now be adapted to instantiate the right class. Factory objects or methods may be needed to hide this complexity from clients.</p>
</li>
<li>
<p>If you do not have access to the source code of the clients, it may be difficult or impossible to apply this pattern since you will not be able to change the calls to the constructors.</p>
</li>
<li>
<p>If the case statements test more than one attribute, it may be necessary to support a more complex hierarchy, possibly requiring multiple inheritance. Consider splitting the class into parts, each with its own hierarchy.</p>
</li>
<li>
<p>When the class containing the original conditionals cannot be subclassed, Transform Self Type Checks can be composed with delegation. The idea is to exploit polymorphism on another hierarchy by moving part of the state and behavior of the original class into a separate class to which the method will delegate, as shown in Figure 10.3.</p>
</li>
</ul>
</div>
</div>
<div class="sect4">
<h5 id="when-the-legacy-solution-is-the-solution-3"><a class="anchor" href="#when-the-legacy-solution-is-the-solution-3"></a>When the legacy solution is the solution</h5>
<div class="paragraph">
<p>There are some situations in which explicit type-checks may nevertheless be the right solution:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>The conditional code may be generated from a special tool. Lexical analysers and parsers, for example, may be automatically generated to contain the kind of conditional code we are trying to avoid. In these cases, however, the generated classes should never be manually extended, but simply regenerated from the modified specifications.</p>
</li>
</ul>
</div>
</div>
</div>
<div class="sect3">
<h4 id="example-16"><a class="anchor" href="#example-16"></a>Example</h4>
<div class="paragraph">
<p>We worked on a complex system that controls large, physical machines by sending them messages. These messages are represented by the class Message and can be of different types.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code>class Message \{ public:

_Message();

set_value(char* text); set_value(int action); void send(Channel c); void receive(Channel c); ...
private: void* data_; int type_;

static const int TEXT = 1; static const int ACTION = 2;

...
}

 a|
Message::send(Channel c) \{ switch (type_) \{ case TEXT:

... case ACTION:

...

} } void Client1::doit() \{ ...

Message * myMessage = new Message();

myMessage-&gt;set_Value("...");

...

}

|</code></pre>
</div>
</div>
<div class="paragraph">
<p>Figure 10.4: Initial design and source code.</p>
</div>
<div class="paragraph">
<p><strong>Before.</strong></p>
</div>
<div class="paragraph">
<p>A message class wraps two different kinds of messages (TEXT and ACTION) that must be serialized to be sent across a network connection as shown in the code and the figure. We would like to be able to send a new kind of message (say VOICE), but this will require changes to several methods of Message as shown in Figure 10.4.</p>
</div>
<div class="paragraph">
<p>|
a|
virtual void send(Channel c) = 0; virtual void receive(Channel c) = 0;</p>
</div>
<div class="paragraph">
<p>&#8230;&#8203;</p>
</div>
<div class="paragraph">
<p>};</p>
</div>
<div class="paragraph">
<p>class Text_Message: public Message</p>
</div>
<div class="paragraph">
<p>\{ public:</p>
</div>
<div class="paragraph">
<p>Text_Message(char* text); void send(Channel c); void receive(Channel c); private: char* text;</p>
</div>
<div class="paragraph">
<p>&#8230;&#8203;</p>
</div>
<div class="paragraph">
<p>};</p>
</div>
<div class="literalblock">
<div class="content">
<pre> a|
public:</pre>
</div>
</div>
<div class="paragraph">
<p>Action_Message(int action); void send(Channel c); void receive(Channel c); private: int action;</p>
</div>
<div class="paragraph">
<p>&#8230;&#8203;</p>
</div>
<div class="paragraph">
<p>};</p>
</div>
<div class="paragraph">
<p>void Client1::doit() \{ &#8230;&#8203;</p>
</div>
<div class="paragraph">
<p>Message * myMessage = new</p>
</div>
<div class="paragraph">
<p>Text_Message("&#8230;&#8203;"); &#8230;&#8203;
}</p>
</div>
<div class="paragraph">
<p>|</p>
</div>
<div class="paragraph">
<p>Figure 10.5: Resulting hierarchy and source code.</p>
</div>
<div class="paragraph">
<p><strong>After.</strong></p>
</div>
<div class="paragraph">
<p>Since Message conceptually implements two different classes, Text_Message and Action_Message, we introduce these as subclasses of Message, as shown in Figure 10.5. We introduce constructors for the new classes, we modify the clients to construct instances of Text_Message and Action_Message rather than Message, and we remove the set_value() methods. Our regression tests should run at this point.</p>
</div>
<div class="paragraph">
<p>Now we find methods that switch on the type variable. In each case, we move the entire case statement to a separate, protected hook method, unless the switch already occupies the entire method. In the case of send(), this is already the case, so we do not have to introduce a hook method. Again, all our tests should still run.</p>
</div>
<div class="paragraph">
<p>Now we iteratively move cases of the case statements from Message to its subclasses. The TEXT case of Message::send() moves to Text_Message::send() and the ACTION case moves to Action_Message::send(). Every time we move such a case, our tests should still run.</p>
</div>
<div class="paragraph">
<p>Finally, since the original send() method is now empty, it can be redeclared to be abstract (<em>i.e.</em>,virtual void send(Channel) = 0). Again, our tests should run.</p>
</div>
</div>
<div class="sect3">
<h4 id="rationale-30"><a class="anchor" href="#rationale-30"></a>Rationale</h4>
<div class="paragraph">
<p>Classes that masquerade as multiple data types make a design harder to understand and extend. The use of explicit type checks leads to long methods that mix several different behaviors. Introducing new behavior then requires changes to be made to all such methods instead of simply specifying one new class representing the new behavior.</p>
</div>
<div class="paragraph">
<p>By transforming such classes to hierarchies that explicitly represent the multiple data types, you improve cohesion by bringing together all the code concerning a single data type, you eliminate a certain amount of duplicated code (<em>i.e.</em>, the conditional tests), and you make your design more transparent, and consequently easier to maintain.</p>
</div>
</div>
<div class="sect3">
<h4 id="related-patterns-24"><a class="anchor" href="#related-patterns-24"></a>Related Patterns</h4>
<div class="paragraph">
<p>In Transform Self Type Checks the condition to be transformed tests type information that is represented as an attribute of the class itself.</p>
</div>
<div class="paragraph">
<p>If the conditional tests <em>mutable</em> state of the host object, consider instead applying Factor out State [p. 266], or possibly Factor out Strategy [p. 270].</p>
</div>
<div class="paragraph">
<p>If the conditional occurs in a <em>client</em> rather than in the provider class itself, consider applying Transform Client Type Checks [p. 257].</p>
</div>
<div class="paragraph">
<p>If the conditional code tests some type attribute of a second object in order to <em>select some third handler object</em>, consider instead applying Transform Conditionals into Registration [p. 277].</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="transform-client-type-checks"><a class="anchor" href="#transform-client-type-checks"></a>10.2 Transform Client Type Checks</h3>
<div class="paragraph">
<p><strong>Intent</strong>
<em>Reduce client/provider coupling by transforming conditional code that tests the type of the provider into a polymorphic call to a new provider method.</em></p>
</div>
<div class="sect3">
<h4 id="problem-37"><a class="anchor" href="#problem-37"></a>Problem</h4>
<div class="paragraph">
<p>How do you reduce the coupling between clients and providers of services, where the clients explicitly check the type of providers and have the responsibility to compose providers code?</p>
</div>
<div class="paragraph">
<p><em>This problem is difficult because:</em></p>
</div>
<div class="ulist">
<ul>
<li>
<p>Adding a new subclass to the provider hierarchy requires making changes to many clients, especially where the tests occur.</p>
</li>
<li>
<p>Clients and providers will tend to be strongly coupled, since clients are performing actions that should be the responsibility of the providers.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p><em>Yet, solving this problem is feasible because:</em></p>
</div>
<div class="ulist">
<ul>
<li>
<p>The conditionals tell you to which classes you should transfer behavior.</p>
</li>
</ul>
</div>
</div>
<div class="sect3">
<h4 id="solution-36"><a class="anchor" href="#solution-36"></a>Solution</h4>
<div class="paragraph">
<p>Introduce a new method to the provider hierarchy. Implement the new method in each subclass of the provider hierarchy by moving the corresponding case of the clients conditional to that class. Replace the entire conditional in the client by a simple call to the new method.</p>
</div>
<div class="sect4">
<h5 id="detection-3"><a class="anchor" href="#detection-3"></a>Detection</h5>
<div class="paragraph">
<p>Apply essentially the same techniques described in Transform Self Type Checks to detect case statements, but look for conditions that test the type of a separate service provider which <em>already</em> implements a hierarchy. You should also look for case statements occurring in different clients of the same provider hierarchy.</p>
</div>
<div class="ulist">
<ul>
<li>
<p>_C[]+:_ Legacy C+ code is not likely to make use of run-time type information (RTTI). Instead, type information will likely be encoded</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>in a data member that takes its value from some enumerated type representing the current class. Look for client code switching on such data members.</p>
</div>
<div class="ulist">
<ul>
<li>
<p><em>Ada:</em> Detecting type tests falls into two cases. If the hierarchy is implemented as a single discriminated record then you will find case statements over the discriminant. If the hierarchy is implemented with tagged types then you cannot write a case statement over the types (they are not discrete); instead an if-then-else structure will be used.</p>
</li>
<li>
<p><em>Smalltalk:</em> As in Transform Self Type Checks, look for applications of isMemberOf: and isKindOf:, and tests like self class = anotherClass.</p>
</li>
<li>
<p><em>Java:</em> Look for applications of the operator instanceof, which tests membership of an object in a specific, known class. Although classes in Java are not objects as in Smalltalk, each class that is loaded into the virtual machine is represented by a single instance of java.lang.Class. It is therefore possible to determine if two objects, x and y belong to the same class by performing the test:</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>x.getClass() == y.getClass()</p>
</div>
<div class="paragraph">
<p>Alternatively, class membership may be tested by comparing class names:</p>
</div>
<div class="paragraph">
<p>x.getClass().getName().equals(y.getClass().getName())</p>
</div>
</div>
<div class="sect4">
<h5 id="steps-18"><a class="anchor" href="#steps-18"></a>Steps</h5>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>Identify the clients performing explicit type checks.</p>
</li>
<li>
<p>Add a new, empty method to the root of the provider hierarchy representing the action performed in the conditional code (see Figure 10.6).</p>
</li>
<li>
<p>Iteratively move a case of the conditional to some provider class, replacing it with a call to that method. After each move, the regression tests should run.</p>
</li>
<li>
<p>When all methods have been moved, each case of the conditional consists of a call to the new method, so replace the entire conditional by a single call to the new method.</p>
</li>
<li>
<p>Consider making the method abstract in the providerâs root. Alternatively implement suitable default behavior here.</p>
</li>
</ol>
</div>
<div class="paragraph">
<p><span class="image"><img src="./media/image36.png" alt="image" width="426" height="351"></span></p>
</div>
<div class="paragraph">
<p>Figure 10.6: Transformation of explicit type check used to determine which methods of a client should be invoked into polymorphic method calls.</p>
</div>
</div>
<div class="sect4">
<h5 id="other-steps-to-consider"><a class="anchor" href="#other-steps-to-consider"></a>Other Steps to Consider</h5>
<div class="ulist">
<ul>
<li>
<p>It may well be that multiple clients are performing exactly the same test and taking the same actions. In this case, the duplicated code can be replaced by a single method call after one of the clients has been transformed. If clients are performing different tests or taking different actions, then the pattern must be applied once for each conditional.</p>
</li>
<li>
<p>If the case statement does not cover all the concrete classes of the provider hierarchy, a new abstract class may need to be introduced as a common superclass of the concerned classes. The new method will then be introduced only for the relevant subtree. Alternatively, if it is not possible to introduce such an abstract class given the existing inheritance hierarchy, consider implementing the method at the root with either an empty default implementation, or one that raises an exception if it is called for an inappropriate class.</p>
</li>
<li>
<p>If the conditionals are nested, the pattern may need to be applied recursively.</p>
</li>
</ul>
</div>
</div>
</div>
<div class="sect3">
<h4 id="tradeoffs-37"><a class="anchor" href="#tradeoffs-37"></a>Tradeoffs</h4>
<div class="sect4">
<h5 id="pros-36"><a class="anchor" href="#pros-36"></a>Pros</h5>
<div class="ulist">
<ul>
<li>
<p>The provider hierarchy offers a new, polymorphic service available to other clients as well.</p>
</li>
<li>
<p>The code of the clients is now better organized and does not have to deal anymore with concerns that are now under the responsibility of the provider.</p>
</li>
<li>
<p>All the code concerning the behavior of a single provider is now together in a single location.</p>
</li>
<li>
<p>The fact that the provider hierarchy offers a uniform interface allows providers to be modified without impacting clients.</p>
</li>
</ul>
</div>
</div>
<div class="sect4">
<h5 id="cons-31"><a class="anchor" href="#cons-31"></a>Cons</h5>
<div class="ulist">
<ul>
<li>
<p>Sometimes it is convenient to see the code handling different cases in a single location. Transform Client Type Checks redistributes the logic to the individual provider classes, with the result that the overview is lost.</p>
</li>
</ul>
</div>
</div>
<div class="sect4">
<h5 id="difficulties-33"><a class="anchor" href="#difficulties-33"></a>Difficulties</h5>
<div class="ulist">
<ul>
<li>
<p>Normally instances of the provider classes should be already have been created so we do not have to look for the creation of the instances, however refactoring the interface will affect all clients of the provider classes and must not be undertaken without considering the full consequences of such an action.</p>
</li>
</ul>
</div>
</div>
<div class="sect4">
<h5 id="when-the-legacy-solution-is-the-solution-4"><a class="anchor" href="#when-the-legacy-solution-is-the-solution-4"></a>When the legacy solution is the solution</h5>
<div class="paragraph">
<p>Client type checks may nevertheless be the right solution when the provider instance does not yet exist or when its class cannot be extended:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>An Abstract Factory [p. 293] object may need to test a type variable in order to know which class to instantiate. For example, a factory may stream objects in from a text file representation, and test some variable that tells it which class the streamed object should belong to.</p>
</li>
<li>
<p>Software that interfaces to a non-object-oriented library, such as a legacy GUI library, may force the developer to simulate the dispatch manually. It is questionable whether, in such cases, it is cost-effective to develop an object-oriented facade to the procedural library.</p>
</li>
<li>
<p>If the provider hierarchy is frozen (<em>e.g.</em>, because the source code is not available), then it will not be possible to transfer behavior to the provider classes. In this case, wrapper classes may be defined to extend the behavior of the provider classes, but the added complexity of defining the wrappers may overwhelm any benefits.</p>
</li>
</ul>
</div>
</div>
</div>
<div class="sect3">
<h4 id="example-17"><a class="anchor" href="#example-17"></a>Example</h4>
<div class="sect4">
<h5 id="before-2"><a class="anchor" href="#before-2"></a>Before</h5>
<div class="paragraph">
<p>The following C++ code illustrates misplaced responsibilities since the client must explicitly type check instances of Telephone to determine what action to perform. The code in bold highlights the difficulties with this approach.</p>
</div>
<div class="paragraph">
<p>|
a|
class Telephone \{ public:</p>
</div>
<div class="paragraph">
<p>enum PhoneType \{</p>
</div>
<div class="paragraph">
<p>POTSPHONE, ISDNPHONE, OPERATORPHONE</p>
</div>
<div class="paragraph">
<p>};</p>
</div>
<div class="paragraph">
<p>Telephone() \{}</p>
</div>
<div class="paragraph">
<p>PhoneType phoneType() \{ return myType; }</p>
</div>
<div class="paragraph">
<p>private:</p>
</div>
<div class="paragraph">
<p>PhoneType myType; protected:</p>
</div>
<div class="paragraph">
<p>void setPhoneType(PhoneType newType) \{ myType = newType; }
};</p>
</div>
<div class="paragraph">
<p>class POTSPhone : public Telephone \{</p>
</div>
<div class="paragraph">
<p>public:</p>
</div>
<div class="paragraph">
<p>POTSPhone() \{ setPhoneType(POTSPHONE); } void tourneManivelle();</p>
</div>
<div class="paragraph">
<p>void call();
};</p>
</div>
<div class="paragraph">
<p>&#8230;&#8203;</p>
</div>
<div class="paragraph">
<p>|</p>
</div>
<div class="paragraph">
<p>|
a|
class ISDNPhone: public Telephone \{ public:</p>
</div>
<div class="paragraph">
<p>_ISDNPhone() \{ setPhoneType(ISDNPHONE);} void initializeLine();</p>
</div>
<div class="paragraph">
<p>void connect();
}; &#8230;&#8203;</p>
</div>
<div class="paragraph">
<p>class OperatorPhone: public Telephone \{ public:</p>
</div>
<div class="paragraph">
<p>OperatorPhone() \{ setPhoneType(OPERATORPHONE); }</p>
</div>
<div class="paragraph">
<p>void operatorMode(bool onOffToggle); void call();</p>
</div>
<div class="paragraph">
<p>};</p>
</div>
<div class="paragraph">
<p>void initiateCalls(Telephone ** phoneArray, int numOfCalls) \{ for(int i = 0; i&lt;numOfCalls ;i++ ) \{ Telephone * p = phoneArray[i];</p>
</div>
<div class="paragraph">
<p>switch(p-&#8594;phoneType()) \{ case Telephone::POTSPHONE: \{ POTSPhone *potsp = (POTSPhone *) p;</p>
</div>
<div class="paragraph">
<p>potsp-&#8594;tourneManivelle();</p>
</div>
<div class="paragraph">
<p>potsp-&#8594;call(); break;</p>
</div>
<div class="paragraph">
<p>}</p>
</div>
<div class="paragraph">
<p>case Telephone::ISDNPHONE: \{ ISDNPhone *isdnp = (ISDNPhone *) p;</p>
</div>
<div class="paragraph">
<p>isdnp-&#8594;initializeLine(); isdnp-&#8594;connect(); break;</p>
</div>
<div class="paragraph">
<p>}</p>
</div>
<div class="paragraph">
<p>case Telephone::OPERATORPHONE: \{ OperatorPhone *opp = (OperatorPhone *) p;</p>
</div>
<div class="paragraph">
<p>opp-&#8594;operatorMode(true);</p>
</div>
<div class="paragraph">
<p>opp-&#8594;call();</p>
</div>
<div class="paragraph">
<p>break;</p>
</div>
<div class="paragraph">
<p>}
default: cerr &lt;&lt; "Unrecognized Phonetype" &lt;&lt; endl;</p>
</div>
<div class="paragraph">
<p>};</p>
</div>
<div class="paragraph">
<p>}</p>
</div>
<div class="paragraph">
<p>}</p>
</div>
<div class="paragraph">
<p>|</p>
</div>
<div class="paragraph">
<p>Figure 10.7: Transforming explicit type checks to polymorphic method invocations.</p>
</div>
</div>
<div class="sect4">
<h5 id="after-1"><a class="anchor" href="#after-1"></a>After</h5>
<div class="paragraph">
<p>After applying the pattern the client code will look like the following. (See also Figure 10.7.)</p>
</div>
<div class="paragraph">
<p>|
a|
class Telephone \{ public:</p>
</div>
<div class="paragraph">
<p>Telephone() \{}</p>
</div>
<div class="paragraph">
<p>virtual void makeCall() = 0;
};</p>
</div>
<div class="paragraph">
<p>Class POTSPhone : public Telephone \{ void tourneManivelle();</p>
</div>
<div class="paragraph">
<p>void call();</p>
</div>
<div class="paragraph">
<p>public:</p>
</div>
<div class="paragraph">
<p>POTSPhone() \{} void makeCall();
};</p>
</div>
<div class="paragraph">
<p>void POTSPhone::makeCall() \{ this-&#8594;tourneManivelle();</p>
</div>
<div class="paragraph">
<p>this-&#8594;call();</p>
</div>
<div class="paragraph">
<p>}</p>
</div>
<div class="paragraph">
<p>class ISDNPhone: public Telephone \{</p>
</div>
<div class="paragraph">
<p>a|
void initializeLine(); void connect();</p>
</div>
<div class="paragraph">
<p>public:</p>
</div>
<div class="paragraph">
<p>ISDNPhone() \{ } void makeCall();</p>
</div>
<div class="paragraph">
<p>};</p>
</div>
<div class="paragraph">
<p>void ISDNPhone::makeCall() \{ this-&#8594;initializeLine();</p>
</div>
<div class="paragraph">
<p>this-&#8594;connect();</p>
</div>
<div class="paragraph">
<p>}</p>
</div>
<div class="paragraph">
<p>class OperatorPhone: public Telephone \{ void operatorMode(bool onOffToggle); void call();</p>
</div>
<div class="paragraph">
<p>public:</p>
</div>
<div class="paragraph">
<p>_OperatorPhone() \{ }</p>
</div>
<div class="paragraph">
<p>void makeCall();
};</p>
</div>
<div class="paragraph">
<p>void OperatorPhone::makeCall() \{ this-&#8594;operatorMode(true); this-&#8594;call();</p>
</div>
<div class="paragraph">
<p>}</p>
</div>
<div class="paragraph">
<p>void initiateCalls(Telephone ** phoneArray, int numOfCalls) \{ for(int i = 0; i&lt;numOfCalls ;i++ ) \{ phoneArray[i]-&#8594;makeCall();</p>
</div>
<div class="paragraph">
<p>}</p>
</div>
<div class="paragraph">
<p>}</p>
</div>
<div class="paragraph">
<p>|</p>
</div>
</div>
</div>
<div class="sect3">
<h4 id="rationale-31"><a class="anchor" href="#rationale-31"></a>Rationale</h4>
<div class="paragraph">
<p>Riel states, âExplicit case analysis on the type of an object is usually an error. The designer should use polymorphism in most of these casesâ [Rie96]. Indeed, explicit type checks in clients are a sign of misplaced responsibilities since they increase coupling between clients and providers. Shifting these responsibilities to the provider will have the following consequences:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>The client and the provider will be more weakly coupled since the client will only need to explicitly know the root of the provider hierarchy instead of all of its concrete subclasses.</p>
</li>
<li>
<p>The provider hierarchy may evolve more gracefully, with less chance of breaking client code.</p>
</li>
<li>
<p>The size and complexity of client code is reduced. The collaborations between clients and providers become more abstract.</p>
</li>
<li>
<p>Abstractions implicit in the old design (<em>i.e.</em>, the actions of the conditional cases) will be made explicit as methods, and will be available to other clients.</p>
</li>
<li>
<p>Code duplication may be reduced (if the same conditionals occur multiply).</p>
</li>
</ul>
</div>
</div>
<div class="sect3">
<h4 id="related-patterns-25"><a class="anchor" href="#related-patterns-25"></a>Related Patterns</h4>
<div class="paragraph">
<p>InTransform Client Type Checks the conditional is made on the type information of a provider class. The same situation occurs in Introduce Null Object where the conditional tests over null value before invoking the methods. From this point of view, Introduce Null Object is a specialization of Transform Client Type Checks.</p>
</div>
<div class="paragraph">
<p>Transform Conditionals into Registration handles the special case in which the clientâs conditional is used to select a third object (typically an external application or tool) to handle the argument.</p>
</div>
<div class="paragraph">
<p>Replace Conditional with Polymorphism [p. 292] is the core refactoring of this reengineering pattern, so the reader may refer to the steps described in [FBB<sup>+</sup>99].</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="factor-out-state"><a class="anchor" href="#factor-out-state"></a>10.3 Factor out State</h3>
<div class="paragraph">
<p><strong>Intent</strong>
<em>Eliminate complex conditional code over an objectâs state by applying the State design pattern.</em></p>
</div>
<div class="sect3">
<h4 id="problem-38"><a class="anchor" href="#problem-38"></a>Problem</h4>
<div class="paragraph">
<p>How do you make a class whose behavior depends on a complex evaluation of its current state more extensible?</p>
</div>
<div class="paragraph">
<p><em>This problem is difficult because:</em></p>
</div>
<div class="ulist">
<ul>
<li>
<p>There are several complex conditional statements spread out over the methods of the object. Adding new behavior may affect these conditionals in subtle ways.</p>
</li>
<li>
<p>Whenever new possible states are introduced, all the methods that test state have to be modified.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p><em>Yet, solving this problem is feasible because:</em></p>
</div>
<div class="ulist">
<ul>
<li>
<p>The objectâs instance variables are typically used to model different abstract states, each of which has its own behavior. If you can identify these abstract states, you can factor the state and the behavior out into a set of simpler, related classes.</p>
</li>
</ul>
</div>
</div>
<div class="sect3">
<h4 id="solution-37"><a class="anchor" href="#solution-37"></a>Solution</h4>
<div class="paragraph">
<p>Apply the State [p. 295] pattern, <em>i.e.</em>, encapsulate the state-dependent behavior into separate objects, delegate calls to these objects and keep the state of the object consistent by referring to the right instance of these state objects (see figure 47).</p>
</div>
<div class="paragraph">
<p>As in Transform Self Type Checks, transform complex conditional code that tests over quantified states into delegated calls to state classes. Apply the State [p. 295] pattern, delegating each conditional case to a separate State object. We invite the reader to read State and State Patterns [p. 295] for a deep description of the problem and discussion [GHJV95] [ABW98] [DA97]. Here we only focus on the reengineering aspects of the pattern.</p>
</div>
<div class="sect4">
<h5 id="steps-19"><a class="anchor" href="#steps-19"></a>Steps</h5>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>Identify the interface of a state and the number of states.</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>Figure 10.8: Transformation to go from a state pattern simulated using explicit state conditional to a situation where the state pattern has been applied.</p>
</div>
<div class="paragraph">
<p>If you are lucky, each conditional will partition the state space in the same way, and the number of states will equal the number of cases in each conditional. In case the conditionals overlap, a finer partitioning will be required.</p>
</div>
<div class="paragraph">
<p>The interface of a state depends on how the state information is accessed and updated, and may need to be refined in the subsequent steps.</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>Create a new abstract class, State, representing the interface of the state.</p>
</li>
<li>
<p>Create a new class subclass of State for each state.</p>
</li>
<li>
<p>Define methods of the interface identified in Step 1 in each of the state classes by copying the corresponding code of the conditional to the new method. Do not forget to change the state of the instance variable in the Context to refer to the right instance of State class. The State methods have the responsibility to change the Context so that it always refers to the next state instance.</p>
</li>
<li>
<p>Add a new instance variable in the Context class.</p>
</li>
<li>
<p>You may have to have a reference from the State to the Context class to invoke the state transitions from the State classes.</p>
</li>
<li>
<p>Initialize the newly created instance to refer to a default state class instance.</p>
</li>
<li>
<p>Change the methods of the Context class containing the tests to delegate the call to the instance variable.</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>Step 4 can be performed using the Extract Method operation of the Refactoring Browser. Note that after each step, the regression tests should still run. The critical step is the last one, in which behavior is delegated to the new state objects.</p>
</div>
</div>
</div>
<div class="sect3">
<h4 id="tradeoffs-38"><a class="anchor" href="#tradeoffs-38"></a>Tradeoffs</h4>
<div class="sect4">
<h5 id="pros-37"><a class="anchor" href="#pros-37"></a>Pros</h5>
<div class="ulist">
<ul>
<li>
<p><em>Limited Impact.</em> The public interface of the original class does not have to change. Since the state instances are accessed by delegation from the original object, the clients are unaffected. In the straightforward case the application of this pattern has a limited impact on the clients.
===== Cons</p>
<div class="ulist">
<ul>
<li>
<p>The systematic application of this pattern may lead to an explosion in the number of classes.</p>
</li>
<li>
<p>This pattern should not be applied when:</p>
<div class="ulist">
<ul>
<li>
<p>there are too many possible states, or the number of states is not fixed</p>
</li>
<li>
<p>it is hard to determine from the code how and when state transitions occur.</p>
</li>
</ul>
</div>
</li>
</ul>
</div>
</li>
</ul>
</div>
</div>
<div class="sect4">
<h5 id="when-the-legacy-solution-is-the-solution-5"><a class="anchor" href="#when-the-legacy-solution-is-the-solution-5"></a>When the legacy solution is the solution</h5>
<div class="paragraph">
<p>This pattern should not be applied lightly.</p>
</div>
<div class="ulist">
<ul>
<li>
<p>When the states are clearly identified and it is known that they will not be changed, the legacy solution has the advantage of grouping all the state behavior by functionality instead of spreading it over different subclasses.</p>
</li>
<li>
<p>In certain domains, such as parsers, table-driven behavior, encoded as conditionals over state, are well-understood, and factoring out the state objects may just make the code harder to understand, and hence to maintain.</p>
</li>
</ul>
</div>
</div>
</div>
<div class="sect3">
<h4 id="known-uses-20"><a class="anchor" href="#known-uses-20"></a>Known Uses</h4>
<div class="paragraph">
<p>The <em>Design Patterns Smalltalk Companion</em> [ABW98] presents a step-by-step code transformation.</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="factor-out-strategy"><a class="anchor" href="#factor-out-strategy"></a>10.4 Factor out Strategy</h3>
<div class="paragraph">
<p><strong>Intent</strong> <em>Eliminate conditional code that selects a suitable algorithm by applying the Strategy design pattern.</em></p>
</div>
<div class="sect3">
<h4 id="problem-39"><a class="anchor" href="#problem-39"></a>Problem</h4>
<div class="paragraph">
<p>How do you make a class whose behavior depends on testing the value of some variable more extensible?</p>
</div>
<div class="paragraph">
<p><em>This problem is difficult because:</em></p>
</div>
<div class="ulist">
<ul>
<li>
<p>New functionality cannot be added without modifying all the methods containing the conditional code.</p>
</li>
<li>
<p>The conditional code may be spread over several classes which make similar decisions about which algorithm to apply.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p><em>Yet, solving this problem is feasible because:</em></p>
</div>
<div class="ulist">
<ul>
<li>
<p>The alternative behaviors are essentially interchangeable.</p>
</li>
</ul>
</div>
</div>
<div class="sect3">
<h4 id="solution-38"><a class="anchor" href="#solution-38"></a>Solution</h4>
<div class="paragraph">
<p>Apply the Strategy pattern, <em>i.e.</em>, encapsulate the algorithmic dependent behavior into separate objects with polymorphic interfaces and delegate calls to these objects (see Figure 10.9).</p>
</div>
<div class="sect4">
<h5 id="steps-20"><a class="anchor" href="#steps-20"></a>Steps</h5>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>Identify the interface of the strategy class.</p>
</li>
<li>
<p>Create a new abstract class, Strategy, representing the interface of the strategies.</p>
</li>
<li>
<p>Create a new class subclass of Strategy for each identified algorithms.</p>
</li>
<li>
<p>Define methods of the interface identified in Step 1 in each of the strategy classes by copying the corresponding code of the test to the method.</p>
</li>
<li>
<p>Add a new instance variable in the Context class to refer to the current strategy.</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>Figure 10.9: Transformation to go from a state pattern simulated using explicit state conditional to a situation where the state pattern has been applied.</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>You may have to have a reference from the Strategy to the Context class to provide access to the information maintained by the Context</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>(See difficulties).</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>Initialize the newly created instance to refer to a default strategy instance.</p>
</li>
<li>
<p>Change the methods of the Context class containing the tests by eliminating the tests and delegating the call to the instance variable.</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>Step 4 can be performed using the Extract Method operation of the Refactoring Browser. Note that after each step, the regression tests should still run. The critical step is the last one, in which behavior is delegated to the new Strategy objects.</p>
</div>
</div>
</div>
<div class="sect3">
<h4 id="tradeoffs-39"><a class="anchor" href="#tradeoffs-39"></a>Tradeoffs</h4>
<div class="sect4">
<h5 id="pros-38"><a class="anchor" href="#pros-38"></a>Pros</h5>
<div class="ulist">
<ul>
<li>
<p><em>Limited Impact.</em> The public interface of the original class does not have to change. Since the Strategy instances are accessed by delegation from the original object, the clients are unaffected. In a straightforward case the application of this pattern has a limited impact on the clients. However, the Context interface will be reduced because</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>all the previously implemented algorithms are now moved to Strategy classes. So you have to check the invocations of these methods and decide on a per case base.</p>
</div>
<div class="ulist">
<ul>
<li>
<p>After applying this pattern, you will be able to plug new strategies without impacting modifying the interface of the Context. Adding a new strategy does not require to recompile the Context class and its clients.</p>
</li>
<li>
<p>After applying this pattern, the interface of the Context class and the Strategy classes will be clearer.</p>
</li>
</ul>
</div>
</div>
<div class="sect4">
<h5 id="cons-33"><a class="anchor" href="#cons-33"></a>Cons</h5>
<div class="ulist">
<ul>
<li>
<p>The systematic application of this pattern may lead to a class explosion. If you have 20 different algorithms you may not want to have 20 new classes each with only one method.</p>
</li>
<li>
<p>Object explosion. Strategies increase the number of instances in an application.</p>
</li>
</ul>
</div>
</div>
<div class="sect4">
<h5 id="difficulties-34"><a class="anchor" href="#difficulties-34"></a>Difficulties</h5>
<div class="ulist">
<ul>
<li>
<p>There are several ways to share information between the Context and the Strategy objects, and the tradeoffs can be subtle. The information can be passed as argument when the Strategy method is invoked, the Context object itself can be passed as argument, or the Strategy objects can hold a reference to their context. If the relationship between the Context and the Strategy is highly dynamic, then it may be preferable to pass this information as a method argument. More detailed discussions of this issue exist in the literature on the Strategy [p. 295] pattern [GHJV95] [ABW98].
==== Example</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>The <em>Design Patterns Smalltalk Companion</em> [ABW98] presents a step-by-step code transformation.</p>
</div>
</div>
</div>
<div class="sect3">
<h4 id="related-patterns-26"><a class="anchor" href="#related-patterns-26"></a>Related Patterns</h4>
<div class="paragraph">
<p>The symptoms and structure of Factor out Strategy bear comparison with</p>
</div>
<div class="paragraph">
<p>Factor out State. The main difference consists in the fact that the Factor out</p>
</div>
<div class="paragraph">
<p>State identifies behavior with different possible states of objects whereas Factor out Strategy is concerned with interchangeable algorithms that are independent of object state. Factor out Strategy allows one to add new strategies without impacting the existing strategy objects.</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="introduce-null-object"><a class="anchor" href="#introduce-null-object"></a>10.5 Introduce Null Object</h3>
<div class="paragraph">
<p><strong>Intent</strong> <em>Eliminate conditional code that tests for null values by applying the Null Object design pattern.</em></p>
</div>
<div class="sect3">
<h4 id="problem-40"><a class="anchor" href="#problem-40"></a>Problem</h4>
<div class="paragraph">
<p>How can you ease modification and extension of a class in presence of repeated tests for null values?</p>
</div>
<div class="paragraph">
<p><em>This problem is difficult because:</em></p>
</div>
<div class="ulist">
<ul>
<li>
<p>Client methods are always testing that certain values are not null before actually invoking their methods.</p>
</li>
<li>
<p>Adding a new subclass to the client hierarchy requires testing null values before invoking some of the provider methods.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p><em>Yet, solving this problem is feasible because:</em></p>
</div>
<div class="ulist">
<ul>
<li>
<p>The client does not need to know that the provider represents a null value.</p>
</li>
</ul>
</div>
</div>
<div class="sect3">
<h4 id="solution-39"><a class="anchor" href="#solution-39"></a>Solution</h4>
<div class="paragraph">
<p>Apply the Null Object [p. 294] pattern, <em>i.e.</em>, encapsulate the null behavior as a separate provider class so that the client class does not have to perform a null test.</p>
</div>
<div class="sect4">
<h5 id="detection-4"><a class="anchor" href="#detection-4"></a>Detection</h5>
<div class="paragraph">
<p>Look for idiomatic null tests.</p>
</div>
<div class="paragraph">
<p>Null tests may take different forms, depending on the programming language and the kind of entity being tested. In Java, for example, a null object reference has the value null, whereas in C++ a null object pointer has the value 0.</p>
</div>
</div>
<div class="sect4">
<h5 id="steps-21"><a class="anchor" href="#steps-21"></a>Steps</h5>
<div class="paragraph">
<p>Fowler discusses in detail the necessary refactoring steps [FBB<sup>+</sup>99].</p>
</div>
<div class="paragraph">
<p><span class="image"><img src="./media/image37.jpg" alt="image" width="432" height="220"></span></p>
</div>
<div class="paragraph">
<p>Figure 10.10: Transformation from a situation based on explicit test of null value to a situation where a Null Object is introduced.</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>Identify the interface required for the null behavior. (This will normally be identical to that of the non-null object.)</p>
</li>
<li>
<p>Create a new abstract superclass as a superclass of the RealObject class.</p>
</li>
<li>
<p>Create a new subclass of the abstract superclass with a name starting with No or Null.</p>
</li>
<li>
<p>Define default methods into the Null Object class.</p>
</li>
<li>
<p>Initialize the instance variable or structure that was checked to now hold at least an instance of the Null Object class.</p>
</li>
<li>
<p>Remove the conditional tests from the client.</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>If you still want to be able to test for null values in a clean way, you may introduce a query method called isNull in RealObject and Null Object classes, as described by Fowler [FBB<sup>+</sup>99].</p>
</div>
</div>
</div>
<div class="sect3">
<h4 id="tradeoffs-40"><a class="anchor" href="#tradeoffs-40"></a>Tradeoffs</h4>
<div class="sect4">
<h5 id="pros-39"><a class="anchor" href="#pros-39"></a>Pros</h5>
<div class="ulist">
<ul>
<li>
<p>The client code is much simpler after applying the pattern.</p>
</li>
<li>
<p>The pattern is relatively simple to apply since the interface of the provider does not have to be modified.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p><strong>Cons</strong></p>
</div>
<div class="ulist">
<ul>
<li>
<p>The provider hierarchy becomes more complex.</p>
</li>
</ul>
</div>
</div>
<div class="sect4">
<h5 id="difficulties-35"><a class="anchor" href="#difficulties-35"></a>Difficulties</h5>
<div class="ulist">
<ul>
<li>
<p>Multiple clients may not agree on the reasonable default behavior of the Null Object. In this case, multiple Null Object classes may need to be defined.
===== When the legacy solution is the solution</p>
<div class="ulist">
<ul>
<li>
<p>If clients do not agree on a common interface.</p>
</li>
<li>
<p>When very little code uses the variable directly or when the code that uses the variable is well-encapsulated in a single place.</p>
</li>
</ul>
</div>
</li>
</ul>
</div>
</div>
</div>
<div class="sect3">
<h4 id="example-19"><a class="anchor" href="#example-19"></a>Example</h4>
<div class="dlist">
<dl>
<dt class="hdlist1">The following Smalltalk code is taken from Woolf [Woo98]. Initially the code contains explicit null tests</dt>
</dl>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="smalltalk">a|
VisualPart&gt;&gt;objectWantedControl

...

âctrl isNil ifFalse:

[ctrl isControlWanted ifTrue:[self] ifFalse:[nil]]

|

It is then transformed into :

[cols=&quot;&quot;,]
|
a|
VisualPart&gt;&gt;objectWantedControl

...

âctrl isControlWanted ifTrue:[self]

ifFalse:[nil]

Controller&gt;&gt;isControlWanted

âself viewHasCursor

NoController&gt;&gt;isControlWanted

âfalse

|</code></pre>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="transform-conditionals-into-registration"><a class="anchor" href="#transform-conditionals-into-registration"></a>10.6 Transform Conditionals into Registration</h3>
<div class="paragraph">
<p><strong>Intent</strong> <em>Improve the modularity of a system by replacing conditionals in clients by a registration mechanism.</em></p>
</div>
<div class="sect3">
<h4 id="problem-41"><a class="anchor" href="#problem-41"></a>Problem</h4>
<div class="paragraph">
<p>How can you reduce the coupling between <em>tools</em> providing services and <em>clients</em> so that the addition or removal of tools does not lead to changing the code of the clients?</p>
</div>
<div class="paragraph">
<p><em>This problem is difficult because:</em></p>
</div>
<div class="ulist">
<ul>
<li>
<p>Having one single place to look for all the kinds of tools makes it easy to understand the system and easy to add new tools.</p>
</li>
<li>
<p>However, every time you remove a <em>tool</em>, you have to remove one case in some conditional statement, else certain parts (<em>tool clients</em>) would still reflect the presence of the removed tools, leading to fragile systems. Then every time you add a new tool, you have to add a new conditional in all the tool clients.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p><em>Yet, solving this problem is feasible because:</em></p>
</div>
<div class="ulist">
<ul>
<li>
<p>Long conditionals make it easy to identify the different type of tools used.</p>
</li>
</ul>
</div>
</div>
<div class="sect3">
<h4 id="solution-40"><a class="anchor" href="#solution-40"></a>Solution</h4>
<div class="paragraph">
<p>Introduce a <em>registration mechanism</em> to which each tool is responsible for registering itself, and transform the <em>tool clients</em> to query the registration repository instead of performing conditionals.</p>
</div>
<div class="sect4">
<h5 id="steps-22"><a class="anchor" href="#steps-22"></a>Steps</h5>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>Define a class describing <em>plug-in objects</em>, <em>i.e.</em>, an object encapsulating the information necessary for registering a tool. Although the internal structure of this class depends on the purpose of the registration, a plug-in should provide the necessary information so the tool manager can <em>identify</em> it, <em>create</em> instance of the represented tool and <em>invoke</em> methods. To invoke a tool method, a method or a similar mechanism like a block closure or inner class should be stored in the plug-in object.</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>Figure 10.11: Transforming conditionals in tool users by introducing a registration mechanism.</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>Define a class representing the <em>plug-in manager</em>, <em>i.e.</em>, that manages the plug-in objects and that will be queried by the tool clients to check the presence of the tools. This class will certainly be a singleton since the plug-ins representing the tools available should not be lost if a new instance of the plug-in manager is created.</p>
</li>
<li>
<p>For each case of the conditional, define a plug-in <em>object</em> associated with the given tool. This plug-in object should be created and registered automatically when the tool it represents is loaded, and it should be unregistered if and when the tool becomes unavailable. Sometimes information from the tool client should be passed to the tool. The current tool client can be passed as argument when the tool is invoked.</p>
</li>
<li>
<p>Transform the entire conditional expression into a query to the tool manager object. This query should return a tool associated to the query and invoke it to access the wished functionality.</p>
</li>
<li>
<p>Remove any tool client actions that directly activate tools. This behavior is now the responsibility of the plug-in manager.</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>The client or the plug-in object may have the responsibility to invoke a tool. It is better to let the plug-in object having this responsibility because it already holds the responsibility of representing how to represent the tools and let the clients just says that they need a tool action.</p>
</div>
</div>
</div>
<div class="sect3">
<h4 id="example-20"><a class="anchor" href="#example-20"></a>Example</h4>
<div class="paragraph">
<p>In Squeak [IKM<sup>+</sup>97], the FileList is a tool that allows the loading of different kinds of files, such as Smalltalk code, JPEG images, MIDI files, HTML, and so on. Depending on the suffix of the selected file, the FileList proposes different actions to the user. We show in the example the loading of the different file depending on their format.</p>
</div>
<div class="sect4">
<h5 id="before-3"><a class="anchor" href="#before-3"></a>Before</h5>
<div class="paragraph">
<p>The FileList implementation creates different menu items representing the different possible actions depending on the suffix of the files. The dynamic part of the menu is defined in the method menusForFileEnding: which takes a file suffix as its argument and returns a menu item containing the label of the menu item and the name of the corresponding method that should be invoked on the FileList object.</p>
</div>
<div class="paragraph">
<p>|
a|
FileList&gt;&gt;menusForFileEnding: suffix</p>
</div>
<div class="paragraph">
<p>(suffix = 'jpg') ifTrue:</p>
</div>
<div class="paragraph">
<p>[âMenuItem label:'open image in a window'.</p>
</div>
<div class="paragraph">
<p>selector: #openImageInWindow].</p>
</div>
<div class="paragraph">
<p>(suffix = 'morph') ifTrue:</p>
</div>
<div class="paragraph">
<p>[âMenuItem label: 'load as morph'.</p>
</div>
<div class="paragraph">
<p>selector: #openMorphFromFile].</p>
</div>
<div class="paragraph">
<p>(suffix = 'mid') ifTrue:</p>
</div>
<div class="paragraph">
<p>[âMenuItem label: 'play midi file'.</p>
</div>
<div class="paragraph">
<p>selector: #playMidiFile].</p>
</div>
<div class="paragraph">
<p>(suffix = 'st') ifTrue:</p>
</div>
<div class="paragraph">
<p>[âMenuItem label: 'fileIn'.</p>
</div>
<div class="paragraph">
<p>selector: #fileInSelection].</p>
</div>
<div class="paragraph">
<p>(suffix = 'swf') ifTrue:</p>
</div>
<div class="paragraph">
<p>[âMenuItem label: 'open as Flash'.</p>
</div>
<div class="paragraph">
<p>selector: #openAsFlash].</p>
</div>
<div class="paragraph">
<p>(suffix = '3ds') ifTrue:</p>
</div>
<div class="paragraph">
<p>[âMenuItem label: 'Open 3DS file'.</p>
</div>
<div class="paragraph">
<p>selector: #open3DSFile].</p>
</div>
<div class="paragraph">
<p>(suffix = 'wrl') ifTrue:</p>
</div>
<div class="paragraph">
<p>[âMenuItem label: 'open in Wonderland'.</p>
</div>
<div class="paragraph">
<p>selector: #openVRMLFile].</p>
</div>
<div class="paragraph">
<p>(suffix = 'html') ifTrue:</p>
</div>
<div class="paragraph">
<p>a|
[âMenuItem label: 'open in html browser'.</p>
</div>
<div class="paragraph">
<p>selector: #openInBrowser].</p>
</div>
<div class="paragraph">
<p>(suffix = '*') ifTrue:</p>
</div>
<div class="paragraph">
<p>[âMenuItem label: 'generate HTML'.</p>
</div>
<div class="paragraph">
<p>selector:#renderFile].</p>
</div>
<div class="paragraph">
<p>|</p>
</div>
<div class="paragraph">
<p>The methods whose selectors are associated in the menu are implemented in the FileList class. We give two examples here. First the method checks if the tool it needs is available, if not it generates a beep, otherwise the corresponding tool is created and then used to handle the selected file.</p>
</div>
<div class="paragraph">
<p>|
a|
FileList&gt;&gt;openInBrowser</p>
</div>
<div class="paragraph">
<p>Smalltalk at: #Scamper ifAbsent: [â self beep].</p>
</div>
<div class="paragraph">
<p>Scamper openOnUrl: (directory url , fileName encodeForHTTP)
FileList&gt;&gt;openVRMLFile</p>
</div>
<div class="paragraph">
<p>| scene |</p>
</div>
<div class="paragraph">
<p>Smalltalk at: #Wonderland ifAbsent: [â self beep]. scene := Wonderland new. scene makeActorFromVRML: self fullName.</p>
</div>
<div class="paragraph">
<p>|</p>
</div>
</div>
<div class="sect4">
<h5 id="after-2"><a class="anchor" href="#after-2"></a>After</h5>
<div class="paragraph">
<p>The solution is to give each tool the responsibility to register itself and let the FileList query the registry of available tools to find which tool can be invoked.</p>
</div>
<div class="paragraph">
<p><em>Step1.</em> The solution is to first create the class ToolPlugin representing the registration of a given tool. Here we store the suffix files, the menu label and the action to be performed when the tools will be invoked.</p>
</div>
<div class="paragraph">
<p>Object subclass: #ToolPlugin instanceVariableNames: 'fileSuffix menuLabelName blockToOpen '</p>
</div>
<div class="paragraph">
<p><em>Step 2.</em> Then the class PluginManager is defined. It defines a structure to hold the registered tools and defines behavior to add, remove and find registered tool.</p>
</div>
<div class="paragraph">
<p>Object subclass: #PluginManager instanceVariableNames: 'plugins '</p>
</div>
<div class="paragraph">
<p>PluginManager&gt;&gt;initialize plugins := OrderedCollection new.</p>
</div>
<div class="paragraph">
<p>PluginManager&gt;&gt;addPlugin : aPlugin plugins add: aRegistree</p>
</div>
<div class="paragraph">
<p>|
a|
PluginManager&gt;&gt;removePlugin: aBlock</p>
</div>
<div class="paragraph">
<p>_(plugins select: aBlock) copy do: [:each| plugins remove: each]
PluginManager&gt;&gt;findToolFor: aSuffix</p>
</div>
<div class="paragraph">
<p>"return a registree of a tool being able to treat file of format aSuffix"</p>
</div>
<div class="paragraph">
<p>â plugins detect: [:each| each suffix = aSuffix] ifNone: [nil]</p>
</div>
<div class="paragraph">
<p>|</p>
</div>
<div class="paragraph">
<p>Note that the findToolFor: method could take a block to select which of the plug-in objects satisfying it and that it could return a list of plug-in representing all the tools currently able to treat a given file format.</p>
</div>
<div class="paragraph">
<p><em>Step 3.</em> Then the tools should register themselves when they are loaded in memory. Here we present two registrations, showing that a plug-in object is created for each tool. As the tools need some information from the FileList object such as the filename or the directory, the action that has to be performed takes as a parameter the instance of the FileList object that invokes it ([:fileList |&#8230;&#8203;] in the code below).</p>
</div>
<div class="paragraph">
<p>In Squeak, when a class specifies a class (static) initialize method, this method is invoked once the class is loaded in memory. We then specialize the class methods initialize of the classes Scamper and Wonderland to invoke their class methods toolRegistration defined below:</p>
</div>
<div class="paragraph">
<p>|
a|
Scamper class&gt;&gt;toolRegistration</p>
</div>
<div class="paragraph">
<p>PluginManager uniqueInstance addPlugin:</p>
</div>
<div class="paragraph">
<p>(ToolPlugin forFileSuffix: 'html' openingBlock:</p>
</div>
<div class="paragraph">
<p>[:fileList |</p>
</div>
<div class="paragraph">
<p>self openOnUrl:</p>
</div>
<div class="paragraph">
<p>(fileList directory url , fileList fileName encodeForHTTP)]</p>
</div>
<div class="paragraph">
<p>menuLabelName: 'open in html browser')
Wonderland class&gt;&gt;toolRegistration</p>
</div>
<div class="paragraph">
<p>PluginManager uniqueInstance addPlugin: (ToolPlugin</p>
</div>
<div class="paragraph">
<p>a|
forFileSuffix: 'wrl' openingBlock:</p>
</div>
<div class="paragraph">
<p>[:fileList |</p>
</div>
<div class="paragraph">
<p>| scene | scene := self new.
scene makeActorFromVRML: fileList fullName] menuLabelName: 'open in Wonderland')</p>
</div>
<div class="paragraph">
<p>|</p>
</div>
<div class="paragraph">
<p>In Squeak, when a class is removed from the system, it receives the message removeFromSystem. Here we then specialize this method for every tool so that it can unregister itself.</p>
</div>
<div class="paragraph">
<p>|
a|
Scamper class&gt;&gt;removeFromSystem</p>
</div>
<div class="paragraph">
<p>super removeFromSystem.</p>
</div>
<div class="paragraph">
<p>PluginManager uniqueInstance removePlugin: [:plugin| plugin forFileSuffix = 'html']</p>
</div>
<div class="paragraph">
<p>Wonderland class&gt;&gt;removeFromSystem</p>
</div>
<div class="paragraph">
<p>super removeFromSystem.</p>
</div>
<div class="paragraph">
<p>PluginManager uniqueInstance removePlugin: [:plugin| plugin forFileSuffix = 'wrl']</p>
</div>
<div class="paragraph">
<p>|</p>
</div>
<div class="paragraph">
<p><em>Step 4.</em> The FileList object now has to use the ToolsManager to identify the right plug-in object depending on the suffix of the selected file. Then if a tool is available for the given suffix, it creates a menu item specifying that the FileList has to be passed as argument of the action block associated with the tool. In the case where there is no tool a special menu is created whose action is to do nothing.</p>
</div>
<div class="paragraph">
<p>|
a|
FileList&gt;&gt;itemsForFileEnding: suffix</p>
</div>
<div class="paragraph">
<p>| plugin |</p>
</div>
<div class="paragraph">
<p>plugin := PluginManager uniqueInstance findToolFor: suffix ifAbsent: [nil].</p>
</div>
<div class="paragraph">
<p>â plugins isNil ifFalse: [Menu label: (plugin menuLabelName) actionBlock: (plugin openingBlock) withParameter: self]</p>
</div>
<div class="paragraph">
<p>ifTrue: [ErrorMenu new label: 'no tool available for the suffix ', suffix]</p>
</div>
<div class="paragraph">
<p>|</p>
</div>
</div>
</div>
<div class="sect3">
<h4 id="tradeoffs-41"><a class="anchor" href="#tradeoffs-41"></a>Tradeoffs</h4>
<div class="sect4">
<h5 id="pros-40"><a class="anchor" href="#pros-40"></a>Pros</h5>
<div class="ulist">
<ul>
<li>
<p>By applying Transform Conditionals into Registration you obtain a system which is both dynamic and flexible. New tools can be added without impacting tool clients.</p>
</li>
<li>
<p>Tool clients no longer have to check whether a given tool is available. The registration mechanism ensures you that the action can be performed.</p>
</li>
<li>
<p>The interaction protocol between tools and tool clients is now normalized.</p>
</li>
</ul>
</div>
</div>
<div class="sect4">
<h5 id="cons-34"><a class="anchor" href="#cons-34"></a>Cons</h5>
<div class="ulist">
<ul>
<li>
<p>You have to define two new classes, one for the object representing tool representation (plugin) and one for the object managing the registered tools (plugin manager).</p>
</li>
</ul>
</div>
</div>
<div class="sect4">
<h5 id="difficulties-36"><a class="anchor" href="#difficulties-36"></a>Difficulties</h5>
<div class="ulist">
<ul>
<li>
<p>While transforming a branch of the conditional into a plug-in object, you will have to define an action associated with the tools via the plug-in object. To ensure a clear separation and full dynamic registration, this action should be defined on the tool and not anymore on the tool client. However, as the tool may need some information from the tool client, the tool client should be passed to the tool as a parameter when the action is invoked. This changes the protocol between the tool and the tool client from a single invocation on the tool client to a method invocation to the tool with an extra parameter. This also implies that in some cases the tool client class have to define new public or friend methods to allow the tools to access the tool client right information.</p>
</li>
<li>
<p>If each single conditional branch is associated only with a single tool, only one plug-in object is needed. However, if the same tool can be called in different ways we will have to create multiple plug-in objects.</p>
</li>
</ul>
</div>
</div>
<div class="sect4">
<h5 id="when-the-legacy-solution-is-the-solution-7"><a class="anchor" href="#when-the-legacy-solution-is-the-solution-7"></a>When the legacy solution is the solution</h5>
<div class="ulist">
<ul>
<li>
<p>If there is only a single tool client class, if all the tools are always available, and if you will never add or remove a tool at run-time, a conditional is simpler.</p>
</li>
</ul>
</div>
</div>
</div>
<div class="sect3">
<h4 id="related-patterns-27"><a class="anchor" href="#related-patterns-27"></a>Related Patterns</h4>
<div class="paragraph">
<p>Both Transform Conditionals into Registration and Transform Client Type Checks eliminate conditional expressions that decide which method should be invoked on which object. The key difference between the two patterns is that Transform Client Type Checks moves behavior from the client to the service provider, whereas Transform Conditionals into Registration deals with behavior that cannot be moved because it is implemented by an external tool.</p>
</div>
</div>
<div class="sect3">
<h4 id="script-identifying-simulated-switches-in-c"><a class="anchor" href="#script-identifying-simulated-switches-in-c"></a>Script: Identifying simulated switches in C++</h4>
<div class="paragraph">
<p>This Perl script searches the methods in C++ files and lists the occurrences of statements used to simulate case statement with if then else <em>i.e.</em>, matching the following expression: elseXif where X can be replaced by , //&#8230;&#8203; or some white space including carriage return.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="perl">#!/opt/local/bin/perl
$/ = '::';
# new record delim.,
$elseIfPattern = 'else[\s\n]*{?[\s\n]*if';
$linecount = 1; while (&lt;&gt;) { s/(//.*)//g; # remove C++ style comments $lc = (split /\n/) -- 1; # count lines
if(/$elseIfPattern/) {
# count # of lines until first
# occurrence of &quot;else if&quot;
$temp = join(&quot;&quot;,$`,$&amp;);
$l = $linecount + split(/\n/,$temp) -- 1;
# count the occurrences of else--if pairs,
# flag the positions for an eventual printout
$swc = s/(else)([\s\n]*{?[\s\n]*if)
        /$1\n        * HERE *$2/g;
printf &quot;\n%s: Statement with
%2d else--if's, first at: %d&quot;,
$ARGV, $swc, $l;
}
   $linecount += $lc; if(eof) {
   close ARGV; $linecount = 0;

   print &quot;\n&quot;;
}
}</code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="thumbnail-patterns"><a class="anchor" href="#thumbnail-patterns"></a>Thumbnail patterns</h2>
<div class="sectionbody">
<div class="paragraph">
<p>There are many patterns that are not specifically concerned with reengineering, but are still relevant to the reengineering process. In this chapter we have listed only those patterns that are specifically referred to at some point in this book. We have grouped them into the following three categories:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><em>Testing patterns.</em> These patterns help you to focus your testing efforts. Our principle source is a pattern language by DeLano and Rising [DR98], though of course a vast literature is available on the subject. Binder, for example, devotes an entire book to the subject [Bin99].</p>
</li>
<li>
<p><em>Refactoring patterns.</em> These patterns focus on individual refactoring steps that you might applying during a reengineering project, or that you might just as well apply during any forward engineering project. Our principle sources are Fowler <em>et al.</em> [FBB<sup>+</sup>99], and the Robertsâ PhD thesis [Rob99].</p>
</li>
<li>
<p><em>Design patterns.</em> Very frequently the result of a reengineering operation is to put a particular design pattern into place. Here we remind the reader of some of the most common design patterns that pop up in a reengineering context. Our main source is, of course, the <em>Design Patterns</em> book [GHJV95].</p>
</li>
</ul>
</div>
<div class="sect2">
<h3 id="a.1-testing-patterns"><a class="anchor" href="#a.1-testing-patterns"></a>A.1 Testing Patterns</h3>
<div class="sect3">
<h4 id="a.1.1-retest-persistent-problems"><a class="anchor" href="#a.1.1-retest-persistent-problems"></a>A.1.1 Retest Persistent Problems</h4>
<div class="paragraph">
<p><strong>Problem:</strong> What areas of the system should receive concentrated testing, irrespective of the features being implemented?</p>
</div>
<div class="paragraph">
<p><strong>Solution:</strong> Keep a list of persistent problem areas and test cases to verify them, not just for resolving the current problems but also for use in subsequent testing. Test these areas thoroughly, even if there are no new features going into them. Retest regularly using, even one last time before the release goes out of the door.</p>
</div>
<div class="paragraph">
<p><strong>Source:</strong> Patterns for system testing [DR98].</p>
</div>
<div class="paragraph">
<p><strong>Referenced from:</strong> Regression Test After Every Change [p. 182].</p>
</div>
</div>
<div class="sect3">
<h4 id="a.1.2-test-fuzzy-features"><a class="anchor" href="#a.1.2-test-fuzzy-features"></a>A.1.2 Test Fuzzy Features</h4>
<div class="paragraph">
<p><strong>Problem:</strong> How can possible problem areas of the system be pinpointed so that the most problems can be found in the least amount of time?</p>
</div>
<div class="paragraph">
<p><strong>Solution:</strong> Study the documentation available on the system. Look for areas that seems ambiguous or ill-defined. Write test plans that cover these areas more thoroughly and concentrate testing in these areas. If designers can tell you all about a feature, it probably works. Itâs what they canât tell you that needs attention during testing.</p>
</div>
<div class="paragraph">
<p><strong>Source:</strong> Patterns for system testing [DR98].</p>
</div>
<div class="paragraph">
<p><strong>Referenced from:</strong> Grow Your Test Base Incrementally [p. 144].</p>
</div>
</div>
<div class="sect3">
<h4 id="a.1.3-test-old-bugs"><a class="anchor" href="#a.1.3-test-old-bugs"></a>A.1.3 Test Old Bugs</h4>
<div class="paragraph">
<p><strong>Problem:</strong> What areas of the system should be targeted for testing so that the most problems can be found in the least amount of time?</p>
</div>
<div class="paragraph">
<p><strong>Solution:</strong> Examine problem reports from previous releases to help select test cases. Since it would be inefficient to test for all old problems, look at problems reported after the last valid snapshot of the system. Categorize problem reports to see if a trend is determined that could be used for additional testing.</p>
</div>
<div class="paragraph">
<p><strong>Source:</strong> Patterns for system testing [DR98].</p>
</div>
<div class="paragraph">
<p><strong>Referenced from:</strong> Grow Your Test Base Incrementally [p. 144].</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="a.2-refactorings"><a class="anchor" href="#a.2-refactorings"></a>A.2 Refactorings</h3>
<div class="sect3">
<h4 id="a.2.1-encapsulate-field"><a class="anchor" href="#a.2.1-encapsulate-field"></a>A.2.1 Encapsulate Field</h4>
<div class="paragraph">
<p><strong>Also Known As:</strong> Abstract Instance Variable [Rob99].</p>
</div>
<div class="paragraph">
<p><strong>Intent</strong> <em>There is a public field. Make it private and provide accessors.</em></p>
</div>
<div class="paragraph">
<p><strong>Source:</strong> <em>Refactoring: Improving the Design of Existing Code</em> [FBB<sup>+</sup>99].</p>
</div>
<div class="paragraph">
<p><strong>Referenced from:</strong> Eliminate Navigation Code [p. 230].</p>
</div>
</div>
<div class="sect3">
<h4 id="a.2.2-extract-method"><a class="anchor" href="#a.2.2-extract-method"></a>A.2.2 Extract Method</h4>
<div class="paragraph">
<p><strong>Intent</strong> <em>You have a code fragment that can be grouped together. Turn the fragment into a method whose name explains the purpose of the method.</em></p>
</div>
<div class="paragraph">
<p><strong>Source:</strong> <em>Refactoring: Improving the Design of Existing Code</em> [FBB<sup>+</sup>99].</p>
</div>
<div class="paragraph">
<p><strong>Referenced from:</strong> Refactor to Understand [p. 115], Visualize Code as Dotplots [p. 210], Move Behavior Close to Data [p. 221]</p>
</div>
</div>
<div class="sect3">
<h4 id="a.2.3-move-method"><a class="anchor" href="#a.2.3-move-method"></a>A.2.3 Move Method</h4>
<div class="paragraph">
<p><strong>Intent</strong> <em>A method is, or will be, using or used by more features of another class than the class on which it is defined. Create a new method with a similar body in the class it uses most. Either turn the old method into a simple delegation, or remove it altogether.</em></p>
</div>
<div class="paragraph">
<p><strong>Source:</strong> <em>Refactoring: Improving the Design of Existing Code</em> [FBB<sup>+</sup>99].</p>
</div>
<div class="paragraph">
<p><strong>Referenced from:</strong> Refactor to Understand [p. 115], Move Behavior Close to Data [p. 221]</p>
</div>
</div>
<div class="sect3">
<h4 id="a.2.4-rename-attribute"><a class="anchor" href="#a.2.4-rename-attribute"></a>A.2.4 Rename Attribute</h4>
<div class="paragraph">
<p><strong>Intent</strong> <em>Rename an instance variable and update all references to it.</em></p>
</div>
<div class="paragraph">
<p><strong>Source:</strong> <em>Practical Analysis for Refactoring</em> [Rob99].</p>
</div>
<div class="paragraph">
<p><strong>Referenced from:</strong> Refactor to Understand [p. 115].</p>
</div>
</div>
<div class="sect3">
<h4 id="a.2.5-rename-method"><a class="anchor" href="#a.2.5-rename-method"></a>A.2.5 Rename Method</h4>
<div class="paragraph">
<p><strong>Intent</strong> <em>The name of a method does not reveal its purpose. Change the name of the method.</em></p>
</div>
<div class="paragraph">
<p><strong>Source:</strong> <em>Refactoring: Improving the Design of Existing Code</em> [FBB<sup>+</sup>99].</p>
</div>
<div class="paragraph">
<p><strong>Referenced from:</strong> Refactor to Understand [p. 115]</p>
</div>
</div>
<div class="sect3">
<h4 id="a.2.6-replace-conditional-with-polymorphism"><a class="anchor" href="#a.2.6-replace-conditional-with-polymorphism"></a>A.2.6 Replace Conditional with Polymorphism</h4>
<div class="paragraph">
<p><strong>Intent</strong> <em>You have a conditional that chooses different behavior depending on the type of an object. Move each leg of the conditional to an overriding method in a subclass. Make the original method abstract.</em></p>
</div>
<div class="paragraph">
<p><strong>Source:</strong> <em>Refactoring: Improving the Design of Existing Code</em> [FBB<sup>+</sup>99].</p>
</div>
<div class="paragraph">
<p><strong>Referenced from:</strong> Transform Client Type Checks [p. 257]</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="a.3-design-patterns"><a class="anchor" href="#a.3-design-patterns"></a>A.3 Design Patterns</h3>
<div class="sect3">
<h4 id="a.3.1-abstract-factory"><a class="anchor" href="#a.3.1-abstract-factory"></a>A.3.1 Abstract Factory</h4>
<div class="paragraph">
<p><strong>Intent</strong> _Provide an interface for creating families of related or dependent objects without specifying their concrete classes.</p>
</div>
<div class="paragraph">
<p><strong>Source:</strong> <em>Design Patterns</em> [GHJV95].</p>
</div>
<div class="paragraph">
<p><strong>Referenced from:</strong> Look for the Contracts [p. 123], Transform Client Type Checks [p. 257].</p>
</div>
</div>
<div class="sect3">
<h4 id="a.3.2-adapter"><a class="anchor" href="#a.3.2-adapter"></a>A.3.2 Adapter</h4>
<div class="paragraph">
<p><strong>Intent</strong> <em>Convert the interface of a class into another interface clients expect. Adapter lets classes work together that couldnât otherwise because of incompatible interfaces.</em></p>
</div>
<div class="paragraph">
<p><strong>Source:</strong> <em>Design Patterns</em> [GHJV95].</p>
</div>
<div class="paragraph">
<p><strong>Referenced from:</strong> Present the Right Interface [p. 187], Move Behavior Close to Data [p. 221].</p>
</div>
</div>
<div class="sect3">
<h4 id="a.3.3-facade"><a class="anchor" href="#a.3.3-facade"></a>A.3.3 Facade</h4>
<div class="paragraph">
<p><strong>Intent</strong> <em>Provide a unified interface to a set of interfaces in a subsystem. Facade defines a higher-level interface that makes the subsystem easier to use.</em></p>
</div>
<div class="paragraph">
<p><strong>Source:</strong> <em>Design Patterns</em> [GHJV95].</p>
</div>
<div class="paragraph">
<p><strong>Referenced from:</strong> Eliminate Navigation Code [p. 230], Split Up God Class [p. 239].</p>
</div>
</div>
<div class="sect3">
<h4 id="a.3.4-factory-method"><a class="anchor" href="#a.3.4-factory-method"></a>A.3.4 Factory Method</h4>
<div class="paragraph">
<p><strong>Intent</strong> <em>Define an interface for creating an object, but let subclasses decide which class to instantiate. Factory Method lets a class defer instantiation to subclasses.</em></p>
</div>
<div class="paragraph">
<p><strong>Source:</strong> <em>Design Patterns</em> [GHJV95].</p>
</div>
<div class="paragraph">
<p><strong>Referenced from:</strong> Look for the Contracts [p. 123]</p>
</div>
</div>
<div class="sect3">
<h4 id="a.3.5-flyweight"><a class="anchor" href="#a.3.5-flyweight"></a>A.3.5 Flyweight</h4>
<div class="paragraph">
<p><strong>Intent</strong> <em>Use sharing to support large numbers of fine-grained objects efficiently.</em></p>
</div>
<div class="paragraph">
<p><strong>Source:</strong> <em>Design Patterns</em> [GHJV95].</p>
</div>
<div class="paragraph">
<p><strong>Referenced from:</strong> Speculate about Design [p. 87]</p>
</div>
</div>
<div class="sect3">
<h4 id="a.3.6-null-object"><a class="anchor" href="#a.3.6-null-object"></a>A.3.6 Null Object</h4>
<div class="paragraph">
<p><strong>Intent</strong> <em>A Null Object provides a surrogate for another object that shares the same interface but does nothing. Thus, the Null Object encapsulates the implementation decisions of how to do nothing and hides those details from its collaborators</em></p>
</div>
<div class="paragraph">
<p><strong>Source:</strong> <em>Null Object</em> [Woo98].</p>
</div>
<div class="paragraph">
<p><strong>Referenced from:</strong> Introduce Null Object [p. 274].</p>
</div>
</div>
<div class="sect3">
<h4 id="a.3.7-quantity"><a class="anchor" href="#a.3.7-quantity"></a>A.3.7 Quantity</h4>
<div class="paragraph">
<p><strong>Problem:</strong> Representing a value such as 6 feet or $5.</p>
</div>
<div class="paragraph">
<p><strong>Solution:</strong> Use a quantity type that includes both the amount and the unit. Currencies are a kind of unit.</p>
</div>
<div class="paragraph">
<p><strong>Source:</strong> <em>Analysis Patterns: Reusable Objects Models</em> [Fow97].</p>
</div>
<div class="paragraph">
<p><strong>Referenced from:</strong> Analyze the Persistent Data [p. 77].</p>
</div>
</div>
<div class="sect3">
<h4 id="a.3.8-singleton"><a class="anchor" href="#a.3.8-singleton"></a>A.3.8 Singleton</h4>
<div class="paragraph">
<p><strong>Intent</strong> <em>Ensure a class only has one instance, and provide a global point of access to it.</em></p>
</div>
<div class="paragraph">
<p><strong>Source:</strong> <em>Design Patterns</em> [GHJV95].</p>
</div>
<div class="paragraph">
<p><strong>Referenced from:</strong> Read all the Code in One Hour [p. 45].</p>
</div>
</div>
<div class="sect3">
<h4 id="a.3.9-state"><a class="anchor" href="#a.3.9-state"></a>A.3.9 State</h4>
<div class="paragraph">
<p><strong>Intent</strong> <em>Allow an object to alter its behavior when its internal state changes. The object will appear to change its class.</em></p>
</div>
<div class="paragraph">
<p><strong>Source:</strong> <em>Design Patterns</em> [GHJV95].</p>
</div>
<div class="paragraph">
<p><strong>Referenced from:</strong> Factor out State [p. 266].</p>
</div>
</div>
<div class="sect3">
<h4 id="a.3.10-state-patterns"><a class="anchor" href="#a.3.10-state-patterns"></a>A.3.10 State Patterns</h4>
<div class="paragraph">
<p><strong>Intent</strong> <em>The State Patterns pattern language refines and clarifies the State Pattern.</em></p>
</div>
<div class="paragraph">
<p><strong>Source:</strong> <em>State Patterns</em> [DA97].</p>
</div>
<div class="paragraph">
<p><strong>Referenced from:</strong> Factor out State [p. 266].</p>
</div>
</div>
<div class="sect3">
<h4 id="a.3.11-strategy"><a class="anchor" href="#a.3.11-strategy"></a>A.3.11 Strategy</h4>
<div class="paragraph">
<p><strong>Intent</strong> _Define a family of algorithms, encapsulate each one in a separate class, and define each class with the same interface so they can be interchangeable. Strategy lets the algorithm vary independently from clients that use it.</p>
</div>
<div class="paragraph">
<p><strong>Source:</strong> <em>Design Patterns</em> [GHJV95].</p>
</div>
<div class="paragraph">
<p><strong>Referenced from:</strong> Factor out Strategy [p. 270].</p>
</div>
</div>
<div class="sect3">
<h4 id="a.3.12-template-method"><a class="anchor" href="#a.3.12-template-method"></a>A.3.12 Template Method</h4>
<div class="paragraph">
<p><strong>Intent</strong> <em>Define the skeleton of an algorithm in an operation, deferring some steps to subclasses. Template Method lets subclasses redefine certain steps of an algorithm without changing the algorithmâs structure.</em></p>
</div>
<div class="paragraph">
<p><strong>Source:</strong> <em>Design Patterns</em> [GHJV95].</p>
</div>
<div class="paragraph">
<p><strong>Referenced from:</strong> Look for the Contracts [p. 123].</p>
</div>
</div>
<div class="sect3">
<h4 id="a.3.13-visitor"><a class="anchor" href="#a.3.13-visitor"></a>A.3.13 Visitor</h4>
<div class="paragraph">
<p><strong>Intent</strong> <em>Represent an operation to be performed on the elements of an object structure. Visitor lets you define a new operation without changing the classes of the elements on which it operates.</em></p>
</div>
<div class="paragraph">
<p><strong>Source:</strong> <em>Design Patterns</em> [GHJV95].</p>
</div>
<div class="paragraph">
<p><strong>Referenced from:</strong> Move Behavior Close to Data [p. 221].</p>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="bibliography"><a class="anchor" href="#bibliography"></a>Bibliography</h2>
<div class="sectionbody">
<div class="paragraph">
<p>|
|[ABW98] |Sherman R. Alpert, Kyle Brown, and Bobby Woolf. <em>The Design Patterns Smalltalk Companion</em>. Addison Wesley, 1998.
|[Arn92] |Robert S. Arnold. <em>Software Reengineering</em>. IEEE Computer Society Press, Los Alamitos CA, 1992.
|[Bak92] |Brenda S. Baker. A program for identifying duplicated code. <em>Computing Science and Statistics</em>, 24:49â57, 1992.
|[BCK98] |Len Bass, Paul Clements, and Rick Kazman. <em>Software Architecture in Practice</em>. Addison Wesley, 1998.
|[BDS<sup>+</sup>00] |Mike Beedle, Martine Devos, Yonat Sharon, Ken Schwaber, and Jeff Sutherland. Scrum: A pattern language for hyperproductive software development. In Neil Harrison, Brian Foote, and Hans Rohnert, editors, <em>Pattern Languages of Program Design 4</em>, pages 637â652. Addison Wesley, 2000.
|[BE96] |Timothy Ball and Stephen Eick. Software visualization in the large. <em>IEEE Computer</em>, 29(4):33â43, 1996.
|[Bec97] |Kent Beck. <em>Smalltalk Best Practice Patterns</em>. Prentice-Hall, 1997.
|[Bec00] |Kent Beck. <em>Extreme Programming Explained: Embrace Change</em>. Addison Wesley, 2000.
|[BF01] |Kent Beck and Martin Fowler. <em>Planning Extreme Programming</em>. Addison Wesley, 2001.
|[BG98] |Kent Beck and Erich Gamma. Test infected: Programmers love writing tests. <em>Java Report</em>, 3(7):51â56, 1998.
|[BH95] |Olin Bray and Michael M. Hess. Reengineering a configuration management system. <em>IEEE Software</em>, 12(1):55â63, January 1995.
|</p>
</div>
<div class="paragraph">
<p>297</p>
</div>
<div class="paragraph">
<p>|
a|
[Big89] Ted J. Biggerstaff. Design recovery for maintenance and reuse. <em>IEEE Computer</em>, 22:36â49, October 1989.</p>
</div>
<div class="paragraph">
<p>[Bin99] Robert V. Binder. <em>Testing Object-Oriented Systems: Models, Patterns, and Tools</em>. Object Technology Series. Addison Wesley, 1999.</p>
</div>
<div class="paragraph">
<p>[BLM98] M. Blaha, D. LaPlant, and E. Marvak. Requirements for repository software. In <em>Proceedings of WCRE â98</em>, pages 164â 173. IEEE Computer Society, 1998. ISBN: 0-8186-89-67-6.</p>
</div>
<div class="paragraph">
<p>[BMF99] Simon Bennett, Steve McRobb, and Ray Farmer. <em>ObjectOriented System Analysis and Design using UML</em>. McGraw Hill, 1999.</p>
</div>
<div class="paragraph">
<p>[BMMM98] William J. Brown, Raphael C. Malveau, Hays W. McCormick,</p>
</div>
<div class="paragraph">
<p>| |III, and Thomas J. Mowbray. <em>AntiPatterns: Refactoring Software, Architectures, and Projects in Crisis</em>. John Wiley Press, 1998.
|[BMR<sup>+</sup>96] |Frank Buschmann, Regine Meunier, Hans Rohnert, Peter Sommerlad, and Michael Stad. <em>Pattern-Oriented Software Architecture â A System of Patterns</em>. John Wiley Press, 1996.
|[BMW93] |Ted J. Biggerstaff, Bharat G. Mittbander, and Dallas Webster. The concept assignment problem in program understanding. In <em>Proceedings of the 15th international conference on Software Engineering (ICSE 1993)</em>. IEEE Computer, 1993.
|[BMW94] |Ted J. Biggerstaff, Bharat G. Mitbander, and Dallas E. Webster. Program understanding and the concept assignment problem. <em>Communications of the ACM</em>, 37(5):72â82, May 1994.
|[Boe88] |Barry W. Boehm. A spiral model of software development and enhancement. <em>IEEE Computer</em>, 21(5):61â72, 1988.
|[Boo94] |Grady Booch. <em>Object Oriented Analysis and Design with Applications</em>. The Benjamin Cummings Publishing Co. Inc., 2nd edition, 1994.
|[BP94] |Jack Barnard and Art Price. Managing code inspection information. <em>IEEE Software</em>, 11(2):59â69, March 1994.
|[Bro75] |Frederick P. Brooks. <em>The Mythical Man-Month</em>. Addison Wesley, Reading, Mass., 1975.
|[Bro87] a|
Frederick P. Brooks. No silver bullet. <em>IEEE Computer</em>,</p>
</div>
<div class="paragraph">
<p>20(4):10â19, April 1987.</p>
</div>
<div class="paragraph">
<p>|</p>
</div>
<div class="paragraph">
<p>|
|[Bro96] |Kyle Brown. Design reverse-engineering and automated design pattern detection in Smalltalk. Masterâs thesis, North Carolina State University, 1996.
|[BS95] |Michael L. Brodie and Michael Stonebraker. <em>Migrating Legacy Systems</em>. Morgan Kaufmann, 1995.
|[BS97] |David Bellin and Susan Suchman Simone. <em>The CRC Card Book</em>. Addison Wesley, 1997.
|[BW96] |Kyle Brown and Bruce G. Whitenack. Crossing chasms: A pattern language for object-rdbms integration. In John M. Vlissides, James O. Coplien, and Norman L. Kerth, editors, <em>Pattern Languages of Program Design 2</em>, pages 227â238. Addison Wesley, 1996.
|[CHR01] a|
Stephen Cook, Rachel Harrison, and Brian Ritchie. Assessing the evolution of financial management information systems. In <em>ECOOP 2001 Workshop Reader</em>, volume 2323 of <em>LNCS</em>.</p>
</div>
<div class="paragraph">
<p>Springer-Verlag, 2001.</p>
</div>
<div class="paragraph">
<p>|[CI92] |Elliot J. Chikofsky and James H. Cross II. Reverse engineering and design recovery: A taxonomy. In Robert S. Arnold, editor, <em>Software Reengineering</em>, pages 54â58. IEEE Computer Society Press, 1992.
|[Coc93] |Alistair Cockburn. The impact of object-orientation on application development. <em>IBM Systems Journal</em>, 32(3):420â444, March 1993.
|[Con68] |Melvin E. Conway. How do committees invent? <em>Datamation</em>, 14(4):28â31, April 1968.
|[Cop92] |James O. Coplien. <em>Advanced C++: Programming Styles and Idioms</em>. Addison Wesley, 1992.
|[Cop95] |James O. Coplien. A development process generative pattern language. In James O. Coplien and Douglas Schmidt, editors, <em>Pattern Languages of Program Design</em>, pages 183â237. Addison Wesley, 1995.
|[Cor89] |Thomas A. Corbi. Program understanding: Challenge for the 1990âs. <em>IBM Systems Journal</em>, 28(2):294â306, 1989.
|[CRR96] |Debra Cameron, Bill Rosenblatt, and Eric Raymond. <em>Learning GNU Emacs</em>. OâReilly, 1996.
|[DA97] |Paul Dyson and Bruse Anderson. State patterns. In Robert Martin, Dirk Riehle, and Frank Buschmann, editors, <em>Pattern Languages of Program Design 3</em>. Addison Wesley, 1997.
|[Dav95] |Alan Mark Davis. <em>201 Principles of Software Development</em>. McGraw-Hill, 1995.
|[DD99] |Serge Demeyer and StÃ©phane Ducasse. Metrics, do they really help? In Jacques Malenfant, editor, <em>Proceedings of Languages et ModÃ¨les Ã  Objets (LMOâ99)</em>, pages 69â82. HERMES Science Publications, Paris, 1999.
|[DDL99] |Serge Demeyer, StÃ©phane Ducasse, and Michele Lanza. A hybrid reverse engineering platform combining metrics and program visualization. In Francoise Balmas, Mike Blaha, and Spencer Rugaber, editors, <em>Proceedings of 6th Working Conference on Reverse Engineering (WCRE â99)</em>. IEEE Computer Society, October 1999.
|[DDN00] a|
Serge Demeyer, StÃ©phane Ducasse, and Oscar Nierstrasz.</p>
</div>
<div class="paragraph">
<p>Finding refactorings via change metrics. In <em>Proceedings of 15th International Conference on Object-Oriented Programming, Systems, Languages, and Applications (OOPSLA â00)</em>, pages 166â 178, New York NY, 2000. ACM Press. Also appeared in ACM SIGPLAN Notices 35 (10).</p>
</div>
<div class="paragraph">
<p>|[DG97] |Serge Demeyer and Harald Gall, editors. <em>Proceedings of the ESEC/FSE Workshop on Object-Oriented Re-engineering</em>. TUV1841-97-10. Technical University of Vienna â Information Systems Institute â Distributed Systems Group, September 1997.
|[DL99] |Tom DeMarco and Timothy Lister. <em>Peopleware, Productive Projects and Teams</em>. Dorset House, 2nd edition, 1999.
|[DR98] a|
David E. DeLano and Linda Rising. Patterns for system testing. In Robert Martin, Dirk Riehle, and Frank Buschmann, editors, <em>Pattern Languages of Program Design 3</em>, pages 503â527.</p>
</div>
<div class="paragraph">
<p>Addison-Welsey, 1998.</p>
</div>
<div class="paragraph">
<p>|[DRD99] |StÃ©phane Ducasse, Matthias Rieger, and Serge Demeyer. A language independent approach for detecting duplicated code. In Hongji Yang and Lee White, editors, _Proceedings|</p>
</div>
<div class="paragraph">
<p><em>of 15th IEEE International Conference on Software Maintenance (ICSMâ99)</em>, pages 109â118. IEEE Computer Society, September 1999.</p>
</div>
<div class="paragraph">
<p>|
|[FBB<sup>+</sup>99] |Martin Fowler, Kent Beck, John Brant, William Opdyke, and Don Roberts. <em>Refactoring: Improving the Design of Existing Code</em>. Addison Wesley, 1999.
|[FH79] |R.K. Fjeldstad and W. T. Hamlen. Application program maintenance study: report to our respondents. In <em>Proceedings of GUIDE 48</em>. The Guide Corporation, 1979.
|[FMvW97] a|
Gert Florijn, Marco Meijers, and Pieter van Winsen. Tool support for object-oriented patterns. In Mehmet Aksit and Satoshi Matsuoka, editors, <em>Proceedings ECOOP â97</em>, volume 1241 of <em>LNCS</em>, pages 472â495, Jyvaskyla, Finland, June 1997.</p>
</div>
<div class="paragraph">
<p>Springer-Verlag.</p>
</div>
<div class="paragraph">
<p>|[Fow97] |Martin Fowler. <em>Analysis Patterns: Reusable Objects Models</em>. Addison Wesley, 1997.
|[FP96] |Norman Fenton and Shari Lawrence Pfleeger. <em>Software Metrics: A Rigorous and Practical Approach</em>. International Thomson Computer Press, London, UK, second edition, 1996.
|[Fro94] |Stuart Frost. Modelling for the rdbms legacy. <em>Object Magazine</em>, pages 43â51, September 1994.
|[FY00] |Brian Foote and Joseph W. Yoder. Big ball of mud. In N. Harrison, B. Foote, and H. Rohnert, editors, <em>Pattern Languages of Program Design</em>, volume 4, pages 654â692. Addison Wesley, 2000.
|[GG93] |Tom Gilb and Dorothy Graham. <em>Software Inspection</em>. Addison Wesley, 1993.
|[GHJ98] |Harald Gall, Karin Hajek, and Mehdi Jazayeri. Detection of logical coupling based on product release history. In <em>Proceedings International Conference on Software Maintenance (ICSM â98)</em>, pages 190â198, Los Alamitos CA, 1998. IEEE Computer Society Press.
|[GHJV95] |Erich Gamma, Richard Helm, Ralph Johnson, and John Vlissides. <em>Design Patterns: Elements of Reusable Object-Oriented Software</em>. Addison Wesley, Reading, Mass., 1995.
|[Gla97] |Robert L. Glass. <em>Building Quality Software</em>. Prentice-Hall, 1997.
|[GR95] |Adele Goldberg and Kenneth S. Rubin. _Succeeding With Ob-|</p>
</div>
<div class="paragraph">
<p>jects: Decision Frameworks for Project Management_. Addison Wesley, Reading, Mass., 1995.</p>
</div>
<div class="paragraph">
<p>|
|[GW99] |Harald Gall and Johannes Weidl. Object-model driven abstraction-to-code mapping. In <em>Proceedings of the 2nd Workshop on Object-Oriented Reengineering (WOOR 1999)</em>. Technical University of Vienna â Technical Report TUV-1841-99-13, 1999.
|[Har96] a|
Neil B. Harrison. Organizational patterns for teams. In John M. Vlissides, James O. Coplien, and Norman L. Kerth, editors, <em>Pattern Languages of Program Design 2</em>, pages 345â352.</p>
</div>
<div class="paragraph">
<p>Addison Wesley, 1996.</p>
</div>
<div class="paragraph">
<p>|[HEH<sup>^96] |J.-L. Hainaut, V. Englebert, J. Henrard, J.-M. Hick, and D. Roland. Database reverse engineering: From requirements to CARE tools. _Automated Software Engineering_, 3(1-2), June 1996.
|[Hel95] |Jonathan I. Helfman. Dotplot patterns: a literal look at pattern languages. _TAPOS_, 2(1):31â41, 1995.
|[IKM^</sup>97] |Dan Ingalls, Ted Kaehler, John Maloney, Scott Wallace, and Alan Kay. Back to the future: The story of Squeak, A practical Smalltalk written in itself. In <em>Proceedings OOPSLA â97, ACM SIGPLAN Notices</em>, pages 318â326. ACM Press, November 1997.
|[JAH01] |Ron Jeffries, Ann Anderson, and Chet Hendrickson. <em>Extreme Programming Installed</em>. Addison Wesley, 2001.
|[JC00] |Daniel Jackson and John Chapin. Redesigning air traffic control: An exercise in software design. <em>IEEE Software</em>, 17(3):63â 70, May 2000.
|[JCJO92] |Ivar Jacobson, Magnus Christerson, Patrik Jonsson, and Gunnar Overgaard. <em>Object-Oriented Software Engineering â A Use Case Driven Approach</em>. Addison Wesley/ACM Press, Reading, Mass., 1992.
|[JGJ97] |Ivar Jacobson, Martin Griss, and Patrik Jonsson. <em>Software Reuse</em>. Addison Wesley/ACM Press, 1997.
|[JGR99] a|
Mehdi Jazayeri, Harald Gall, and Claudio Riva. Visualizing</p>
</div>
<div class="paragraph">
<p>Software Release Histories: The Use of Color and Third Di-</p>
</div>
<div class="paragraph">
<p>|</p>
</div>
<div class="paragraph">
<p>mension. In <em>Proceedings of ICSM â99 (International Conference on Software Maintenance)</em>, pages 99â108. IEEE Computer Society Press, 1999.</p>
</div>
<div class="paragraph">
<p>|
|[JS96] |Dean F. Jerding and John T. Stasko. The information mural: Increasing information bandwidth in visualizations. Technical Report GIT-GVU-96-25, Georgia Institute of Technology, October 1996.
|[JSZ97] |Jens. H. Jahnke, Wilhelm. SchÃ¤fer, and Albert. ZÃ¼ndorf. Generic fuzzy reasoning nets as a basis ofr reverse engineering relational database applications. In <em>Proceedings of ESEC/FSE â97</em>, number 1301 in LNCS, pages 193â210, 1997. inproceedings.
|[KC98a] |Rick Kazman and S. Jeromy Carriere. View extraction and view fusion in architectural understanding. In <em>Proceedings of the 5th International Conference on Software Reuse</em>, Victoria, B.C., 1998.
|[KC98b] |Wolfgang Keller and Jens Coldewey. Accessing relational databases: A pattern language. In Robert Martin, Dirk Riehle, and Frank Bushmann, editors, <em>Pattern Languages of Program Design 3</em>, pages 313â343. Addison Wesley, 1998.
|[KC99] |Rick Kazman and S. J. Carriere. Playing detective: Reconstructing software architecture from available evidence. <em>Automated Software Engineering</em>, April 1999.
|[Kel00] |Wolfgang Keller. The bridge to the new town â a legacy system migration pattern. In <em>Proceedings of EuroPLoP 2000</em>, 2000.
|[Knu92] |Donald E. Knuth. <em>Literate Programming</em>. Stanford, California: Center for the Study of Language and Information, 1992.
|[Lan99] |Michele Lanza. Combining Metrics and Graphs for Object Oriented Reverse Engineering. Diploma Thesis, University of Bern, October 1999.
|[LB85] |Manny Lehman and Les Belady. <em>Program Evolution: Processes of Software Change</em>. London Academic Press, London, 1985.
|[Lea96] |Doug Lea. <em>Concurrent Programming in Java, Design Principles and Patterns</em>. The Java Series. Addison Wesley, 1996.
|[LHR88] |Karl J. Lieberherr, Ian M. Holland, and Arthur Riel. Objectoriented programming: An objective sense of style. In _Pro-|</p>
</div>
<div class="paragraph">
<p><em>ceedings OOPSLA â88, ACM SIGPLAN Notices</em>, volume 23, pages 323â334, November 1988.</p>
</div>
<div class="paragraph">
<p>|
|[LK94] |Mark Lorenz and Jeff Kidd. <em>Object-Oriented Software Metrics: A Practical Guide</em>. Prentice-Hall, 1994.
|[Lov93] |Tom Love. <em>Object Lessons â Lessons Learned in Object-Oriented Development Projects</em>. SIGS Books, New York, 1993.
|[LPM<sup>^97] |Bruno LaguÃ«, Daniel Proulx, Ettore M. Merlo, Jean Mayrand, and John Hudepohl. Assessing the benefits of incorporating function clone detection in a development process. In _Proceedings of ICSM (International Conference on Software Maintenance)_. IEEE, 1997.
|[Mar82] |Tom De Marco. _Controlling Software Projects_. Yourdon Press, 1982.
|[Mey96] |Scott Meyers. _More Effective C_. Addison Wesley, 1996.
|[Mey98] |Scott Meyers. _Effective C_. Addison Wesley, second edition, 1998.
|[MJS^</sup>00] |Hausi A. MÃ¼ller, Jens H. Janhke, Dennis B. Smith, MargaretAnne Storey, Scott R. Tilley, and Kenny Wong. Reverse engineering: A roadmap. In A. Finkelstein, editor, <em>The Future of Software Engineering 2000</em>. ACM Press, 2000.
|[MLM96] |Jean Mayrand, Claude Leblanc, and Ettore M. Merlo. Experiment on the automatic detection of function clones in a software system using metrics. In <em>International Conference on Software Maintenance (ICSM)</em>, pages 244â253, 1996.
|[MN97] |Gail C. Murphy and David Notkin. Reengineering with reflexion models: A case study. <em>IEEE Computer</em>, 8:29â36, 1997.
|[Nes88] |Paolo Nesi. Managing OO project better. <em>IEEE Software</em>, July 1988.
|[Nie99] |Jakob Nielsen. <em>Usability Engineering</em>. Morgan Kaufmann, 1999.
|[OâC00] |Alan OâCallaghan. Patterns for architectural praxis. In <em>Proceedings of EuroPLoP 2000</em>, 2000.
|[ODF99] |Alan OâCallaghan, Ping Dai, and Ray Farmer. Patterns for change â sample patterns from the adaptor pattern language. In <em>Proceedings of EuroPLoP 1999</em>, 1999.
|[PB94] |William J. Premerlani and Michael R. Blaha. An approach for reverse engineering of relational databases. <em>Communications of the ACM</em>, 37(5):42â49, May 1994.
|</p>
</div>
<div class="paragraph">
<p>|
|[PK82] a|
J. Pustell and F. Kafatos. A high speed, high capacity homology matrix: Zooming through SV40 and polyoma. <em>Nucleid
_Acids Research</em>, 10(15):4765â4782, 1982.</p>
</div>
<div class="paragraph">
<p>|[PK01] |Joseph Pelrine and Alan Knight. <em>Mastering ENVY/Developer</em>. Cambridge University Press, 2001.
|[Pre94] |Roger S. Pressman. <em>Software Engineering: A Practitionerâs Approach</em>. McGraw-Hill, 1994.
|[RBCM91] |D.J. Robson, K. H. Bennet, B. J. Cornelius, and M. Munro. Approaches to program comprehension. <em>Journal of Systems and Software</em>, 14:79â84, February 1991. Republished in [Arno92a].
|[RBJ97] |Don Roberts, John Brant, and Ralph E. Johnson. A refactoring tool for Smalltalk. <em>Theory and Practice of Object Systems (TAPOS)</em>, 3(4):253â263, 1997.
|[RD99] |Tamar Richner and StÃ©phane Ducasse. Recovering highlevel views of object-oriented applications from static and dynamic information. In Hongji Yang and Lee White, editors, <em>Proceedings of 15th IEEE International Conference on Software Maintenance (ICSMâ99)</em>, pages 13â22, Los Alamitos CA, September 1999. IEEE Computer Society Press.
|[Ree96] |Trygve Reenskaug. <em>Working with Objects: The OOram Software Engineering Method</em>. Manning Publications, 1996.
|[RG98] |Dirk Riehle and Thomas Gross. Role model based framework design and integration. In <em>Proceedings OOPSLA â98, ACM SIGPLAN Notices</em>, pages 117â133, October 1998.
|[Rie96] |Arthur Riel. <em>Object-Oriented Design Heuristics</em>. Addison Wesley, Boston MA, 1996.
|[Ris00] |Linda Rising. Customer interaction patterns. In Neil Harrison, Brian Foote, and Hans Rohnert, editors, <em>Pattern Languages of Program Design 4</em>, pages 585â609. Addison Wesley, 2000.
|[Rob99] |Donald Bradley Roberts. <em>Practical Analysis for Refactoring</em>. PhD thesis, University of Illinois, 1999.
|[RS89] a|
Trygve Reenskaug and Anna Lise Skaar. An environment for literate Smalltalk programming. In <em>Proceedings OOPSLA â89, ACM SIGPLAN Notices</em>, volume 24, pages 337â346, October</p>
</div>
<div class="paragraph">
<p>1989.</p>
</div>
<div class="paragraph">
<p>|</p>
</div>
<div class="paragraph">
<p>|
|[RW98] |Spencer Rugaber and Jim White. Restoring a legacy: Lessons learned. <em>IEEE Software</em>, 15(4):28â33, July 1998.
|[SG96] |Mary Shaw and David Garlan. <em>Software Architecture: Perspectives on an Emerging Discipline</em>. Prentice-Hall, 1996.
|[Sha97] |Alec Sharp. <em>Smalltalk by Example</em>. McGraw-Hill, 1997.
|[SLMD96] |Patrick Steyaert, Carine Lucas, Kim Mens, and Theo DâHondt. Reuse Contracts: Managing the Evolution of Reusable Assets. In <em>Proceedings of OOPSLA â96 (International Conference on Object-Oriented Programming, Systems, Languages, and Applications)</em>, pages 268â285. ACM Press, 1996.
|[Sne99] |Harry M. Sneed. Risks involved in reengineering projects. In <em>Proceedings of the 6th Working Conference on Reverse Engineering (WCRE)</em>. IEEE, 1999.
|[Som96] |Ian Sommerville. <em>Software Engineering</em>. Addison Wesley, fifth edition, 1996.
|[SP98] |Perdita Stevens and Rob Pooley. System reengineering patterns. In <em>Proceedings of FSE-6</em>. ACM-SIGSOFT, 1998.
|[SRMK99] |Reinhard Schauer, SÃ©bastian Robitaille, Francois Martel, and Rudolf Keller. Hot-Spot Recovery in Object-Oriented Software with Inheritance and Composition Template Methods. In <em>Proceedings of ICSM â99 (International Conference on Software Maintenance)</em>. IEEE Computer Society Press, 1999.
|[SSRB00] |Douglas C. Schmidt, Michael Stal, Hans Rohnert, and Frank Buschmann. <em>Pattern-Oriented Software Architecture Volume 2 â Networked and Concurrent Objects</em>. John Wiley and Sons, 2000.
|[SW98] |Geri Schneider and Jason P. Winters. <em>Applying Use Cases</em>. Addison Wesley, 1998.
|[Tay00] |Paul Taylor. Capable, productive, and satisfied: Some organizational patterns for protecting productive people. In N. Harrison, B. Foote, and H. Rohnert, editors, <em>Pattern Languages of Program Design</em>, volume 4, pages 611â636. Addison Wesley, 2000.
|[Tho98] |Rob Thomsett. The year 2000 bug: a forgotten lesson. <em>IEEE Software</em>, 15(4):91â93,95, July 1998.
|</p>
</div>
<div class="paragraph">
<p>|
|[WBWW90] Rebecca Wirfs-Brock, Brian Wilkerson, and Lauren Wiener.
| |<em>Designing Object-Oriented Software</em>. Prentice-Hall, 1990.
|[WG98] |Johannes Weidl and Harald Gall. Binding object models to source code: An approach to object-oriented rearchitecting. In <em>Proceedings of the 22nd Computer Software and Application Conference (COMPSAC 1998)</em>. IEEE Computer Society Press, 1998.
|[Woo98] |Bobby Woolf. Null object. In Robert Martin, Dirk Riehle, and Frank Buschmann, editors, <em>Pattern Languages of Program Design 3</em>, pages 5â18. Addison Wesley, 1998.
|[WTMS95] a|
Kenny Wong, Scott R. Tilley, Hausi A. MÃ¼ller, and MargaretAnne D. Storey. Structural redocumentation: A case study.</p>
</div>
<div class="paragraph">
<p><em>IEEE Software</em>, 12(1):46â54, January 1995.</p>
</div>
<div class="paragraph">
<p>|[Wuy98] |Roel Wuyts. Declarative reasoning about the structure objectoriented systems. In <em>Proceedings of the TOOLS USA â98 Conference</em>, pages 112â124. IEEE Computer Society Press, 1998.
|[You97] |Edward Yourdon. <em>Death March</em>. Prentice-Hall, 1997.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="appendix"><a class="anchor" href="#appendix"></a>Appendix</h2>
<div class="sectionbody">
<div class="sect2">
<h3 id="praise-for-object-oriented-reengineering-patterns"><a class="anchor" href="#praise-for-object-oriented-reengineering-patterns"></a>Praise</h3>
<div class="paragraph">
<p><em>for the original Object-Oriented Reengineering Patterns book</em></p>
</div>
<div class="quoteblock">
<blockquote>
<div class="paragraph">
<p>âHowâ to refactor is already well covered in the literature. However, âWhenâ and âWhyâ can only be learned by experience. This book will give you a head start in learning when to start redesigning a system, when to stop for now, and what effects you can expect to see from your efforts.</p>
</div>
</blockquote>
<div class="attribution">
&#8212; Kent Beck<br>
<cite>Director, Three Rivers Institute</cite>
</div>
</div>
<div class="quoteblock">
<blockquote>
<div class="paragraph">
<p>This book is full of practical, hands-on reengineering knowledge and expertise presented in a form that makes it easy to understand and use. The patterns in this book thus help everyone who is concerned with using reengineering to guide their work. I wish I had had this book in my library earlier.</p>
</div>
</blockquote>
<div class="attribution">
&#8212; Frank Buschmann<br>
<cite>Senior Principal Engineer Siemens AG</cite>
</div>
</div>
<div class="quoteblock">
<blockquote>
<div class="paragraph">
<p>This book is more than its title advertises. Effective reengineering is really about purposeful and efficient reading of someone elseâs code in order to produce predictable change. The same processes the authors highlight as patterns of skillful reengineering behavior can easily be cast as the skills you need to create readable, maintainable software systems.</p>
</div>
</blockquote>
<div class="attribution">
&#8212; Adele Goldberg<br>
<cite>Neometron, Inc.</cite>
</div>
</div>
<div class="quoteblock">
<blockquote>
<div class="paragraph">
<p>If a guy named Dave brought a large box to my office that contained a lot of documentation and two CDs-installation disks for software that my company wanted to reengineer â Iâd be happy to have the authors of this book by my side. Barring that, having their book is the next best thing. No silver bullets, no hype, no promises that this will be easy â just a down-toearth, easy-to-read, extremely useful book of helpful guidelines to tackle the project. Buy this book and browse it before Dave arrives in your office! It just might save you and your company a lot of grief.</p>
</div>
</blockquote>
<div class="attribution">
&#8212; ]Linda Rising<br>
<cite>Independent Consultant</cite>
</div>
</div>
</div>
<div class="sect2">
<h3 id="foreword"><a class="anchor" href="#foreword"></a>Foreword</h3>
<div class="sect3">
<h4 id="foreword-by-martin-fowler"><a class="anchor" href="#foreword-by-martin-fowler"></a>Foreword by Martin Fowler</h4>
<div class="paragraph">
<p>For a long time itâs puzzled me that most books on software development processes talk about what to do when you are starting from a blank sheet of editor screen. Itâs puzzled me because thatâs not the most common situation that people write code in. Most people have to make changes to an existing code base, even if itâs their own. In an ideal world this code base is well designed and well factored, but we all know how often the ideal world appears in our career.</p>
</div>
<div class="paragraph">
<p>So this book is important because itâs written from the perspective of what to do with an imperfect yet valuable code base. I also like the fact that itâs based on an effective mix of academic and industrial work. I visited the FAMOOS group in their early days during a chill early winter in Bern. I liked the way that they cycled between the field and the lab, trying out ideas on real projects, coming back to the lab to reflect.</p>
</div>
<div class="paragraph">
<p>This resulting book speaks with that experience. It gives you the building blocks for a plan to tackle a difficult code base, it gives you context for techniques like refactoring. It is a sad fact that there are too few of these kinds of books out there, when reengineering is still a common event. But Iâm at least glad to see that while there arenât many books in this vein, this book is an example of how good they are.</p>
</div>
<div class="paragraph">
<p>Martin Fowler, <em>Thought Works, Inc.</em></p>
</div>
</div>
<div class="sect3">
<h4 id="foreword-by-ralph-e.-johnson"><a class="anchor" href="#foreword-by-ralph-e.-johnson"></a>Foreword by Ralph E. Johnson</h4>
<div class="paragraph">
<p>One of the signs of a good pattern is that experts who read it are likely to say âof course, everybody knows thatâ but beginners are likely to say âinteresting, but will it work?â Patterns should be easy to follow, but the most valuable patterns are those that are not obvious. Experts have learned from experience that the patterns work, but beginners have to take the patterns on faith until they use them and develop their own experience.</p>
</div>
<div class="paragraph">
<p>Over the last couple of years, Iâve had the chance to give the patterns in this book to a wide variety of people and discuss them. My pattern discussion group has a few members who have decades of consulting experience, and they could quickly regale the group with stories of using these patterns. The younger members loved the stories as they were convinced of the value of the patterns.</p>
</div>
<div class="paragraph">
<p>I made students in my software engineering class read some of the patterns as part of a section on reengineering. The section went well even though none of the students got excited by the patterns. They didnât have the experience to evaluate them. However, one of the students came back to me after his summer job and said that of everything in the course, the material that was the most useful was the patterns on reverse engineering. Before that experience, the patterns seemed believable. Afterwards, they were believed!</p>
</div>
<div class="paragraph">
<p>If you have a lot of experience with software reengineering then you probably wonât learn much from this book. You should read it anyway, because youâll want to give copies to people you work with, and you will want to use the vocabulary of the book when you talk with them. If you are new to reengineering, you should read the book, learn the patterns, and try them. You will learn a lot that will be valuable. Donât expect to understand the patterns completely before you try them, because patterns are practical, and practical knowledge has to be experienced to be fully understood. Nevertheless, the book will give you a big advantage. It is much easier to learn when you have a path to follow, and this book provides a reliable guide.</p>
</div>
<div class="paragraph">
<p>Ralph E. Johnson, <em>University of Illinois at Urbana-Champaign</em>*</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="acknowledgments"><a class="anchor" href="#acknowledgments"></a>Acknowledgments</h3>
<div class="paragraph">
<p>We would like to thank first and foremost our FAMOOS partners at Nokia, Daimler-Benz, FZI and Sema who provided the context for discovering these patterns. Persons like Juha (Julho) Tuominen, Roland Trauter, Eduardo Casais and Theo Dirk Meijler played a crucial role while starting the project. We would especially like to thank our co-authors of the prototype for this book, <em>The FAMOOS Object-Oriented Reengineering Handbook:</em> Holger BÃ¤r, Markus Bauer, Oliver Ciupke, Michele Lanza, Radu Marinescu, Robb Nebbe, Michael Przybilski, Tamar Richner, Matthias Rieger, Claudio Riva, Anne-Marie Sassen, Benedikt Schulz, Patrick Steyaert, Sander Tichelaar and Joachim Weisbrod.</p>
</div>
<div class="paragraph">
<p>We gratefully acknowledge the financial support of the European Union towards ESPRIT project 21975 (FAMOOS) as well as that of the Swiss Government towards projects NFS-2000-46947.96 and BBW-96.0015. The University of Antwerp provided financial support in terms of a grant entitled âObject Oriented Reengineeringâ while the Fund for Scientific Research in Flanders sponsored by means of a research network named âFoundations of Software Evolutionâ.</p>
</div>
<div class="paragraph">
<p>Some of the material in this book was presented in the graduate course âObject-Oriented software Reengineeringâ held at the University of Bern in the winter semesters of 1998 and 1999, and at several tutorials at OOPSLA. We would like to thank the participants of the courses and tutorials for their feedback and input. We also would like to thank members of the Software Composition Group at the University of Bern for participating in several pattern workshops and giving valuable feedback on many of the patterns in this book: Michele Lanza, Pietro Malorgio, Robbe Nebbe, Tamar Richner, Matthias Rieger and Sander Tichelaar.</p>
</div>
<div class="paragraph">
<p>Several of the patterns in this book have been presented elsewhere. We would like to thank our EuroPLoP shepherds Kent Beck (1998), Kyle Brown (1999), Neil Harrison (2000), Mary Lynn Manns (2000), Don Roberts (1998) and Charles Weir (1998) and all participants of the writersâ workshops where these patterns have been discussed. Special thanks go to Jens Coldewey for helping us out with pattern forms and forces.</p>
</div>
<div class="paragraph">
<p>We would like to thank the members and friends of Ralph Johnsonâs Software Architecture Group who workshopped several chapters of this book: John Brant, Brian Foote, Alejandra Garrido, Peter Hatch, Ralph Johnson, Brian Marick, Andrew Rosenfeld, Weerasak Witthawaskul and Joe Yoder. Downloading and playing voluminous megabytes of workshop recordings in mp3 format truly made each of us feel like a âfly on the wallâ!</p>
</div>
<div class="paragraph">
<p>We would like to thank Tim Cox, our editor, and Stacie Pierce, his assistant, both at Morgan Kaufmann, for following our project with such dedication. Also, thanks to Christa Preisendanz at DPunkt Verlag for putting us in touch with Tim in the first place! We especially appreciated the two very thorough rounds of reviews that this book underwent, and we only regret that the final draft of this book is nothing like the definitive work some of reviewers clearly hoped it would be! We thank our reviewers for reading between the lines and helping to explain many of these patterns to us: Kyle Brown, Thierry Cattel, Oliver Ciupke, Koen De Hondt, Jim Coplien, Gert Florijn, Neil Harrison, Mary Lynn Manns, Alan OâCallaghan, Don Roberts and Benedikt Schulz.</p>
</div>
</div>
</div>
</div>
</div>
<div id="footnotes">
<hr>
<div class="footnote" id="_footnote_1">
<a href="#_footnoteref_1">1</a>. During the FAMOOS project we faced systems ranging between 500.000 lines of C++ and 2.5 million lines of Ada.
</div>
<div class="footnote" id="_footnote_2">
<a href="#_footnoteref_2">2</a>. In one particular reverse engineering experience, we were facing source code that was a mixture of English and German. As you may expect, this complicates matters a lot.
</div>
<div class="footnote" id="_footnote_3">
<a href="#_footnoteref_3">3</a>. Most metric tools allow you to focus on special entities by specifying some threshold interval and then only displaying those entities where the measurements fall into that interval.
</div>
<div class="footnote" id="_footnote_4">
<a href="#_footnoteref_4">4</a>. Metrics theory prohibits arbitrary manipulations of numbers; one should first verify whether the scale of the measurement permits the calculation [FP96
</div>
<div class="footnote" id="_footnote_5">
<a href="#_footnoteref_5">5</a>. Note that some configuration management systems keep track of renaming operations which will of course alleviate the problem.
</div>
</div>
<div id="footer">
<div id="footer-text">
Version 0.01-alpha<br>
Last updated 2017-01-27 10:16:42 MEZ
</div>
</div>
</body>
</html>